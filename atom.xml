<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小玉的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.devzou.com/"/>
  <updated>2019-12-02T14:42:51.367Z</updated>
  <id>https://blog.devzou.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Proxy CONNECT aborted due to timeout</title>
    <link href="https://blog.devzou.com/2019/11/15/git/2019-12-02-git_Proxy_CONNECT_aborted_due_to_timeout/"/>
    <id>https://blog.devzou.com/2019/11/15/git/2019-12-02-git_Proxy_CONNECT_aborted_due_to_timeout/</id>
    <published>2019-11-15T00:10:09.000Z</published>
    <updated>2019-12-02T14:42:51.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天在clone  github上的源码时报错如下<br><img src="/img/git/git_proxy_01.png" alt=""></p><h2 id="fq配置如下"><a href="#fq配置如下" class="headerlink" title="fq配置如下"></a>fq配置如下</h2><p><img src="/img/git/git_proxy_02.png" alt=""></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1086&apos;</div><div class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1086&apos;</div></pre></td></tr></table></figure><p>git config –global –list 显示git config global配置信息。<br>再次git clone xxx 即可。<br>如需要对应还原git proxy，可以使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global --unset http.proxy</div><div class="line">git config --global --unset https.proxy</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;今天在clone  github上的源码时报错如下&lt;br&gt;&lt;img src=&quot;/img/git/git_proxy_01.png&quot; alt=
      
    
    </summary>
    
      <category term="资源" scheme="https://blog.devzou.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Git" scheme="https://blog.devzou.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.devzou.com/2019/10/24/ios/2019-10-24-NSURLProtocol/"/>
    <id>https://blog.devzou.com/2019/10/24/ios/2019-10-24-NSURLProtocol/</id>
    <published>2019-10-24T04:26:10.335Z</published>
    <updated>2019-10-30T07:48:26.340Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: NSURLProtocol<br>category: iOS<br>date: 2016-7-30 9:10:09<br>tags: iOS</p><h2 id="keywords-NSURLProtocol"><a href="#keywords-NSURLProtocol" class="headerlink" title="keywords: NSURLProtocol"></a>keywords: NSURLProtocol</h2><p>NSURLProtocol能够让你去重新定义苹果的URL加载系统 (URL Loading System)的行为，URL Loading System里有许多类用于处理URL请求，比如NSURL，NSURLRequest，NSURLConnection和NSURLSession等，当URL Loading System使用NSURLRequest去获取资源的时候，它会创建一个NSURLProtocol子类的实例，你不应该直接实例化一个NSURLProtocol，NSURLProtocol看起来像是一个协议，但其实这是一个类，而且必须使用该类的子类，并且需要被注册。<br><img src="![](/img/ios/url_loading_system/loading-system.png" alt="">)</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/documentation/foundation/nsurlprotocol?language=occ" target="_blank" rel="external">https://developer.apple.com/documentation/foundation/nsurlprotocol?language=occ</a><br><a href="https://developer.apple.com/library/ios/samplecode/CustomHTTPProtocol/CustomHTTPProtocol.zip" target="_blank" rel="external">官方Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: NSURLProtocol&lt;br&gt;category: iOS&lt;br&gt;date: 2016-7-30 9:10:09&lt;br&gt;tags: iOS&lt;/p&gt;
&lt;h2 id=&quot;keywords-NSURLProtocol&quot;&gt;&lt;a href=&quot;#keywords
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL 数据类型</title>
    <link href="https://blog.devzou.com/2019/10/18/mysql/2019-10-19-MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://blog.devzou.com/2019/10/18/mysql/2019-10-19-MySQL 数据类型/</id>
    <published>2019-10-18T01:10:09.000Z</published>
    <updated>2019-10-19T23:24:44.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。<br>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>MySQL支持所有标准SQL数值数据类型。<br>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。<br>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。<br>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。<br>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。<br><img src="/img/mysql/mysql_1/01.png" alt=""></p><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。<br>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。<br>TIMESTAMP类型有专有的自动更新特性，将在后面描述。<br><img src="/img/mysql/mysql_1/02.png" alt=""></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。<br><img src="/img/mysql/mysql_1/03.png" alt=""><br>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MySQL中定义数据字段的类型对你数据库的优化是非常重要的。&lt;br&gt;MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符
      
    
    </summary>
    
      <category term="mysql" scheme="https://blog.devzou.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.devzou.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql权限管理</title>
    <link href="https://blog.devzou.com/2019/10/18/mysql/2019-10-18-mysql%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://blog.devzou.com/2019/10/18/mysql/2019-10-18-mysql权限管理/</id>
    <published>2019-10-18T01:10:09.000Z</published>
    <updated>2019-10-17T22:08:22.767Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="mysql" scheme="https://blog.devzou.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.devzou.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JAVA数据库连接之JDBC</title>
    <link href="https://blog.devzou.com/2019/08/12/Java/2019-10-21-Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%B9%8BJDBC/"/>
    <id>https://blog.devzou.com/2019/08/12/Java/2019-10-21-Java数据库连接之JDBC/</id>
    <published>2019-08-12T00:10:09.000Z</published>
    <updated>2019-10-21T13:52:10.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JDBC (Java Database Connectivity) API，即Java数据库编程接口，是连接java应用程序和数据库之间的桥粱，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。比如建立数据库连接、执行SQL语句进行数据的存取操作。</p><h2 id="JDBC使用详解"><a href="#JDBC使用详解" class="headerlink" title="JDBC使用详解"></a>JDBC使用详解</h2><h3 id="1-加载驱动器类"><a href="#1-加载驱动器类" class="headerlink" title="1.加载驱动器类"></a>1.加载驱动器类</h3><h3 id="2-建立与数据库的链接"><a href="#2-建立与数据库的链接" class="headerlink" title="2.建立与数据库的链接"></a>2.建立与数据库的链接</h3><h3 id="3-创建statement对象"><a href="#3-创建statement对象" class="headerlink" title="3.创建statement对象"></a>3.创建statement对象</h3><h3 id="4-执行SQL语句"><a href="#4-执行SQL语句" class="headerlink" title="4.执行SQL语句"></a>4.执行SQL语句</h3><h3 id="5-访问ResultSet的记录"><a href="#5-访问ResultSet的记录" class="headerlink" title="5.访问ResultSet的记录"></a>5.访问ResultSet的记录</h3><h3 id="6-依次关闭ResultSet、Statement、Connection对象"><a href="#6-依次关闭ResultSet、Statement、Connection对象" class="headerlink" title="6.依次关闭ResultSet、Statement、Connection对象"></a>6.依次关闭ResultSet、Statement、Connection对象</h3><p>示例代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String DRIVER_NAME = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String URL = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String USER_NAME = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String PWD = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">    <span class="keyword">static</span>  &#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            properties.load(DBUtil.class.getResourceAsStream(<span class="string">"/jdbc.properties"</span>));</div><div class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            System.out.println(<span class="string">"系统加载jdbc.properties配置文件异常"</span>);</div><div class="line">        &#125;</div><div class="line">        DRIVER_NAME = properties.getProperty(<span class="string">"jdbc.driver"</span>);</div><div class="line">        URL = properties.getProperty(<span class="string">"jdbc.url"</span>);</div><div class="line">        USER_NAME = properties.getProperty(<span class="string">"jdbc.username"</span>);</div><div class="line">        PWD = properties.getProperty(<span class="string">"jdbc.password"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class.forName(DRIVER_NAME);</div><div class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            System.out.println(<span class="string">"数据库驱动加载异常，请检查"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//        DriverManager.registerDriver(new Driver());</span></div><div class="line">        Connection connection = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">            connection = DriverManager.getConnection(URL, USER_NAME, PWD);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            System.out.println(e);</div><div class="line">            System.out.println(<span class="string">"连接数据库失败了"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  connection;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection connection)</span> </span>&#123;</div><div class="line">        close(connection);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection connection, Statement statement, ResultSet resultSet)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (resultSet !=<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!resultSet.isClosed()) &#123;</div><div class="line">                    resultSet.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (connection !=<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!connection.isClosed()) &#123;</div><div class="line">                    connection.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (statement !=<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!statement.isClosed()) &#123;</div><div class="line">                    statement.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JDBC (Java Database Connectivity) API，即Java数据库编程接口，是连接java应用程序和数据库之间的桥
      
    
    </summary>
    
      <category term="Java" scheme="https://blog.devzou.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.devzou.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发之servlet、Filter、Listener</title>
    <link href="https://blog.devzou.com/2019/08/12/Java/2019-10-25-servlet%E3%80%81Filer%E3%80%81Listener/"/>
    <id>https://blog.devzou.com/2019/08/12/Java/2019-10-25-servlet、Filer、Listener/</id>
    <published>2019-08-12T00:10:09.000Z</published>
    <updated>2019-10-25T00:10:06.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet 是服务端的 Java 应用程序，用于处理HTTP请求，做出相应的响应。</p><p>当客户端向服务器发出HTTP请求时，首先会由服务器中的 Web 容器（如Tomcat）对请求进行路由，交给该URL对应的 Servlet 进行处理，Servlet 所要做的事情就是返回适当的内容给用户。</p><p>要创建自己的 Servlet，可以通过以下三种方式来实现</p><ul><li>实现 Servlet 接口</li><li>继承 GenericServlet 类</li><li>继承 HttpServlet 类</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h2&gt;&lt;p&gt;Servlet 是服务端的 Java 应用程序，用于处理HTTP请求，做出相应的响应。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Java" scheme="https://blog.devzou.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.devzou.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 异步函数之Stream</title>
    <link href="https://blog.devzou.com/2019/08/11/flutter/2019-12-11-Flutter%20%E5%BC%82%E6%AD%A5%E4%B9%8BStream/"/>
    <id>https://blog.devzou.com/2019/08/11/flutter/2019-12-11-Flutter 异步之Stream/</id>
    <published>2019-08-11T01:10:09.000Z</published>
    <updated>2019-12-11T15:38:36.773Z</updated>
    
    <content type="html"><![CDATA[<p>Stream 也是用于接收异步事件数据，和Future 不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Stream.fromFutures([</div><div class="line">  <span class="comment">// 1秒后返回结果</span></div><div class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"hello 1"</span>;</div><div class="line">  &#125;),</div><div class="line">  <span class="comment">// 抛出一个异常</span></div><div class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),()&#123;</div><div class="line">    <span class="keyword">throw</span> AssertionError(<span class="string">"Error"</span>);</div><div class="line">  &#125;),</div><div class="line">  <span class="comment">// 3秒后返回结果</span></div><div class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"hello 3"</span>;</div><div class="line">  &#125;)</div><div class="line">]).listen((data)&#123;</div><div class="line">   <span class="built_in">print</span>(data);</div><div class="line">&#125;, onError: (e)&#123;</div><div class="line">   <span class="built_in">print</span>(e.message);</div><div class="line">&#125;,onDone: ()&#123;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>上面的代码依次会输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hello 1</div><div class="line">Error</div><div class="line">hello 3</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Stream 也是用于接收异步事件数据，和Future 不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 异步之async/await</title>
    <link href="https://blog.devzou.com/2019/08/10/flutter/2019-12-11-Dart%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E4%B9%8Basync:await/"/>
    <id>https://blog.devzou.com/2019/08/10/flutter/2019-12-11-Dart异步函数之async:await/</id>
    <published>2019-08-10T01:10:09.000Z</published>
    <updated>2019-12-11T15:34:11.010Z</updated>
    
    <content type="html"><![CDATA[<p>Dart中的async/await 和JavaScript中的async/await功能和用法是一模一样的，如果你已经了解JavaScript中的async/await的用法，可以直接跳过本节。<br><strong>回调地狱(Callback Hell)</strong><br>如果代码中有大量异步逻辑，并且出现大量异步任务依赖其它异步任务的结果时，必然会出现Future.then回调中套回调情况。举个例子，比如现在有个需求场景是用户先登录，登录成功后会获得用户ID，然后通过用户ID，再去请求用户个人信息，获取到用户个人信息后，为了使用方便，我们需要将其缓存在本地文件系统，代码如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先分别定义各个异步任务</span></div><div class="line">Future&lt;<span class="built_in">String</span>&gt; login(<span class="built_in">String</span> userName, <span class="built_in">String</span> pwd)&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">//用户登录</span></div><div class="line">&#125;;</div><div class="line">Future&lt;<span class="built_in">String</span>&gt; getUserInfo(<span class="built_in">String</span> id)&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">//获取用户信息 </span></div><div class="line">&#125;;</div><div class="line">Future saveUserInfo(<span class="built_in">String</span> userInfo)&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 保存用户信息 </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>接下来，执行整个任务流<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">login(<span class="string">"alice"</span>,<span class="string">"******"</span>).then((id)&#123;</div><div class="line"> <span class="comment">//登录成功后通过，id获取用户信息    </span></div><div class="line"> getUserInfo(id).then((userInfo)&#123;</div><div class="line">    <span class="comment">//获取用户信息后保存 </span></div><div class="line">    saveUserInfo(userInfo).then(()&#123;</div><div class="line">       <span class="comment">//保存用户信息，接下来执行其它操作</span></div><div class="line">        ...</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为回调地狱（Callback Hell）。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了Promise，以及ECMAScript7中引入的async/await。 而在Dart中几乎是完全平移了JavaScript中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过Future和async/await如何消除上面示例中的嵌套问题。<br><strong>使用Future消除Callback Hell</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">login(<span class="string">"alice"</span>,<span class="string">"******"</span>).then((id)&#123;</div><div class="line">      <span class="keyword">return</span> getUserInfo(id);</div><div class="line">&#125;).then((userInfo)&#123;</div><div class="line">    <span class="keyword">return</span> saveUserInfo(userInfo);</div><div class="line">&#125;).then((e)&#123;</div><div class="line">   <span class="comment">//执行接下来的操作 </span></div><div class="line">&#125;).catchError((e)&#123;</div><div class="line">  <span class="comment">//错误处理  </span></div><div class="line">  <span class="built_in">print</span>(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>正如上文所述， “Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用” ，如果在then中返回的是一个Future的话，该future会执行，执行结束后会触发后面的then回调，这样依次向下，就避免了层层嵌套。<br><strong>使用async/await消除callback hell</strong><br>通过Future回调中再返回Future的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用async/await了，下面我们先直接看代码，然后再解释，代码如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">task() <span class="keyword">async</span> &#123;</div><div class="line">   <span class="keyword">try</span>&#123;</div><div class="line">    <span class="built_in">String</span> id = <span class="keyword">await</span> login(<span class="string">"alice"</span>,<span class="string">"******"</span>);</div><div class="line">    <span class="built_in">String</span> userInfo = <span class="keyword">await</span> getUserInfo(id);</div><div class="line">    <span class="keyword">await</span> saveUserInfo(userInfo);</div><div class="line">    <span class="comment">//执行接下来的操作   </span></div><div class="line">   &#125; <span class="keyword">catch</span>(e)&#123;</div><div class="line">    <span class="comment">//错误处理   </span></div><div class="line">    <span class="built_in">print</span>(e);   </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>async用来表示函数是异步的，定义的函数会返回一个Future对象，可以使用then方法添加回调函数。</li><li>await 后面是一个Future，表示等待该异步任务完成，异步完成后才会往下走；await必须出现在 async 函数内部。<br>可以看到，我们通过async/await将一个异步流用同步的代码表示出来了。<blockquote><p> 其实，无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dart中的async/await 和JavaScript中的async/await功能和用法是一模一样的，如果你已经了解JavaScript中的async/await的用法，可以直接跳过本节。&lt;br&gt;&lt;strong&gt;回调地狱(Callback Hell)&lt;/strong&gt;
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 异步函数之Future</title>
    <link href="https://blog.devzou.com/2019/08/10/flutter/2019-12-11-Flutter%E4%B8%AD%E5%BC%82%E6%AD%A5%E4%B9%8BFuture/"/>
    <id>https://blog.devzou.com/2019/08/10/flutter/2019-12-11-Flutter中异步之Future/</id>
    <published>2019-08-10T01:10:09.000Z</published>
    <updated>2019-12-11T15:31:23.383Z</updated>
    
    <content type="html"><![CDATA[<p>Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。</p><p>async和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。</p><p>由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> initFuture() &#123;</div><div class="line">    Future future = <span class="keyword">new</span> Future(()=&gt;<span class="keyword">null</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="Future-then"><a href="#Future-then" class="headerlink" title="Future.then"></a>Future.then</h2><p>为了方便示例，在本例中我们使用Future.delayed 创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串”hello world!”，然后我们在then中接收异步结果并打印结果，代码如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),()&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">"hello world!"</span>;</div><div class="line">&#125;).then((data)&#123;</div><div class="line">   <span class="built_in">print</span>(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="Future-catchError"><a href="#Future-catchError" class="headerlink" title="Future.catchError"></a>Future.catchError</h2><p>如果异步任务发生错误，我们可以在catchError中捕获错误，我们将上面示例改为：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),()&#123;</div><div class="line">   <span class="comment">//return "hello world!";</span></div><div class="line">   <span class="keyword">throw</span> AssertionError(<span class="string">"Error"</span>);  </div><div class="line">&#125;).then((data)&#123;</div><div class="line">   <span class="comment">//执行成功会走到这里  </span></div><div class="line">   <span class="built_in">print</span>(<span class="string">"success"</span>);</div><div class="line">&#125;).catchError((e)&#123;</div><div class="line">   <span class="comment">//执行失败会走到这里  </span></div><div class="line">   <span class="built_in">print</span>(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>在本示例中，我们在异步任务中抛出了一个异常，then的回调函数将不会被执行，取而代之的是 catchError回调函数将被调用；但是，并不是只有 catchError回调才能捕获错误，then方法还有一个可选参数onError，我们也可以它来捕获异常：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () &#123;</div><div class="line">    <span class="comment">//return "hello world!";</span></div><div class="line">    <span class="keyword">throw</span> AssertionError(<span class="string">"Error"</span>);</div><div class="line">&#125;).then((data) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"success"</span>);</div><div class="line">&#125;, onError: (e) &#123;</div><div class="line">    <span class="built_in">print</span>(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="Future-whenComplete"><a href="#Future-whenComplete" class="headerlink" title="Future.whenComplete"></a>Future.whenComplete</h2><p>有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在then或catch中关闭一下对话框，第二种就是使用Future的whenComplete回调，我们将上面示例改一下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),()&#123;</div><div class="line">   <span class="comment">//return "hi world!";</span></div><div class="line">   <span class="keyword">throw</span> AssertionError(<span class="string">"Error"</span>);</div><div class="line">&#125;).then((data)&#123;</div><div class="line">   <span class="comment">//执行成功会走到这里 </span></div><div class="line">   <span class="built_in">print</span>(data);</div><div class="line">&#125;).catchError((e)&#123;</div><div class="line">   <span class="comment">//执行失败会走到这里   </span></div><div class="line">   <span class="built_in">print</span>(e);</div><div class="line">&#125;).whenComplete(()&#123;</div><div class="line">   <span class="comment">//无论成功或失败都会走到这里</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="Future-wait"><a href="#Future-wait" class="headerlink" title="Future.wait"></a>Future.wait</h2><p>有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是Future.wait，它接受一个Future数组参数，只有数组中所有Future都执行成功后，才会触发then的成功回调，只要有一个Future执行失败，就会触发错误回调。下面，我们通过模拟Future.delayed 来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Future.wait([</div><div class="line">  <span class="comment">// 2秒后返回结果  </span></div><div class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</div><div class="line">  &#125;),</div><div class="line">  <span class="comment">// 4秒后返回结果  </span></div><div class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">4</span>), () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">" world"</span>;</div><div class="line">  &#125;)</div><div class="line">]).then((results)&#123;</div><div class="line">  <span class="built_in">print</span>(results[<span class="number">0</span>]+results[<span class="number">1</span>]);</div><div class="line">&#125;).catchError((e)&#123;</div><div class="line">  <span class="built_in">print</span>(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>执行上面代码，4秒后你会在控制台中看到“hello world”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。&lt;/p&gt;
&lt;p&gt;async和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。&lt;/p
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Dart语言简介</title>
    <link href="https://blog.devzou.com/2019/08/07/flutter/2019-12-11-Dart%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/"/>
    <id>https://blog.devzou.com/2019/08/07/flutter/2019-12-11-Dart语言简介/</id>
    <published>2019-08-07T00:10:09.000Z</published>
    <updated>2019-12-11T14:56:04.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dart在静态语法方面和Java非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和JavaScript很像，如函数式特性、异步支持等。除了融合Java和JavaScript语言之所长之外，Dart也具有一些其它具有表现力的语法，如可选命名参数、..（级联运算符）和?.（条件成员访问运算符）以及??（判空赋值运算符）。其实，对编程语言了解比较多的读者会发现，在Dart中其实看到的不仅有Java和JavaScript的影子，它还具有其它编程语言中的身影，如命名参数在Objective-C和Swift中早就很普遍，而??操作符在PHP 7.0语法中就已经存在了，因此我们可以看到Google对Dart语言给予厚望，是想把Dart打造成一门集百家之所长的编程语言。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><strong>1.var</strong><br>类似于JavaScript中的var，它可以接收任何类型的变量，但最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型，如：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t;</div><div class="line">t = <span class="string">"hello world"</span>;</div><div class="line"><span class="comment">// 下面代码在dart中会报错，因为变量t的类型已经确定为String，</span></div><div class="line"><span class="comment">// 类型一旦确定后则不能再更改其类型。</span></div><div class="line">t = <span class="number">20</span>;</div></pre></td></tr></table></figure></p><p>上面的代码在JavaScript是没有问题的，前端开发者需要注意一下，之所以有此差异是因为Dart本身是一个强类型语言，任何变量都是有确定类型的，在Dart中，当用var声明一个变量后，Dart在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定，而JavaScript是纯粹的弱类型脚本语言，var只是变量的声明方式而已。<br><strong>2.dynamic和Object</strong><br>Object 是Dart所有对象的根基类，也就是说所有类型都是Object的子类(包括Function和Null)，所以任何类型的数据都可以赋值给Object声明的对象. dynamic与var一样都是关键词,声明的变量可以赋值任意对象。 而dynamic与Object相同之处在于,他们声明的变量可以在后期改变赋值类型。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dynamic</span> t;</div><div class="line"><span class="built_in">Object</span> x;</div><div class="line">t = <span class="string">"hellow world"</span>;</div><div class="line">x = <span class="string">'Hello Object'</span>;</div><div class="line"><span class="comment">//下面代码没有问题</span></div><div class="line">t = <span class="number">400</span>;</div><div class="line">x = <span class="number">2000</span>;</div></pre></td></tr></table></figure></p><p>dynamic与Object不同的是,dynamic声明的对象编译器会提供所有可能的组合, 而Object声明的对象只能使用Object的属性与方法, 否则编译器会报错。如:<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dynamic</span> a;</div><div class="line"><span class="built_in">Object</span> b;</div><div class="line">main() &#123;</div><div class="line">    a = <span class="string">""</span>;</div><div class="line">    b = <span class="string">""</span>;</div><div class="line">    printLengths();</div><div class="line">&#125;   </div><div class="line"></div><div class="line">printLengths() &#123;</div><div class="line">    <span class="comment">// no warning</span></div><div class="line">    <span class="built_in">print</span>(a.length);</div><div class="line">    <span class="comment">// warning:</span></div><div class="line">    <span class="comment">// The getter 'length' is not defined for the class 'Object'</span></div><div class="line">    <span class="built_in">print</span>(b.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>变量a不会报错, 变量b编译器会报错<br>dynamic的这个特性与Objective-C中的id作用很像. dynamic的这个特点使得我们在使用它时需要格外注意,这很容易引入一个运行时错误.<br><strong>3.final和const</strong><br>如果您从未打算更改一个变量，那么使用 final 或 const，不是var，也不是一个类型。 一个 final 变量只能被设置一次，两者区别在于：const 变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，变量类型可以省略，如：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//可以省略String这个类型声明</span></div><div class="line"><span class="keyword">final</span> str = <span class="string">"hello world"</span>;</div><div class="line"><span class="comment">//final String str = "hello world"; </span></div><div class="line"><span class="keyword">const</span> str1 = <span class="string">"hello world"</span>;</div><div class="line"><span class="comment">//const String str1 = "hello world";</span></div></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。<br><strong>1.函数声明</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</div><div class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Dart函数声明如果没有显式声明返回值类型时会默认当做dynamic处理，注意，函数返回值没有类型推断：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">bool</span> CALLBACK();</div><div class="line"></div><div class="line"><span class="comment">//不指定返回类型，此时默认为dynamic，不是bool</span></div><div class="line">isNoble(<span class="built_in">int</span> atomicNumber) &#123;</div><div class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> test(CALLBACK cb)&#123;</div><div class="line">   <span class="built_in">print</span>(cb()); </div><div class="line">&#125;</div><div class="line"><span class="comment">//报错，isNoble不是bool类型</span></div><div class="line">test(isNoble);</div></pre></td></tr></table></figure></p><p><strong>2.对于只包含一个表达式的函数，可以使用简写语法</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bool</span> isNoble (<span class="built_in">int</span> atomicNumber)=&gt; _nobleGases [ atomicNumber ] ！= <span class="keyword">null</span> ;</div></pre></td></tr></table></figure></p><p><strong>3.函数作为变量</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> say = (str)&#123;</div><div class="line">  <span class="built_in">print</span>(str);</div><div class="line">&#125;;</div><div class="line">say(<span class="string">"hello world"</span>);</div></pre></td></tr></table></figure></p><p><strong>4.函数作为参数传递</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> execute(<span class="keyword">var</span> callback) &#123;</div><div class="line">    callback();</div><div class="line">&#125;</div><div class="line">execute(() =&gt; <span class="built_in">print</span>(<span class="string">"xxx"</span>))</div></pre></td></tr></table></figure></p><p><strong>5.可选的位置参数</strong><br>包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="string">'$from says $msg'</span>;</div><div class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</div><div class="line">    result = <span class="string">'$result with a $device'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面是一个不带可选参数调用这个函数的例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say(<span class="string">'one'</span>, <span class="string">'two'</span>); <span class="comment">//结果是： one says two</span></div></pre></td></tr></table></figure></p><p>下面是用第三个参数调用这个函数的例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say(<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>);<span class="comment">//结果是：one says two with a three</span></div></pre></td></tr></table></figure></p><p><strong>6.可选的命名参数</strong><br>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置[bold]和[hidden]标志</span></div><div class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</div><div class="line">    <span class="comment">// ... </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用函数时，可以使用指定命名参数。例如：paramName: value<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</div></pre></td></tr></table></figure></p><p>可选命名参数在Flutter中使用非常多。</p><p><strong>注意，不能同时使用可选的位置参数和可选的命名参数</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Dart在静态语法方面和Java非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和JavaScript很像，如函数式特性、异步支持
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.devzou.com/2019/08/01/tool/2019-08-01-charles%E7%A0%B4%E8%A7%A3/"/>
    <id>https://blog.devzou.com/2019/08/01/tool/2019-08-01-charles破解/</id>
    <published>2019-08-01T06:41:16.462Z</published>
    <updated>2019-08-01T07:19:06.491Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: charles系列破解激活方法<br>date: 2019-05-16 8:10:09<br>category: 工具<br>tags: 工具<br>description: 软件破解</p><hr><h2 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h2><p> // Charles Proxy License</p><p>// 适用于Charles任意版本的注册码，谁还会想要使用破解版呢。</p><p>// Charles 4.2.8目前是最新版，可用。<br>注册名称：https：//zhile.io</p><p>许可证密钥：48891cf209c6d32bf4</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: charles系列破解激活方法&lt;br&gt;date: 2019-05-16 8:10:09&lt;br&gt;category: 工具&lt;br&gt;tags: 工具&lt;br&gt;description: 软件破解&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;破解方法&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>navicat for mac 登录数据库报错</title>
    <link href="https://blog.devzou.com/2019/07/31/mysql/2019-08-02-navicat%20for%20mac%20%E7%99%BB%E5%BD%95%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99/"/>
    <id>https://blog.devzou.com/2019/07/31/mysql/2019-08-02-navicat for mac 登录数据库报错/</id>
    <published>2019-07-31T01:10:09.000Z</published>
    <updated>2019-10-17T22:15:28.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报错描述"><a href="#报错描述" class="headerlink" title="报错描述"></a>报错描述</h2><p>2059 - Authentication plugin ‘caching_sha2_password’ cannot be loaded: dlopen(../Frameworks/caching_sha2_password.so, 2): image not found</p><h2 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h2><p>这是 MySQL 的问题，不是客户端问题，</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘yourpassword’;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;报错描述&quot;&gt;&lt;a href=&quot;#报错描述&quot; class=&quot;headerlink&quot; title=&quot;报错描述&quot;&gt;&lt;/a&gt;报错描述&lt;/h2&gt;&lt;p&gt;2059 - Authentication plugin ‘caching_sha2_password’ cannot be
      
    
    </summary>
    
      <category term="mysql" scheme="https://blog.devzou.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.devzou.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>xcodeproj使用</title>
    <link href="https://blog.devzou.com/2019/07/31/ios/2019-07-31-xcodeproj%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.devzou.com/2019/07/31/ios/2019-07-31-xcodeproj使用/</id>
    <published>2019-07-31T01:10:09.000Z</published>
    <updated>2019-07-31T02:43:51.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Xcodeproj的作用是使用Ruby来创建和修改Xcode项目，包括对Xcode工作区（.xcworkspace）和配置文件（.xcconfig）等的修改。xcodeproj这个库功能很强大，XCode工程的大多数配置都可以通过通过xcodeproj完成；在这里主要给大家介绍下一些常用配置的修改方法。</p><h2 id="安装xcodeproj"><a href="#安装xcodeproj" class="headerlink" title="安装xcodeproj"></a>安装xcodeproj</h2><p><code>gem install xcodeproj</code></p><h2 id="通过xcodeproj在工程的xxx-group下引入xx-h和xx-m文件"><a href="#通过xcodeproj在工程的xxx-group下引入xx-h和xx-m文件" class="headerlink" title="通过xcodeproj在工程的xxx group下引入xx.h和xx.m文件"></a>通过xcodeproj在工程的xxx group下引入xx.h和xx.m文件</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></div><div class="line"></div><div class="line"><span class="comment">#打开项目工程xxx.xcodeproj</span></div><div class="line">project_path =  <span class="string">'xxxPath/xxx.xcodeproj'</span></div><div class="line">project = Xcodeproj::Project.open(project_path)</div><div class="line"></div><div class="line"><span class="comment">#找到要插入的group (参数中true表示如果找不到group，就创建一个group)</span></div><div class="line">group = project.main_group.find_subpath(File.join(<span class="string">'GroupName'</span>),<span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="comment">#set一下sorce_tree</span></div><div class="line">group.set_source_tree(<span class="string">'SOURCE_ROOT'</span>)</div><div class="line"></div><div class="line"><span class="comment">#向group中增加文件引用（.h文件只需引用一下，.m引用后还需add一下）</span></div><div class="line">file_ref = group.new_reference(<span class="string">'xxxPath/xx.h'</span>)</div><div class="line"></div><div class="line">file_ref = group.new_reference(<span class="string">'xxxPath/xx.m'</span>)</div><div class="line">ret = target.add_file_references(file_ref)</div><div class="line"></div><div class="line">project.save</div></pre></td></tr></table></figure><h2 id="通过xcodeproj在工程中引入framwork、-a文件和bundle文件"><a href="#通过xcodeproj在工程中引入framwork、-a文件和bundle文件" class="headerlink" title="通过xcodeproj在工程中引入framwork、.a文件和bundle文件"></a>通过xcodeproj在工程中引入framwork、.a文件和bundle文件</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></div><div class="line"></div><div class="line"><span class="comment">#打开项目工程A.xcodeproj</span></div><div class="line">project_path =  <span class="string">'xxxPath/xx.xcodeproj'</span></div><div class="line">project = Xcodeproj::Project.open(project_path)</div><div class="line"></div><div class="line"><span class="comment">#遍历target，找到需要操作的target</span></div><div class="line"></div><div class="line">targetIndex = <span class="number">0</span></div><div class="line"></div><div class="line">project.targets.each_with_index <span class="keyword">do</span> <span class="params">|target, index|</span></div><div class="line">  <span class="keyword">if</span> target.name  == <span class="string">"xxxTargetName"</span></div><div class="line">    targetIndex = index</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">target = project.targets[targetIndex]</div><div class="line"></div><div class="line"><span class="comment">#添加xx.framework的引用</span></div><div class="line">file_ref = project.frameworks_group.new_file(<span class="string">'xxPath/xx.framework'</span>)</div><div class="line">target.frameworks_build_phases.add_file_reference(file_ref)</div><div class="line"></div><div class="line"><span class="comment">#添加xx.a的引用</span></div><div class="line">file_ref = project.frameworks_group.new_file(<span class="string">'xxPath/xx.a'</span>)</div><div class="line">target.frameworks_build_phases.add_file_reference(file_ref)</div><div class="line"></div><div class="line"><span class="comment">#添加xx.bundle的引用</span></div><div class="line">file_ref = project.frameworks_group.new_file(<span class="string">'xxPath/xx.bundle'</span>)</div><div class="line">target.resources_build_phase.add_file_reference(file_ref)</div><div class="line"></div><div class="line">project.save</div></pre></td></tr></table></figure><h2 id="通过xcodeproj在把xx-framework-xxx-h-xxx-bundle-加入到copy-files-phase中"><a href="#通过xcodeproj在把xx-framework-xxx-h-xxx-bundle-加入到copy-files-phase中" class="headerlink" title="通过xcodeproj在把xx.framework xxx.h  xxx.bundle 加入到copy files phase中"></a>通过xcodeproj在把xx.framework xxx.h  xxx.bundle 加入到copy files phase中</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></div><div class="line"><span class="comment">#打开项目工程A.xcodeproj </span></div><div class="line">project_path = <span class="string">'xxxPath/xx.xcodeproj'</span> </div><div class="line">project = Xcodeproj::Project.open(project_path)</div><div class="line"><span class="comment">#遍历target，找到需要操作的target </span></div><div class="line">targetIndex = <span class="number">0</span> </div><div class="line">project.targets.each_with_index <span class="keyword">do</span> <span class="params">|target, index|</span> </div><div class="line">  <span class="keyword">if</span> target.name == <span class="string">"xxxTargetName"</span> </div><div class="line">    targetIndex = index </div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">target = project.targets[targetIndex] </div><div class="line"></div><div class="line">file_ref = project.frameworks_group.new_file(<span class="string">'xxPath/xx.framework'</span>)</div><div class="line"></div><div class="line"><span class="comment">#把xx.framework添加到copy files中</span></div><div class="line"><span class="comment">#"leakFramework"即copy files build phase的名字，可自己随便取，也可不填，默认为空</span></div><div class="line">target.new_copy_files_build_phase(<span class="string">"leakFramework"</span>)</div><div class="line"></div><div class="line"><span class="comment">#项目中可能有多个copy files build phases，找到刚刚创建的那个，然后把xx.framework引入</span></div><div class="line">target.copy_files_build_phases.each <span class="keyword">do</span> <span class="params">|item|</span> </div><div class="line">  <span class="keyword">if</span> item.name == <span class="string">"leakFramework"</span></div><div class="line">     <span class="comment">#引入xx.framework</span></div><div class="line">     item.add_file_reference(file_ref)</div><div class="line">     <span class="comment">#设置copy file buldphase中的Destination选项，使用枚举值表示的。"10"表示Frameworks </span></div><div class="line">     <span class="comment">#这个值我是通过对比设置前后的两个文件找出来的</span></div><div class="line">     item.dst_subfolder_spec = <span class="string">"10"</span></div><div class="line">     <span class="comment">#勾上code sign on copy选项（默认是没勾上的）</span></div><div class="line">     item.files[<span class="number">0</span>].settings = Hash.new  </div><div class="line">     item.files[<span class="number">0</span>].settings[<span class="string">"ATTRIBUTES"</span>] = [<span class="string">"CodeSignOnCopy"</span>] </div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">project.save</div></pre></td></tr></table></figure><h2 id="通过xcodeproj设置证书"><a href="#通过xcodeproj设置证书" class="headerlink" title="通过xcodeproj设置证书"></a>通过xcodeproj设置证书</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></div><div class="line"></div><div class="line"><span class="comment">#打开项目工程A.xcodeproj</span></div><div class="line">project_path = <span class="string">'xxxPath/A.xcodeproj'</span></div><div class="line">project = Xcodeproj::Project.open(project_path)</div><div class="line"></div><div class="line"><span class="comment">#修改某个target在debug模式下的证书配置</span></div><div class="line"><span class="comment">#此处遍历找到debug</span></div><div class="line">project.targets[<span class="number">0</span>].build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></div><div class="line">  <span class="keyword">if</span> config.name == <span class="string">'Debug'</span></div><div class="line">    config.build_settings[<span class="string">"PROVISIONING_PROFILE_SPECIFIER"</span>] = <span class="string">"xxProfileName"</span></div><div class="line">    config.build_settings[<span class="string">"DEVELOPMENT_TEAM"</span>] = <span class="string">"xxTeamName"</span></div><div class="line">    config.build_settings[<span class="string">"CODE_SIGN_IDENTITY"</span>] = <span class="string">"xxIdentityName"</span></div><div class="line">    config.build_settings[<span class="string">"CODE_SIGN_IDENTITY[sdk=iphoneos*]"</span>] = <span class="string">"iPhone Developer"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">project.save</div></pre></td></tr></table></figure><p>此处可以通过此方法修改target下某个模式（debug, release等）的大多数配置，可通过config.build_settings查看所有的键值对，然后根据需求修改键值，如OTHER_FLAGS,PRODUCT_BUNDLE_IDENTIFIER,HEADER_SEARCH_PATHS,LIBRARY_SEARCH_PATHS等。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://rubygems.org/gems/xcodeproj" target="_blank" rel="external">https://rubygems.org/gems/xcodeproj</a><br><a href="https://github.com/CocoaPods/Xcodeproj" target="_blank" rel="external">https://github.com/CocoaPods/Xcodeproj</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Xcodeproj的作用是使用Ruby来创建和修改Xcode项目，包括对Xcode工作区（.xcworkspace）和配置文件（.xccon
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>flutter入门之在macOS上搭建开发环境</title>
    <link href="https://blog.devzou.com/2019/07/30/flutter/2019-09-02-flutter%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.devzou.com/2019/07/30/flutter/2019-09-02-flutter入门之环境配置/</id>
    <published>2019-07-30T01:10:09.000Z</published>
    <updated>2019-09-02T23:13:39.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>要安装并运行Flutter，您的开发环境必须满足以下最低要求:</p><ul><li>操作系统: macOS (64-bit)</li><li>磁盘空间: 700 MB (不包括Xcode或Android Studio的磁盘空间）.</li><li>工具: Flutter 依赖下面这些命令行工具.<br>bash, mkdir, rm, git, curl, unzip, which<h2 id="获取flutter-SDK"><a href="#获取flutter-SDK" class="headerlink" title="获取flutter SDK"></a>获取flutter SDK</h2>1.去flutter官网下载其最新可用的安装包，<a href="https://flutter.io/sdk-archive/#macos" target="_blank" rel="external">转到下载页 </a>。<br>注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，<a href="https://github.com/flutter/flutter/releases" target="_blank" rel="external">转到下载页</a> 。</li></ul><p>2.解压安装包到你想安装的目录，比如我是放在用户目录下面<br>  <img src="/img/flutter/01/flutter01_1.png" alt=""><br>3.添加flutter相关工具到path中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=`<span class="built_in">pwd</span>`/flutter/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure></p><p> <img src="/img/flutter/01/flutter01_3.png" alt="">  </p><h2 id="运行-flutter-doctor"><a href="#运行-flutter-doctor" class="headerlink" title="运行 flutter doctor"></a>运行 flutter doctor</h2><p>运行以下命令查看是否需要安装其它依赖项来完成安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flutter doctor</div></pre></td></tr></table></figure></p><p><img src="/img/flutter/01/flutter01_2.png" alt=""><br>该命令检查您的环境并在终端窗口中显示报告。Dart SDK已经在捆绑在Flutter里了，没有必要单独安装Dart。 仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务（以粗体显示）</p><p>第一次运行一个flutter命令（如flutter doctor）时，它会下载它自己的依赖项并自行编译。以后再运行就会快得多。</p><p>以下各部分介绍如何执行这些任务并完成设置过程。你会看到在flutter doctor输出中， 如果你选择使用IDE，我们提供了，IntelliJ IDEA，Android Studio和VS Code的插件， 请参阅<a href="https://flutterchina.club/get-started/editor/" target="_blank" rel="external">编辑器设置</a> 以了解安装Flutter和Dart插件的步骤。</p><p>一旦你安装了任何缺失的依赖，再次运行flutter doctor命令来验证你是否已经正确地设置了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统要求&quot;&gt;&lt;a href=&quot;#系统要求&quot; class=&quot;headerlink&quot; title=&quot;系统要求&quot;&gt;&lt;/a&gt;系统要求&lt;/h2&gt;&lt;p&gt;要安装并运行Flutter，您的开发环境必须满足以下最低要求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统: macOS (64-b
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Flutter中App的生命周期</title>
    <link href="https://blog.devzou.com/2019/07/30/flutter/2019-12-11-Flutter%E4%B8%ADApp%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://blog.devzou.com/2019/07/30/flutter/2019-12-11-Flutter中App的生命周期/</id>
    <published>2019-07-30T01:10:09.000Z</published>
    <updated>2019-12-27T08:23:40.576Z</updated>
    
    <content type="html"><![CDATA[<p>如果想要知道 Flutter App 的生命周期，例如 Flutter 是在前台还是在后台，就需要使用到 WidgetsBindingObserver 了，使用方法如下：</p><h2 id="1-State-的类-mix-WidgetsBindingObserver："><a href="#1-State-的类-mix-WidgetsBindingObserver：" class="headerlink" title="1.State 的类 mix WidgetsBindingObserver："></a>1.State 的类 mix WidgetsBindingObserver：</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-在-State-的-initState-里添加监听："><a href="#2-在-State-的-initState-里添加监听：" class="headerlink" title="2.在 State 的 initState 里添加监听："></a>2.在 State 的 initState 里添加监听：</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> initState()&#123;</div><div class="line">    <span class="keyword">super</span>.initState();</div><div class="line">    WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h2 id="3-在-State-的-dispose-里移除监听："><a href="#3-在-State-的-dispose-里移除监听：" class="headerlink" title="3.在 State 的 dispose 里移除监听："></a>3.在 State 的 dispose 里移除监听：</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> dispose() &#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement dispose</span></div><div class="line">    <span class="keyword">super</span>.dispose();</div><div class="line">    WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h2 id="4-在-State-里-override-didChangeAppLifecycleState"><a href="#4-在-State-里-override-didChangeAppLifecycleState" class="headerlink" title="4.在 State 里 override didChangeAppLifecycleState"></a>4.在 State 里 override didChangeAppLifecycleState</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line"><span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</div><div class="line">  <span class="keyword">super</span>.didChangeAppLifecycleState(state);</div><div class="line">  <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</div><div class="line">    <span class="comment">// went to Background</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (state == AppLifecycleState.resumed) &#123;</div><div class="line">    <span class="comment">// came back to Foreground</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>AppLifecycleState 就是 App 的生命周期，有：</p><ul><li>resumed</li><li>inactive</li><li>paused</li><li>suspending</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果想要知道 Flutter App 的生命周期，例如 Flutter 是在前台还是在后台，就需要使用到 WidgetsBindingObserver 了，使用方法如下：&lt;/p&gt;
&lt;h2 id=&quot;1-State-的类-mix-WidgetsBindingObserver：&quot;
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>idea配置flutter开发环境</title>
    <link href="https://blog.devzou.com/2019/07/30/flutter/2019-09-03-idea%E9%85%8D%E7%BD%AEflutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.devzou.com/2019/07/30/flutter/2019-09-03-idea配置flutter开发环境/</id>
    <published>2019-07-30T01:10:09.000Z</published>
    <updated>2019-09-03T02:36:46.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装flutter插件"><a href="#安装flutter插件" class="headerlink" title="安装flutter插件"></a>安装flutter插件</h2><p> 在Preferences -&gt; Plugin 中搜索flutter并install,如下图<br> <img src="/img/flutter/02/flutter02_1.png" alt=""><br> <img src="/img/flutter/02/flutter02_2.png" alt=""></p><h2 id="install-SDK"><a href="#install-SDK" class="headerlink" title="install SDK"></a>install SDK</h2><p>选择安装路径<br> <img src="/img/flutter/02/flutter02_3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装flutter插件&quot;&gt;&lt;a href=&quot;#安装flutter插件&quot; class=&quot;headerlink&quot; title=&quot;安装flutter插件&quot;&gt;&lt;/a&gt;安装flutter插件&lt;/h2&gt;&lt;p&gt; 在Preferences -&amp;gt; Plugin 中搜索flut
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Widget 的生命周期</title>
    <link href="https://blog.devzou.com/2019/07/30/flutter/2019-12-11-Widget%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://blog.devzou.com/2019/07/30/flutter/2019-12-11-Widget的生命周期/</id>
    <published>2019-07-30T01:10:09.000Z</published>
    <updated>2019-12-11T12:23:56.732Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 里的 Widget 分为 StatelessWidget 和 StatefulWidget 两种，这两种 Widget 的生命周期是不一样的，我们接下来具体来看。</p><h3 id="StatelessWidget-的生命周期"><a href="#StatelessWidget-的生命周期" class="headerlink" title="StatelessWidget 的生命周期"></a>StatelessWidget 的生命周期</h3><p>StatelessWidget 的生命周期只有一个，就是：build<br>build 是用来创建 Widget 的，但因为 build 在每次界面刷新的时候都会调用，所以不要在 build 里写业务逻辑，可以把业务逻辑写到你的 StatelessWidget 的构造函数里。<br>StatelessWidget 的 build 函数代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">'StatelessWidget build'</span>);</div><div class="line">    <span class="keyword">return</span> Text(<span class="string">'MyWidget'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="StatefulWidget-的生命周期"><a href="#StatefulWidget-的生命周期" class="headerlink" title="StatefulWidget 的生命周期"></a>StatefulWidget 的生命周期</h3><p>StatefulWidget 的生命周期比较复杂，依次为：<br>**1. createState</p><ol><li>initState</li><li>didChangeDependencies</li><li>build</li><li>addPostFrameCallback</li><li>didUpdateWidget</li><li>deactivate</li><li>dispose<strong><br>接下来具体介绍一下各个生命周期。</strong>1.createState**<br>createState 是 StatefulWidget 里创建 State 的方法，当要创建新的 StatefulWidget 的时候，会立即执行 createState，而且只执行一次，createState 必须要实现：<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</div><div class="line">   <span class="meta">@override</span></div><div class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p><strong>2.initState</strong><br>前面的 createState 是在创建 StatefulWidget 的时候会调用，initState 是 StatefulWidget 创建完后调用的第一个方法，而且只执行一次，类似于 Android 的 onCreate、iOS 的 viewDidLoad()，所以在这里 View 并没有渲染，但是这时 StatefulWidget 已经被加载到渲染树里了，这时 StatefulWidget 的 mount 的值会变为 true，直到 dispose 调用的时候才会变为 false。可以在 initState 里做一些初始化的操作。<br>在 override initState 的时候必须要调用 super.initState()：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line"><span class="keyword">void</span> initState() &#123;</div><div class="line">  <span class="keyword">super</span>.initState();</div><div class="line">  <span class="comment">// Do other things</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>3.didChangeDependencies</strong><br>当 StatefulWidget 第一次创建的时候，didChangeDependencies 方法会在 initState 方法之后立即调用，之后当 StatefulWidget 刷新的时候，就不会调用了，除非你的 StatefulWidget 依赖的 InheritedWidget 发生变化之后，didChangeDependencies 才会调用，所以 didChangeDependencies 有可能会被调用多次。<br><strong>4.build</strong><br>在 StatefulWidget 第一次创建的时候，build 方法会在 didChangeDependencies 方法之后立即调用，另外一种会调用 build 方法的场景是，每当 UI 需要重新渲染的时候，build 都会被调用，所以 build 会被多次调用，然后 返回要渲染的 Widget。千万不要在 build 里做除了创建 Widget 之外的操作，因为这个会影响 UI 的渲染效率。<br><strong>5.addPostFrameCallback</strong><br>addPostFrameCallback 是 StatefulWidge 渲染结束的回调，只会被调用一次，之后 StatefulWidget 需要刷新 UI 也不会被调用，addPostFrameCallback 的使用方法是在 initState 里添加回调：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:flutter/scheduler.dart'</span>;</div><div class="line"><span class="meta">@override</span></div><div class="line"><span class="keyword">void</span> initState() &#123;</div><div class="line">  <span class="keyword">super</span>.initState();</div><div class="line">  SchedulerBinding.instance.addPostFrameCallback((_) =&gt; &#123;&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>6.didUpdateWidget</strong><br>didUpdateWidget 这个生命周期我们一般不会用到，只有在使用 key 对 Widget 进行复用的时候才会调用。<br><strong>7.deactivate</strong><br>当要将 State 对象从渲染树中移除的时候，就会调用 deactivate 生命周期，这标志着 StatefulWidget 将要销毁，但是有时候 State 不会被销毁，而是重新插入到渲染树种。<br><strong>8.dispose</strong><br>当 View 不需要再显示，从渲染树中移除的时候，State 就会永久的从渲染树中移除，就会调用 dispose 生命周期，这时候就可以在 dispose 里做一些取消监听、动画的操作，和 initState 是相反的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flutter 里的 Widget 分为 StatelessWidget 和 StatefulWidget 两种，这两种 Widget 的生命周期是不一样的，我们接下来具体来看。&lt;/p&gt;
&lt;h3 id=&quot;StatelessWidget-的生命周期&quot;&gt;&lt;a href=&quot;#St
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ios 证书无法生成p12 文件解决，或者无法生成秘钥问题</title>
    <link href="https://blog.devzou.com/2019/05/12/ios/2019-05-11-ios%20%E8%AF%81%E4%B9%A6%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90p12%20%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%88%96%E8%80%85%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E7%A7%98%E9%92%A5/"/>
    <id>https://blog.devzou.com/2019/05/12/ios/2019-05-11-ios 证书无法生成p12 文件解决，或者无法生成秘钥/</id>
    <published>2019-05-12T01:10:09.000Z</published>
    <updated>2019-05-21T00:38:02.377Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog.devzou.com/img/ios/ioscer_1_01.png" alt=""></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>发布证书即将过期，按照相应的步骤去生成证书后，在本机电脑安装后没有秘钥(就是看不到钥匙串证书左边的那个三角符号)。如下图证书没有秘钥是无法导出p12文件的。<br><img src="/img/ios/ioscer_1_02.png" alt=""></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>1.证书类型选择错误，左侧有两个分类，选择 登录–证书，找到需要导出的文件，右键点击可导出p12文件，如果在 登录–证书 中找不到需要的证书，而在 系统–证书 中能找到，拖动证书到登录即可解决。<br>2.生成证书时选择的CSR文件为非本机电脑生成的。重新在本机上生成CSR文件，然后再重新生成证书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://blog.devzou.com/img/ios/ioscer_1_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Mach-O 可执行文件</title>
    <link href="https://blog.devzou.com/2019/04/20/ios/2019-05-06-Mach-O%20%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://blog.devzou.com/2019/04/20/ios/2019-05-06-Mach-O 可执行文件/</id>
    <published>2019-04-20T00:10:09.000Z</published>
    <updated>2019-05-21T00:37:36.301Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog.devzou.com/img/ios/macho_01.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mach-O 是 Apple 系统上（包括 MacOS 以及 iOS）的可执行文件格式，类似于 windows 上的 PE 文件以及 linux 上的 ELF 文件。上图左边为官方图，右边为用<a href="https://github.com/gdbinit/MachOView" target="_blank" rel="external">MachOView</a>软件打开的 Mach-O 文件图。可以非常清晰的看到，这种文件格式由文件头（Header）、加载命令（Load Commands）以及具体数据（Segment&amp;Section）组成。下面一一介绍。 </p><h2 id="Header-文件头"><a href="#Header-文件头" class="headerlink" title="Header(文件头)"></a>Header(文件头)</h2><p>Header(文件头)的作用是使系统能够快速定位其运行环境以及文件类型等等<br>源码如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The 32-bit mach header appears at the very beginning of the object file for</span></div><div class="line"><span class="comment"> * 32-bit architectures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> mach_header &#123;</div><div class="line">uint32_tmagic;<span class="comment">/* mach magic number identifier */</span></div><div class="line">cpu_type_tcputype;<span class="comment">/* cpu specifier */</span></div><div class="line">cpu_subtype_tcpusubtype;<span class="comment">/* machine specifier */</span></div><div class="line">uint32_tfiletype;<span class="comment">/* type of file */</span></div><div class="line">uint32_tncmds;<span class="comment">/* number of load commands */</span></div><div class="line">uint32_tsizeofcmds;<span class="comment">/* the size of all the load commands */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">/* Constant for the magic field of the mach_header (32-bit architectures) */</span></div><div class="line"><span class="meta">#defineMH_MAGIC0xfeedface/* the mach magic number */</span></div><div class="line"><span class="meta">#define MH_CIGAM0xcefaedfe/* NXSwapInt(MH_MAGIC) */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The 64-bit mach header appears at the very beginning of object files for</span></div><div class="line"><span class="comment"> * 64-bit architectures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> mach_header_64 &#123;</div><div class="line">uint32_tmagic;<span class="comment">/* mach magic number identifier */</span></div><div class="line">cpu_type_tcputype;<span class="comment">/* cpu specifier */</span></div><div class="line">cpu_subtype_tcpusubtype;<span class="comment">/* machine specifier */</span></div><div class="line">uint32_tfiletype;<span class="comment">/* type of file */</span></div><div class="line">uint32_tncmds;<span class="comment">/* number of load commands */</span></div><div class="line">uint32_tsizeofcmds;<span class="comment">/* the size of all the load commands */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">uint32_treserved;<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span></div><div class="line"><span class="meta">#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */</span></div><div class="line"><span class="meta">#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */</span></div></pre></td></tr></table></figure></p><p>分析文件头的 otool 命令为： <code>otool -h 可执行文件</code> ，或者可视化强一点的 <code>otool -hv 可执行文件</code>。</p><h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><p>Load Commands 是跟在 Header 后面的加载命令区，所有 commands 的大小总和即为 Header-&gt;sizeofcmds 字段，共有 Header-&gt;ncmds 条加载命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct load_command &#123;</div><div class="line">    uint32_t cmd;        /* type of load command */</div><div class="line">    uint32_t cmdsize;    /* total size of command in bytes */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>Command 以 LC 开头，不同的加载命令有不同的专有的结构体，cmd 和 cmdsize 是都有的，分别为命令类型（即命令名称），这条命令的长度。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。如果当前 LC_SEGMENT 包含 section，那么 section 的结构体紧跟在 LC_SEGMENT 的结构体之后，所占字节数由 SEGMENT 的 cmdsize 字段给出。</p><table><thead><tr><th style="text-align:center">Cmd</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">LC_SEGMENT/LC_SEGMENT_64</td><td style="text-align:center">将对应的段中的数据加载并映射到进程的内存空间去</td></tr><tr><td style="text-align:center">LC_SYMTAB</td><td style="text-align:center">符号表信息</td></tr><tr><td style="text-align:center">LC_DYSYMTAB</td><td style="text-align:center">动态符号表信息</td></tr><tr><td style="text-align:center">LC_LOAD_DYLINKER</td><td style="text-align:center">启动动态加载连接器/usr/lib/dyld程序</td></tr><tr><td style="text-align:center">LC_UUID</td><td style="text-align:center">唯一的 UUID，标示该二进制文件，128bit</td></tr><tr><td style="text-align:center">LC_VERSION_MIN_IPHONEOS/MACOSX</td><td style="text-align:center">要求的最低系统版本（Xcode中的Deployment Target）</td></tr><tr><td style="text-align:center">LC_MAIN</td><td style="text-align:center">设置程序主线程的入口地址和栈大小</td></tr><tr><td style="text-align:center">LC_ENCRYPTION_INFO</td><td style="text-align:center">加密信息</td></tr><tr><td style="text-align:center">LC_LOAD_DYLIB</td><td style="text-align:center">加载的动态库，包括动态库地址、名称、版本号等</td></tr><tr><td style="text-align:center">LC_FUNCTION_STARTS</td><td style="text-align:center">函数地址起始表</td></tr><tr><td style="text-align:center">LC_CODE_SIGNATURE</td><td style="text-align:center">代码签名信息</td></tr></tbody></table><p>使用命令 <code>otool -l 可执行文件</code> 可以查看加载命令区，使用<code>otool -l 可执行文件|grep cryptid</code> 可以查看是否加密</p><h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><p>Mach-O 文件有多个段（Segment），每个段有不同的功能。然后每个段又分为很多小的 Section。 LC_SEGMENT 意味着这部分文件需要映射到进程的地址空间去。一般有以下段名：<br><strong>__PAGEZERO:</strong>　空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用。<br><strong>__TEXT:</strong>　包含了执行代码以及其他只读数据。该段数据可以 VM_PROT_READ(读)、VM_PROT_EXECUTE(执行)，不能被修改。<br><strong>__DATA:</strong>　程序数据，该段可写 VM_PROT_WRITE/READ/EXECUTE。<br><strong>__LINKEDIT:</strong>　链接器使用的符号以及其他表。</p><p>段的结构体定义为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> segment_command &#123; <span class="comment">/* for 32-bit architectures */</span></div><div class="line">uint32_tcmd;<span class="comment">/* LC_SEGMENT */</span></div><div class="line">uint32_tcmdsize;<span class="comment">/* includes sizeof section structs */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment name */</span></div><div class="line">uint32_tvmaddr;<span class="comment">/* memory address of this segment 段的虚拟内存地址*/</span></div><div class="line">uint32_tvmsize;<span class="comment">/* memory size of this segment  段的虚拟内存大小*/</span></div><div class="line">uint32_tfileoff;<span class="comment">/* file offset of this segment  段在文件中的偏移量*/</span></div><div class="line">uint32_tfilesize;<span class="comment">/* amount to map from the file  段在文件中的大小*/</span></div><div class="line">vm_prot_tmaxprot;<span class="comment">/* maximum VM protection */</span></div><div class="line">vm_prot_tinitprot;<span class="comment">/* initial VM protection */</span></div><div class="line">uint32_tnsects;<span class="comment">/* number of sections in segment */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> segment_command_64 &#123; <span class="comment">/* for 64-bit architectures */</span></div><div class="line">uint32_tcmd;<span class="comment">/* LC_SEGMENT_64 */</span></div><div class="line">uint32_tcmdsize;<span class="comment">/* includes sizeof section_64 structs */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment name */</span></div><div class="line">uint64_tvmaddr;<span class="comment">/* memory address of this segment */</span></div><div class="line">uint64_tvmsize;<span class="comment">/* memory size of this segment */</span></div><div class="line">uint64_tfileoff;<span class="comment">/* file offset of this segment */</span></div><div class="line">uint64_tfilesize;<span class="comment">/* amount to map from the file */</span></div><div class="line">vm_prot_tmaxprot;<span class="comment">/* maximum VM protection */</span></div><div class="line">vm_prot_tinitprot;<span class="comment">/* initial VM protection */</span></div><div class="line">uint32_tnsects;<span class="comment">/* number of sections in segment */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>其中 nsects 字段就是表明该段中有多少个 section。文件映射的起始位置是由 fileoff 给出，映射到地址空间的 vmaddr 处。</p><h2 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h2><p>Section 是具体有用的数据存放的地方。它的结构体跟随在 LC_SEGMENT 结构体之后，LC_SEGMENT 又在 Load Commands 中，但是 segment 的数据内容是跟在 Load Commands 之后的。它的结构体为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></div><div class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></div><div class="line">uint32_taddr;<span class="comment">/* memory address of this section 该节在内存中的起始位置*/</span></div><div class="line">uint32_tsize;<span class="comment">/* size in bytes of this section 该节的大小*/</span></div><div class="line">uint32_toffset;<span class="comment">/* file offset of this section 该节的文件偏移*/</span></div><div class="line">uint32_talign;<span class="comment">/* section alignment (power of 2) 字节大小对齐*/</span></div><div class="line">uint32_treloff;<span class="comment">/* file offset of relocation entries 重定位入口的文件偏移*/</span></div><div class="line">uint32_tnreloc;<span class="comment">/* number of relocation entries 需要重定位的入口数量*/</span></div><div class="line">uint32_tflags;<span class="comment">/* flags (section type and attributes) */</span></div><div class="line">uint32_treserved1;<span class="comment">/* reserved (for offset or index) */</span></div><div class="line">uint32_treserved2;<span class="comment">/* reserved (for count or sizeof) */</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></div><div class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></div><div class="line">uint64_taddr;<span class="comment">/* memory address of this section */</span></div><div class="line">uint64_tsize;<span class="comment">/* size in bytes of this section */</span></div><div class="line">uint32_toffset;<span class="comment">/* file offset of this section */</span></div><div class="line">uint32_talign;<span class="comment">/* section alignment (power of 2) */</span></div><div class="line">uint32_treloff;<span class="comment">/* file offset of relocation entries */</span></div><div class="line">uint32_tnreloc;<span class="comment">/* number of relocation entries */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags (section type and attributes)*/</span></div><div class="line">uint32_treserved1;<span class="comment">/* reserved (for offset or index) */</span></div><div class="line">uint32_treserved2;<span class="comment">/* reserved (for count or sizeof) */</span></div><div class="line">uint32_treserved3;<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>其中 flag 字段分为两个部分，一个是区域类型（section type），一个是区域属性（section attributes）。其中 type 是互斥的，即只能有一个类型，而 attributes 不是互斥的，可以有多个属性。如果段（segment）中的任何一个 section 拥有属性 S_ATTR_DEBUG，那么该段所有的 section 都必须拥有这个属性。具体的flag字段内容以及意义请参考 /usr/include/mach-o/loader.h。</p><p>段名为大写，节名为小写。各节的作用主要有：</p><ul><li>__text:　主程序代码</li><li>__stub_helper:　用于动态链接的存根</li><li>__symbolstub1:　用于动态链接的存根</li><li>__objc_methname:　Objective-C 的方法名</li><li>__objc_classname:　Objective-C 的类名</li><li><p>__cstring:　硬编码的字符串</p></li><li><p>__lazy_symbol:　懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接</p></li><li>_got:　存储引用符号的实际地址，类似于动态符号表</li><li>__nl_symbol_ptr:　非延迟加载节</li><li>__mod_init_func:　初始化的全局函数地址，在 main 之前被调用</li><li>__mod_term_func:　结束函数地址</li><li><p>__cfstring:　Core Foundation 用到的字符串（OC字符串）</p></li><li><p>__objc_clsslist:　Objective-C 的类列表</p></li><li><strong>objc_nlclslist:　Objective-C 的 +load 函数列表，比 </strong>mod_init_func 更早执行</li><li>__objc_const:　Objective-C 的常量</li><li>__data:　初始化的可变的变量</li><li>__bss:　未初始化的静态变量</li></ul><p>查看某段中某节的命令为： <code>otool -s __TEXT __text 可执行文件</code>。</p><h2 id="与-IDA-的对应地址"><a href="#与-IDA-的对应地址" class="headerlink" title="与 IDA 的对应地址"></a>与 IDA 的对应地址</h2><p>如果用 MachOView 来查看的话，界面左上角有一个 RAW、RVA 的选项。RAW 就是指该字节相对于文件开始部分的绝对偏移，文件头部的地址是从0x000开始的。RVA 是相对于某个基地址的偏移，也就是整体的绝对偏移值再加上某个基地址，文件头部的地址是从某个值（基地址）开始的。</p><p>这个所谓的基地址其实是 LC_SEGMENT_64(_PAGEZERO) 中的 VM_Size 字段的值，因为留出这段空白页面就是为了捕获程序的空指针，以及考虑到页面对齐。IDA 中就是使用的 RVA 地址。这个地址在 armv7 中是0x4000，arm64 中是0x10000 0000。</p><p>Section(<strong>TEXT,</strong>text ) 所在的 RVA 地址，对应的就是 IDA 解析的函数开始地址。 IDA 解析的 Mach-O 文件中的函数都位于 Section( <strong>TEXT) 段，然后还会接着解析 Section( </strong>DATA) 段，即 IDA 中的数据区。</p><p>LC_MAIN 加载命令中的 Entry Offset 字段 + 基地址（RVA 选项下的文件头部地址） = IDA 中左侧函数 _main 的地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://blog.devzou.com/img/ios/macho_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能调试之instruments</title>
    <link href="https://blog.devzou.com/2019/03/20/ios/2019-05-06-iOS%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E4%B9%8Binstruments/"/>
    <id>https://blog.devzou.com/2019/03/20/ios/2019-05-06-iOS性能调试之instruments/</id>
    <published>2019-03-20T00:10:09.000Z</published>
    <updated>2019-05-13T02:42:27.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于instruments"><a href="#关于instruments" class="headerlink" title="关于instruments"></a>关于instruments</h2><p>Instruments是功能强大且灵活的性能分析和测试工具，是Xcode工具集的一部分,它旨在帮助您分析您的iOS，watchOS，tvOS和macOS应用程序，流程和设备，以便更好地了解和优化应用程序的行为和性能。从应用程序开发过程开始，将仪器集成到您的工作流程中，可以帮助您在开发周期的早期发现问题，从而节省您的时间。<br>    在Instruments中，您使用专用工具（称为工具）来跟踪应用程序，流程和设备的不同方面。仪器在配置文件时收集数据，并将结果详细呈现给您以供分析。<br>    与其他性能和调试工具不同，Instruments允许您收集广泛不同类型的数据并并排查看。这样可以更轻松地识别可能被忽视的趋势。例如，您的应用可能会因多个开放式网络连接而出现大量内存增长。通过一起使用分配和连接工具，您可以识别未关闭的连接，从而实现快速的内存增长。</p><p>使用 Instruments 你可以做下面这些事：</p><ol><li>检查一个或多个应用或进程的行为。</li><li>检查设备相关的功能，比如：Wi-Fi、蓝牙等。</li><li>在真机或模拟器上进行性能测试。</li><li>创建自定义的 DTrace 来分析系统以及应用的各种行为。</li><li>跟踪源码中的问题。</li><li>对 App 进行性能分析。</li><li>查找 App 中的内存问题，比如：内存泄露(Leaked memory)、废弃内存(Abandoned memory)、僵尸(zombies)等。</li><li>给出程序优化的建议。</li><li>进行系统级别的问题定位。</li><li>通过脚本记录一个用户行为序列，从而可以通过运行脚本对你的 iOS 应用进行可重复多次的自动化测试。</li><li>保存测试配置模板以供复用。<br>虽然 Instruments 是 Xcode 的一个工具集，但是它是以一个独立的 App 的形式存在的，你可以在 Xcode -&gt; Open Developer Tool -&gt; Instruments 中打开它。<h2 id="内存性能"><a href="#内存性能" class="headerlink" title="内存性能"></a>内存性能</h2>Instruments 可以帮我们了解到应用程序使用内存的几个方面：</li></ol><ul><li><strong>全局内存使用情况(Overall Memory Use)</strong>: 从全局的角度监测应用程序的内存使用情况，捕捉非预期的或大幅度的内存增长。</li><li><strong>内存泄露(Leaked memory)</strong>: 未被你的程序引用，同时也不能被使用或释放的内存。</li><li><strong>废弃内存(Abandoned memory)</strong>: 被你的程序引用，但是没什么卵用的内存。</li><li><strong>僵尸对象(Zombies)</strong>: 僵尸对象指的是对应的内存已经被释放并且不再会使用到，但是你的程序却在某处依然有指向它的引用。在 iOS 中有一个 NSZombie 机制，这个是为了内存调试的目的而设计的一种机制。在这个机制下，当你 NSZombieEnabled 为 YES 时，当一个对应的引用计数减为 0 时，这个对象不会被释放，当这个对象再收到任何消息时，它会记录一条 warning，而不是直接崩溃，以方便我们进行程序调试。</li></ul><p>这里我们介绍下查找内存泄露的过程：<br>1.在products-&gt;profile中启动instruments面板<br><img src="/img/ios/performance_1_01.png" alt=""><br>2.选中Leaks模板<br><img src="/img/ios/performance_1_02.png" alt=""></p><ol><li>选择正确的设备和应用程序，点击红色按钮运行应用程序<br><img src="/img/ios/performance_1_03.png" alt=""><br>4.我们可以看到如下界面<br><img src="/img/ios/performance_1_04.png" alt=""></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://help.apple.com/instruments/mac/current/" target="_blank" rel="external"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于instruments&quot;&gt;&lt;a href=&quot;#关于instruments&quot; class=&quot;headerlink&quot; title=&quot;关于instruments&quot;&gt;&lt;/a&gt;关于instruments&lt;/h2&gt;&lt;p&gt;Instruments是功能强大且灵活的性能分析和测
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
</feed>
