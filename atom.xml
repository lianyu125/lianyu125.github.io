<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小玉的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.devzou.com/"/>
  <updated>2019-12-02T14:42:51.367Z</updated>
  <id>https://blog.devzou.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Proxy CONNECT aborted due to timeout</title>
    <link href="https://blog.devzou.com/2019/11/15/git/2019-12-02-git_Proxy_CONNECT_aborted_due_to_timeout/"/>
    <id>https://blog.devzou.com/2019/11/15/git/2019-12-02-git_Proxy_CONNECT_aborted_due_to_timeout/</id>
    <published>2019-11-15T00:10:09.000Z</published>
    <updated>2019-12-02T14:42:51.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天在clone  github上的源码时报错如下<br><img src="/img/git/git_proxy_01.png" alt=""></p><h2 id="fq配置如下"><a href="#fq配置如下" class="headerlink" title="fq配置如下"></a>fq配置如下</h2><p><img src="/img/git/git_proxy_02.png" alt=""></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1086&apos;</div><div class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1086&apos;</div></pre></td></tr></table></figure><p>git config –global –list 显示git config global配置信息。<br>再次git clone xxx 即可。<br>如需要对应还原git proxy，可以使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global --unset http.proxy</div><div class="line">git config --global --unset https.proxy</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;今天在clone  github上的源码时报错如下&lt;br&gt;&lt;img src=&quot;/img/git/git_proxy_01.png&quot; alt=
      
    
    </summary>
    
      <category term="资源" scheme="https://blog.devzou.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Git" scheme="https://blog.devzou.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.devzou.com/2019/10/24/ios/2019-10-24-NSURLProtocol/"/>
    <id>https://blog.devzou.com/2019/10/24/ios/2019-10-24-NSURLProtocol/</id>
    <published>2019-10-24T04:26:10.335Z</published>
    <updated>2019-10-30T07:48:26.340Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: NSURLProtocol<br>category: iOS<br>date: 2016-7-30 9:10:09<br>tags: iOS</p><h2 id="keywords-NSURLProtocol"><a href="#keywords-NSURLProtocol" class="headerlink" title="keywords: NSURLProtocol"></a>keywords: NSURLProtocol</h2><p>NSURLProtocol能够让你去重新定义苹果的URL加载系统 (URL Loading System)的行为，URL Loading System里有许多类用于处理URL请求，比如NSURL，NSURLRequest，NSURLConnection和NSURLSession等，当URL Loading System使用NSURLRequest去获取资源的时候，它会创建一个NSURLProtocol子类的实例，你不应该直接实例化一个NSURLProtocol，NSURLProtocol看起来像是一个协议，但其实这是一个类，而且必须使用该类的子类，并且需要被注册。<br><img src="![](/img/ios/url_loading_system/loading-system.png" alt="">)</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/documentation/foundation/nsurlprotocol?language=occ" target="_blank" rel="external">https://developer.apple.com/documentation/foundation/nsurlprotocol?language=occ</a><br><a href="https://developer.apple.com/library/ios/samplecode/CustomHTTPProtocol/CustomHTTPProtocol.zip" target="_blank" rel="external">官方Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: NSURLProtocol&lt;br&gt;category: iOS&lt;br&gt;date: 2016-7-30 9:10:09&lt;br&gt;tags: iOS&lt;/p&gt;
&lt;h2 id=&quot;keywords-NSURLProtocol&quot;&gt;&lt;a href=&quot;#keywords
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql权限管理</title>
    <link href="https://blog.devzou.com/2019/10/18/mysql/2019-10-18-mysql%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://blog.devzou.com/2019/10/18/mysql/2019-10-18-mysql权限管理/</id>
    <published>2019-10-18T01:10:09.000Z</published>
    <updated>2019-10-17T22:08:22.767Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="mysql" scheme="https://blog.devzou.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.devzou.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据类型</title>
    <link href="https://blog.devzou.com/2019/10/18/mysql/2019-10-19-MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://blog.devzou.com/2019/10/18/mysql/2019-10-19-MySQL 数据类型/</id>
    <published>2019-10-18T01:10:09.000Z</published>
    <updated>2019-10-19T23:24:44.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。<br>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>MySQL支持所有标准SQL数值数据类型。<br>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。<br>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。<br>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。<br>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。<br><img src="/img/mysql/mysql_1/01.png" alt=""></p><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。<br>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。<br>TIMESTAMP类型有专有的自动更新特性，将在后面描述。<br><img src="/img/mysql/mysql_1/02.png" alt=""></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。<br><img src="/img/mysql/mysql_1/03.png" alt=""><br>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MySQL中定义数据字段的类型对你数据库的优化是非常重要的。&lt;br&gt;MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符
      
    
    </summary>
    
      <category term="mysql" scheme="https://blog.devzou.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.devzou.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发之servlet、Filter、Listener</title>
    <link href="https://blog.devzou.com/2019/08/12/Java/2019-10-25-servlet%E3%80%81Filer%E3%80%81Listener/"/>
    <id>https://blog.devzou.com/2019/08/12/Java/2019-10-25-servlet、Filer、Listener/</id>
    <published>2019-08-12T00:10:09.000Z</published>
    <updated>2019-10-25T00:10:06.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet 是服务端的 Java 应用程序，用于处理HTTP请求，做出相应的响应。</p><p>当客户端向服务器发出HTTP请求时，首先会由服务器中的 Web 容器（如Tomcat）对请求进行路由，交给该URL对应的 Servlet 进行处理，Servlet 所要做的事情就是返回适当的内容给用户。</p><p>要创建自己的 Servlet，可以通过以下三种方式来实现</p><ul><li>实现 Servlet 接口</li><li>继承 GenericServlet 类</li><li>继承 HttpServlet 类</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h2&gt;&lt;p&gt;Servlet 是服务端的 Java 应用程序，用于处理HTTP请求，做出相应的响应。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Java" scheme="https://blog.devzou.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.devzou.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA数据库连接之JDBC</title>
    <link href="https://blog.devzou.com/2019/08/12/Java/2019-10-21-Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%B9%8BJDBC/"/>
    <id>https://blog.devzou.com/2019/08/12/Java/2019-10-21-Java数据库连接之JDBC/</id>
    <published>2019-08-12T00:10:09.000Z</published>
    <updated>2019-10-21T13:52:10.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JDBC (Java Database Connectivity) API，即Java数据库编程接口，是连接java应用程序和数据库之间的桥粱，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。比如建立数据库连接、执行SQL语句进行数据的存取操作。</p><h2 id="JDBC使用详解"><a href="#JDBC使用详解" class="headerlink" title="JDBC使用详解"></a>JDBC使用详解</h2><h3 id="1-加载驱动器类"><a href="#1-加载驱动器类" class="headerlink" title="1.加载驱动器类"></a>1.加载驱动器类</h3><h3 id="2-建立与数据库的链接"><a href="#2-建立与数据库的链接" class="headerlink" title="2.建立与数据库的链接"></a>2.建立与数据库的链接</h3><h3 id="3-创建statement对象"><a href="#3-创建statement对象" class="headerlink" title="3.创建statement对象"></a>3.创建statement对象</h3><h3 id="4-执行SQL语句"><a href="#4-执行SQL语句" class="headerlink" title="4.执行SQL语句"></a>4.执行SQL语句</h3><h3 id="5-访问ResultSet的记录"><a href="#5-访问ResultSet的记录" class="headerlink" title="5.访问ResultSet的记录"></a>5.访问ResultSet的记录</h3><h3 id="6-依次关闭ResultSet、Statement、Connection对象"><a href="#6-依次关闭ResultSet、Statement、Connection对象" class="headerlink" title="6.依次关闭ResultSet、Statement、Connection对象"></a>6.依次关闭ResultSet、Statement、Connection对象</h3><p>示例代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String DRIVER_NAME = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String URL = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String USER_NAME = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String PWD = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">    <span class="keyword">static</span>  &#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            properties.load(DBUtil.class.getResourceAsStream(<span class="string">"/jdbc.properties"</span>));</div><div class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            System.out.println(<span class="string">"系统加载jdbc.properties配置文件异常"</span>);</div><div class="line">        &#125;</div><div class="line">        DRIVER_NAME = properties.getProperty(<span class="string">"jdbc.driver"</span>);</div><div class="line">        URL = properties.getProperty(<span class="string">"jdbc.url"</span>);</div><div class="line">        USER_NAME = properties.getProperty(<span class="string">"jdbc.username"</span>);</div><div class="line">        PWD = properties.getProperty(<span class="string">"jdbc.password"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class.forName(DRIVER_NAME);</div><div class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            System.out.println(<span class="string">"数据库驱动加载异常，请检查"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//        DriverManager.registerDriver(new Driver());</span></div><div class="line">        Connection connection = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">            connection = DriverManager.getConnection(URL, USER_NAME, PWD);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            System.out.println(e);</div><div class="line">            System.out.println(<span class="string">"连接数据库失败了"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  connection;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection connection)</span> </span>&#123;</div><div class="line">        close(connection);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection connection, Statement statement, ResultSet resultSet)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (resultSet !=<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!resultSet.isClosed()) &#123;</div><div class="line">                    resultSet.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (connection !=<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!connection.isClosed()) &#123;</div><div class="line">                    connection.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (statement !=<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!statement.isClosed()) &#123;</div><div class="line">                    statement.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JDBC (Java Database Connectivity) API，即Java数据库编程接口，是连接java应用程序和数据库之间的桥
      
    
    </summary>
    
      <category term="Java" scheme="https://blog.devzou.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.devzou.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.devzou.com/2019/08/01/tool/2019-08-01-charles%E7%A0%B4%E8%A7%A3/"/>
    <id>https://blog.devzou.com/2019/08/01/tool/2019-08-01-charles破解/</id>
    <published>2019-08-01T06:41:16.462Z</published>
    <updated>2019-08-01T07:19:06.491Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: charles系列破解激活方法<br>date: 2019-05-16 8:10:09<br>category: 工具<br>tags: 工具<br>description: 软件破解</p><hr><h2 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h2><p> // Charles Proxy License</p><p>// 适用于Charles任意版本的注册码，谁还会想要使用破解版呢。</p><p>// Charles 4.2.8目前是最新版，可用。<br>注册名称：https：//zhile.io</p><p>许可证密钥：48891cf209c6d32bf4</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: charles系列破解激活方法&lt;br&gt;date: 2019-05-16 8:10:09&lt;br&gt;category: 工具&lt;br&gt;tags: 工具&lt;br&gt;description: 软件破解&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;破解方法&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>navicat for mac 登录数据库报错</title>
    <link href="https://blog.devzou.com/2019/07/31/mysql/2019-08-02-navicat%20for%20mac%20%E7%99%BB%E5%BD%95%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99/"/>
    <id>https://blog.devzou.com/2019/07/31/mysql/2019-08-02-navicat for mac 登录数据库报错/</id>
    <published>2019-07-31T01:10:09.000Z</published>
    <updated>2019-10-17T22:15:28.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报错描述"><a href="#报错描述" class="headerlink" title="报错描述"></a>报错描述</h2><p>2059 - Authentication plugin ‘caching_sha2_password’ cannot be loaded: dlopen(../Frameworks/caching_sha2_password.so, 2): image not found</p><h2 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h2><p>这是 MySQL 的问题，不是客户端问题，</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘yourpassword’;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;报错描述&quot;&gt;&lt;a href=&quot;#报错描述&quot; class=&quot;headerlink&quot; title=&quot;报错描述&quot;&gt;&lt;/a&gt;报错描述&lt;/h2&gt;&lt;p&gt;2059 - Authentication plugin ‘caching_sha2_password’ cannot be
      
    
    </summary>
    
      <category term="mysql" scheme="https://blog.devzou.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.devzou.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>xcodeproj使用</title>
    <link href="https://blog.devzou.com/2019/07/31/ios/2019-07-31-xcodeproj%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.devzou.com/2019/07/31/ios/2019-07-31-xcodeproj使用/</id>
    <published>2019-07-31T01:10:09.000Z</published>
    <updated>2019-07-31T02:43:51.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Xcodeproj的作用是使用Ruby来创建和修改Xcode项目，包括对Xcode工作区（.xcworkspace）和配置文件（.xcconfig）等的修改。xcodeproj这个库功能很强大，XCode工程的大多数配置都可以通过通过xcodeproj完成；在这里主要给大家介绍下一些常用配置的修改方法。</p><h2 id="安装xcodeproj"><a href="#安装xcodeproj" class="headerlink" title="安装xcodeproj"></a>安装xcodeproj</h2><p><code>gem install xcodeproj</code></p><h2 id="通过xcodeproj在工程的xxx-group下引入xx-h和xx-m文件"><a href="#通过xcodeproj在工程的xxx-group下引入xx-h和xx-m文件" class="headerlink" title="通过xcodeproj在工程的xxx group下引入xx.h和xx.m文件"></a>通过xcodeproj在工程的xxx group下引入xx.h和xx.m文件</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></div><div class="line"></div><div class="line"><span class="comment">#打开项目工程xxx.xcodeproj</span></div><div class="line">project_path =  <span class="string">'xxxPath/xxx.xcodeproj'</span></div><div class="line">project = Xcodeproj::Project.open(project_path)</div><div class="line"></div><div class="line"><span class="comment">#找到要插入的group (参数中true表示如果找不到group，就创建一个group)</span></div><div class="line">group = project.main_group.find_subpath(File.join(<span class="string">'GroupName'</span>),<span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="comment">#set一下sorce_tree</span></div><div class="line">group.set_source_tree(<span class="string">'SOURCE_ROOT'</span>)</div><div class="line"></div><div class="line"><span class="comment">#向group中增加文件引用（.h文件只需引用一下，.m引用后还需add一下）</span></div><div class="line">file_ref = group.new_reference(<span class="string">'xxxPath/xx.h'</span>)</div><div class="line"></div><div class="line">file_ref = group.new_reference(<span class="string">'xxxPath/xx.m'</span>)</div><div class="line">ret = target.add_file_references(file_ref)</div><div class="line"></div><div class="line">project.save</div></pre></td></tr></table></figure><h2 id="通过xcodeproj在工程中引入framwork、-a文件和bundle文件"><a href="#通过xcodeproj在工程中引入framwork、-a文件和bundle文件" class="headerlink" title="通过xcodeproj在工程中引入framwork、.a文件和bundle文件"></a>通过xcodeproj在工程中引入framwork、.a文件和bundle文件</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></div><div class="line"></div><div class="line"><span class="comment">#打开项目工程A.xcodeproj</span></div><div class="line">project_path =  <span class="string">'xxxPath/xx.xcodeproj'</span></div><div class="line">project = Xcodeproj::Project.open(project_path)</div><div class="line"></div><div class="line"><span class="comment">#遍历target，找到需要操作的target</span></div><div class="line"></div><div class="line">targetIndex = <span class="number">0</span></div><div class="line"></div><div class="line">project.targets.each_with_index <span class="keyword">do</span> <span class="params">|target, index|</span></div><div class="line">  <span class="keyword">if</span> target.name  == <span class="string">"xxxTargetName"</span></div><div class="line">    targetIndex = index</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">target = project.targets[targetIndex]</div><div class="line"></div><div class="line"><span class="comment">#添加xx.framework的引用</span></div><div class="line">file_ref = project.frameworks_group.new_file(<span class="string">'xxPath/xx.framework'</span>)</div><div class="line">target.frameworks_build_phases.add_file_reference(file_ref)</div><div class="line"></div><div class="line"><span class="comment">#添加xx.a的引用</span></div><div class="line">file_ref = project.frameworks_group.new_file(<span class="string">'xxPath/xx.a'</span>)</div><div class="line">target.frameworks_build_phases.add_file_reference(file_ref)</div><div class="line"></div><div class="line"><span class="comment">#添加xx.bundle的引用</span></div><div class="line">file_ref = project.frameworks_group.new_file(<span class="string">'xxPath/xx.bundle'</span>)</div><div class="line">target.resources_build_phase.add_file_reference(file_ref)</div><div class="line"></div><div class="line">project.save</div></pre></td></tr></table></figure><h2 id="通过xcodeproj在把xx-framework-xxx-h-xxx-bundle-加入到copy-files-phase中"><a href="#通过xcodeproj在把xx-framework-xxx-h-xxx-bundle-加入到copy-files-phase中" class="headerlink" title="通过xcodeproj在把xx.framework xxx.h  xxx.bundle 加入到copy files phase中"></a>通过xcodeproj在把xx.framework xxx.h  xxx.bundle 加入到copy files phase中</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></div><div class="line"><span class="comment">#打开项目工程A.xcodeproj </span></div><div class="line">project_path = <span class="string">'xxxPath/xx.xcodeproj'</span> </div><div class="line">project = Xcodeproj::Project.open(project_path)</div><div class="line"><span class="comment">#遍历target，找到需要操作的target </span></div><div class="line">targetIndex = <span class="number">0</span> </div><div class="line">project.targets.each_with_index <span class="keyword">do</span> <span class="params">|target, index|</span> </div><div class="line">  <span class="keyword">if</span> target.name == <span class="string">"xxxTargetName"</span> </div><div class="line">    targetIndex = index </div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">target = project.targets[targetIndex] </div><div class="line"></div><div class="line">file_ref = project.frameworks_group.new_file(<span class="string">'xxPath/xx.framework'</span>)</div><div class="line"></div><div class="line"><span class="comment">#把xx.framework添加到copy files中</span></div><div class="line"><span class="comment">#"leakFramework"即copy files build phase的名字，可自己随便取，也可不填，默认为空</span></div><div class="line">target.new_copy_files_build_phase(<span class="string">"leakFramework"</span>)</div><div class="line"></div><div class="line"><span class="comment">#项目中可能有多个copy files build phases，找到刚刚创建的那个，然后把xx.framework引入</span></div><div class="line">target.copy_files_build_phases.each <span class="keyword">do</span> <span class="params">|item|</span> </div><div class="line">  <span class="keyword">if</span> item.name == <span class="string">"leakFramework"</span></div><div class="line">     <span class="comment">#引入xx.framework</span></div><div class="line">     item.add_file_reference(file_ref)</div><div class="line">     <span class="comment">#设置copy file buldphase中的Destination选项，使用枚举值表示的。"10"表示Frameworks </span></div><div class="line">     <span class="comment">#这个值我是通过对比设置前后的两个文件找出来的</span></div><div class="line">     item.dst_subfolder_spec = <span class="string">"10"</span></div><div class="line">     <span class="comment">#勾上code sign on copy选项（默认是没勾上的）</span></div><div class="line">     item.files[<span class="number">0</span>].settings = Hash.new  </div><div class="line">     item.files[<span class="number">0</span>].settings[<span class="string">"ATTRIBUTES"</span>] = [<span class="string">"CodeSignOnCopy"</span>] </div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">project.save</div></pre></td></tr></table></figure><h2 id="通过xcodeproj设置证书"><a href="#通过xcodeproj设置证书" class="headerlink" title="通过xcodeproj设置证书"></a>通过xcodeproj设置证书</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></div><div class="line"></div><div class="line"><span class="comment">#打开项目工程A.xcodeproj</span></div><div class="line">project_path = <span class="string">'xxxPath/A.xcodeproj'</span></div><div class="line">project = Xcodeproj::Project.open(project_path)</div><div class="line"></div><div class="line"><span class="comment">#修改某个target在debug模式下的证书配置</span></div><div class="line"><span class="comment">#此处遍历找到debug</span></div><div class="line">project.targets[<span class="number">0</span>].build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></div><div class="line">  <span class="keyword">if</span> config.name == <span class="string">'Debug'</span></div><div class="line">    config.build_settings[<span class="string">"PROVISIONING_PROFILE_SPECIFIER"</span>] = <span class="string">"xxProfileName"</span></div><div class="line">    config.build_settings[<span class="string">"DEVELOPMENT_TEAM"</span>] = <span class="string">"xxTeamName"</span></div><div class="line">    config.build_settings[<span class="string">"CODE_SIGN_IDENTITY"</span>] = <span class="string">"xxIdentityName"</span></div><div class="line">    config.build_settings[<span class="string">"CODE_SIGN_IDENTITY[sdk=iphoneos*]"</span>] = <span class="string">"iPhone Developer"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">project.save</div></pre></td></tr></table></figure><p>此处可以通过此方法修改target下某个模式（debug, release等）的大多数配置，可通过config.build_settings查看所有的键值对，然后根据需求修改键值，如OTHER_FLAGS,PRODUCT_BUNDLE_IDENTIFIER,HEADER_SEARCH_PATHS,LIBRARY_SEARCH_PATHS等。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://rubygems.org/gems/xcodeproj" target="_blank" rel="external">https://rubygems.org/gems/xcodeproj</a><br><a href="https://github.com/CocoaPods/Xcodeproj" target="_blank" rel="external">https://github.com/CocoaPods/Xcodeproj</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Xcodeproj的作用是使用Ruby来创建和修改Xcode项目，包括对Xcode工作区（.xcworkspace）和配置文件（.xccon
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>idea配置flutter开发环境</title>
    <link href="https://blog.devzou.com/2019/07/30/flutter/2019-09-03-idea%E9%85%8D%E7%BD%AEflutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.devzou.com/2019/07/30/flutter/2019-09-03-idea配置flutter开发环境/</id>
    <published>2019-07-30T01:10:09.000Z</published>
    <updated>2019-09-03T02:36:46.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装flutter插件"><a href="#安装flutter插件" class="headerlink" title="安装flutter插件"></a>安装flutter插件</h2><p> 在Preferences -&gt; Plugin 中搜索flutter并install,如下图<br> <img src="/img/flutter/02/flutter02_1.png" alt=""><br> <img src="/img/flutter/02/flutter02_2.png" alt=""></p><h2 id="install-SDK"><a href="#install-SDK" class="headerlink" title="install SDK"></a>install SDK</h2><p>选择安装路径<br> <img src="/img/flutter/02/flutter02_3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装flutter插件&quot;&gt;&lt;a href=&quot;#安装flutter插件&quot; class=&quot;headerlink&quot; title=&quot;安装flutter插件&quot;&gt;&lt;/a&gt;安装flutter插件&lt;/h2&gt;&lt;p&gt; 在Preferences -&amp;gt; Plugin 中搜索flut
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>flutter入门之在macOS上搭建开发环境</title>
    <link href="https://blog.devzou.com/2019/07/30/flutter/2019-09-02-flutter%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.devzou.com/2019/07/30/flutter/2019-09-02-flutter入门之环境配置/</id>
    <published>2019-07-30T01:10:09.000Z</published>
    <updated>2019-09-02T23:13:39.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>要安装并运行Flutter，您的开发环境必须满足以下最低要求:</p><ul><li>操作系统: macOS (64-bit)</li><li>磁盘空间: 700 MB (不包括Xcode或Android Studio的磁盘空间）.</li><li>工具: Flutter 依赖下面这些命令行工具.<br>bash, mkdir, rm, git, curl, unzip, which<h2 id="获取flutter-SDK"><a href="#获取flutter-SDK" class="headerlink" title="获取flutter SDK"></a>获取flutter SDK</h2>1.去flutter官网下载其最新可用的安装包，<a href="https://flutter.io/sdk-archive/#macos" target="_blank" rel="external">转到下载页 </a>。<br>注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，<a href="https://github.com/flutter/flutter/releases" target="_blank" rel="external">转到下载页</a> 。</li></ul><p>2.解压安装包到你想安装的目录，比如我是放在用户目录下面<br>  <img src="/img/flutter/01/flutter01_1.png" alt=""><br>3.添加flutter相关工具到path中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=`<span class="built_in">pwd</span>`/flutter/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure></p><p> <img src="/img/flutter/01/flutter01_3.png" alt="">  </p><h2 id="运行-flutter-doctor"><a href="#运行-flutter-doctor" class="headerlink" title="运行 flutter doctor"></a>运行 flutter doctor</h2><p>运行以下命令查看是否需要安装其它依赖项来完成安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flutter doctor</div></pre></td></tr></table></figure></p><p><img src="/img/flutter/01/flutter01_2.png" alt=""><br>该命令检查您的环境并在终端窗口中显示报告。Dart SDK已经在捆绑在Flutter里了，没有必要单独安装Dart。 仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务（以粗体显示）</p><p>第一次运行一个flutter命令（如flutter doctor）时，它会下载它自己的依赖项并自行编译。以后再运行就会快得多。</p><p>以下各部分介绍如何执行这些任务并完成设置过程。你会看到在flutter doctor输出中， 如果你选择使用IDE，我们提供了，IntelliJ IDEA，Android Studio和VS Code的插件， 请参阅<a href="https://flutterchina.club/get-started/editor/" target="_blank" rel="external">编辑器设置</a> 以了解安装Flutter和Dart插件的步骤。</p><p>一旦你安装了任何缺失的依赖，再次运行flutter doctor命令来验证你是否已经正确地设置了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统要求&quot;&gt;&lt;a href=&quot;#系统要求&quot; class=&quot;headerlink&quot; title=&quot;系统要求&quot;&gt;&lt;/a&gt;系统要求&lt;/h2&gt;&lt;p&gt;要安装并运行Flutter，您的开发环境必须满足以下最低要求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统: macOS (64-b
      
    
    </summary>
    
      <category term="fluter" scheme="https://blog.devzou.com/categories/fluter/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ios 证书无法生成p12 文件解决，或者无法生成秘钥问题</title>
    <link href="https://blog.devzou.com/2019/05/12/ios/2019-05-11-ios%20%E8%AF%81%E4%B9%A6%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90p12%20%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%88%96%E8%80%85%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E7%A7%98%E9%92%A5/"/>
    <id>https://blog.devzou.com/2019/05/12/ios/2019-05-11-ios 证书无法生成p12 文件解决，或者无法生成秘钥/</id>
    <published>2019-05-12T01:10:09.000Z</published>
    <updated>2019-05-21T00:38:02.377Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog.devzou.com/img/ios/ioscer_1_01.png" alt=""></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>发布证书即将过期，按照相应的步骤去生成证书后，在本机电脑安装后没有秘钥(就是看不到钥匙串证书左边的那个三角符号)。如下图证书没有秘钥是无法导出p12文件的。<br><img src="/img/ios/ioscer_1_02.png" alt=""></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>1.证书类型选择错误，左侧有两个分类，选择 登录–证书，找到需要导出的文件，右键点击可导出p12文件，如果在 登录–证书 中找不到需要的证书，而在 系统–证书 中能找到，拖动证书到登录即可解决。<br>2.生成证书时选择的CSR文件为非本机电脑生成的。重新在本机上生成CSR文件，然后再重新生成证书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://blog.devzou.com/img/ios/ioscer_1_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Mach-O 可执行文件</title>
    <link href="https://blog.devzou.com/2019/04/20/ios/2019-05-06-Mach-O%20%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://blog.devzou.com/2019/04/20/ios/2019-05-06-Mach-O 可执行文件/</id>
    <published>2019-04-20T00:10:09.000Z</published>
    <updated>2019-05-21T00:37:36.301Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog.devzou.com/img/ios/macho_01.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mach-O 是 Apple 系统上（包括 MacOS 以及 iOS）的可执行文件格式，类似于 windows 上的 PE 文件以及 linux 上的 ELF 文件。上图左边为官方图，右边为用<a href="https://github.com/gdbinit/MachOView" target="_blank" rel="external">MachOView</a>软件打开的 Mach-O 文件图。可以非常清晰的看到，这种文件格式由文件头（Header）、加载命令（Load Commands）以及具体数据（Segment&amp;Section）组成。下面一一介绍。 </p><h2 id="Header-文件头"><a href="#Header-文件头" class="headerlink" title="Header(文件头)"></a>Header(文件头)</h2><p>Header(文件头)的作用是使系统能够快速定位其运行环境以及文件类型等等<br>源码如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The 32-bit mach header appears at the very beginning of the object file for</span></div><div class="line"><span class="comment"> * 32-bit architectures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> mach_header &#123;</div><div class="line">uint32_tmagic;<span class="comment">/* mach magic number identifier */</span></div><div class="line">cpu_type_tcputype;<span class="comment">/* cpu specifier */</span></div><div class="line">cpu_subtype_tcpusubtype;<span class="comment">/* machine specifier */</span></div><div class="line">uint32_tfiletype;<span class="comment">/* type of file */</span></div><div class="line">uint32_tncmds;<span class="comment">/* number of load commands */</span></div><div class="line">uint32_tsizeofcmds;<span class="comment">/* the size of all the load commands */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">/* Constant for the magic field of the mach_header (32-bit architectures) */</span></div><div class="line"><span class="meta">#defineMH_MAGIC0xfeedface/* the mach magic number */</span></div><div class="line"><span class="meta">#define MH_CIGAM0xcefaedfe/* NXSwapInt(MH_MAGIC) */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The 64-bit mach header appears at the very beginning of object files for</span></div><div class="line"><span class="comment"> * 64-bit architectures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> mach_header_64 &#123;</div><div class="line">uint32_tmagic;<span class="comment">/* mach magic number identifier */</span></div><div class="line">cpu_type_tcputype;<span class="comment">/* cpu specifier */</span></div><div class="line">cpu_subtype_tcpusubtype;<span class="comment">/* machine specifier */</span></div><div class="line">uint32_tfiletype;<span class="comment">/* type of file */</span></div><div class="line">uint32_tncmds;<span class="comment">/* number of load commands */</span></div><div class="line">uint32_tsizeofcmds;<span class="comment">/* the size of all the load commands */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">uint32_treserved;<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span></div><div class="line"><span class="meta">#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */</span></div><div class="line"><span class="meta">#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */</span></div></pre></td></tr></table></figure></p><p>分析文件头的 otool 命令为： <code>otool -h 可执行文件</code> ，或者可视化强一点的 <code>otool -hv 可执行文件</code>。</p><h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><p>Load Commands 是跟在 Header 后面的加载命令区，所有 commands 的大小总和即为 Header-&gt;sizeofcmds 字段，共有 Header-&gt;ncmds 条加载命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct load_command &#123;</div><div class="line">    uint32_t cmd;        /* type of load command */</div><div class="line">    uint32_t cmdsize;    /* total size of command in bytes */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>Command 以 LC 开头，不同的加载命令有不同的专有的结构体，cmd 和 cmdsize 是都有的，分别为命令类型（即命令名称），这条命令的长度。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。如果当前 LC_SEGMENT 包含 section，那么 section 的结构体紧跟在 LC_SEGMENT 的结构体之后，所占字节数由 SEGMENT 的 cmdsize 字段给出。</p><table><thead><tr><th style="text-align:center">Cmd</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">LC_SEGMENT/LC_SEGMENT_64</td><td style="text-align:center">将对应的段中的数据加载并映射到进程的内存空间去</td></tr><tr><td style="text-align:center">LC_SYMTAB</td><td style="text-align:center">符号表信息</td></tr><tr><td style="text-align:center">LC_DYSYMTAB</td><td style="text-align:center">动态符号表信息</td></tr><tr><td style="text-align:center">LC_LOAD_DYLINKER</td><td style="text-align:center">启动动态加载连接器/usr/lib/dyld程序</td></tr><tr><td style="text-align:center">LC_UUID</td><td style="text-align:center">唯一的 UUID，标示该二进制文件，128bit</td></tr><tr><td style="text-align:center">LC_VERSION_MIN_IPHONEOS/MACOSX</td><td style="text-align:center">要求的最低系统版本（Xcode中的Deployment Target）</td></tr><tr><td style="text-align:center">LC_MAIN</td><td style="text-align:center">设置程序主线程的入口地址和栈大小</td></tr><tr><td style="text-align:center">LC_ENCRYPTION_INFO</td><td style="text-align:center">加密信息</td></tr><tr><td style="text-align:center">LC_LOAD_DYLIB</td><td style="text-align:center">加载的动态库，包括动态库地址、名称、版本号等</td></tr><tr><td style="text-align:center">LC_FUNCTION_STARTS</td><td style="text-align:center">函数地址起始表</td></tr><tr><td style="text-align:center">LC_CODE_SIGNATURE</td><td style="text-align:center">代码签名信息</td></tr></tbody></table><p>使用命令 <code>otool -l 可执行文件</code> 可以查看加载命令区，使用<code>otool -l 可执行文件|grep cryptid</code> 可以查看是否加密</p><h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><p>Mach-O 文件有多个段（Segment），每个段有不同的功能。然后每个段又分为很多小的 Section。 LC_SEGMENT 意味着这部分文件需要映射到进程的地址空间去。一般有以下段名：<br><strong>__PAGEZERO:</strong>　空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用。<br><strong>__TEXT:</strong>　包含了执行代码以及其他只读数据。该段数据可以 VM_PROT_READ(读)、VM_PROT_EXECUTE(执行)，不能被修改。<br><strong>__DATA:</strong>　程序数据，该段可写 VM_PROT_WRITE/READ/EXECUTE。<br><strong>__LINKEDIT:</strong>　链接器使用的符号以及其他表。</p><p>段的结构体定义为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> segment_command &#123; <span class="comment">/* for 32-bit architectures */</span></div><div class="line">uint32_tcmd;<span class="comment">/* LC_SEGMENT */</span></div><div class="line">uint32_tcmdsize;<span class="comment">/* includes sizeof section structs */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment name */</span></div><div class="line">uint32_tvmaddr;<span class="comment">/* memory address of this segment 段的虚拟内存地址*/</span></div><div class="line">uint32_tvmsize;<span class="comment">/* memory size of this segment  段的虚拟内存大小*/</span></div><div class="line">uint32_tfileoff;<span class="comment">/* file offset of this segment  段在文件中的偏移量*/</span></div><div class="line">uint32_tfilesize;<span class="comment">/* amount to map from the file  段在文件中的大小*/</span></div><div class="line">vm_prot_tmaxprot;<span class="comment">/* maximum VM protection */</span></div><div class="line">vm_prot_tinitprot;<span class="comment">/* initial VM protection */</span></div><div class="line">uint32_tnsects;<span class="comment">/* number of sections in segment */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> segment_command_64 &#123; <span class="comment">/* for 64-bit architectures */</span></div><div class="line">uint32_tcmd;<span class="comment">/* LC_SEGMENT_64 */</span></div><div class="line">uint32_tcmdsize;<span class="comment">/* includes sizeof section_64 structs */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment name */</span></div><div class="line">uint64_tvmaddr;<span class="comment">/* memory address of this segment */</span></div><div class="line">uint64_tvmsize;<span class="comment">/* memory size of this segment */</span></div><div class="line">uint64_tfileoff;<span class="comment">/* file offset of this segment */</span></div><div class="line">uint64_tfilesize;<span class="comment">/* amount to map from the file */</span></div><div class="line">vm_prot_tmaxprot;<span class="comment">/* maximum VM protection */</span></div><div class="line">vm_prot_tinitprot;<span class="comment">/* initial VM protection */</span></div><div class="line">uint32_tnsects;<span class="comment">/* number of sections in segment */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>其中 nsects 字段就是表明该段中有多少个 section。文件映射的起始位置是由 fileoff 给出，映射到地址空间的 vmaddr 处。</p><h2 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h2><p>Section 是具体有用的数据存放的地方。它的结构体跟随在 LC_SEGMENT 结构体之后，LC_SEGMENT 又在 Load Commands 中，但是 segment 的数据内容是跟在 Load Commands 之后的。它的结构体为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></div><div class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></div><div class="line">uint32_taddr;<span class="comment">/* memory address of this section 该节在内存中的起始位置*/</span></div><div class="line">uint32_tsize;<span class="comment">/* size in bytes of this section 该节的大小*/</span></div><div class="line">uint32_toffset;<span class="comment">/* file offset of this section 该节的文件偏移*/</span></div><div class="line">uint32_talign;<span class="comment">/* section alignment (power of 2) 字节大小对齐*/</span></div><div class="line">uint32_treloff;<span class="comment">/* file offset of relocation entries 重定位入口的文件偏移*/</span></div><div class="line">uint32_tnreloc;<span class="comment">/* number of relocation entries 需要重定位的入口数量*/</span></div><div class="line">uint32_tflags;<span class="comment">/* flags (section type and attributes) */</span></div><div class="line">uint32_treserved1;<span class="comment">/* reserved (for offset or index) */</span></div><div class="line">uint32_treserved2;<span class="comment">/* reserved (for count or sizeof) */</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></div><div class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></div><div class="line">uint64_taddr;<span class="comment">/* memory address of this section */</span></div><div class="line">uint64_tsize;<span class="comment">/* size in bytes of this section */</span></div><div class="line">uint32_toffset;<span class="comment">/* file offset of this section */</span></div><div class="line">uint32_talign;<span class="comment">/* section alignment (power of 2) */</span></div><div class="line">uint32_treloff;<span class="comment">/* file offset of relocation entries */</span></div><div class="line">uint32_tnreloc;<span class="comment">/* number of relocation entries */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags (section type and attributes)*/</span></div><div class="line">uint32_treserved1;<span class="comment">/* reserved (for offset or index) */</span></div><div class="line">uint32_treserved2;<span class="comment">/* reserved (for count or sizeof) */</span></div><div class="line">uint32_treserved3;<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>其中 flag 字段分为两个部分，一个是区域类型（section type），一个是区域属性（section attributes）。其中 type 是互斥的，即只能有一个类型，而 attributes 不是互斥的，可以有多个属性。如果段（segment）中的任何一个 section 拥有属性 S_ATTR_DEBUG，那么该段所有的 section 都必须拥有这个属性。具体的flag字段内容以及意义请参考 /usr/include/mach-o/loader.h。</p><p>段名为大写，节名为小写。各节的作用主要有：</p><ul><li>__text:　主程序代码</li><li>__stub_helper:　用于动态链接的存根</li><li>__symbolstub1:　用于动态链接的存根</li><li>__objc_methname:　Objective-C 的方法名</li><li>__objc_classname:　Objective-C 的类名</li><li><p>__cstring:　硬编码的字符串</p></li><li><p>__lazy_symbol:　懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接</p></li><li>_got:　存储引用符号的实际地址，类似于动态符号表</li><li>__nl_symbol_ptr:　非延迟加载节</li><li>__mod_init_func:　初始化的全局函数地址，在 main 之前被调用</li><li>__mod_term_func:　结束函数地址</li><li><p>__cfstring:　Core Foundation 用到的字符串（OC字符串）</p></li><li><p>__objc_clsslist:　Objective-C 的类列表</p></li><li><strong>objc_nlclslist:　Objective-C 的 +load 函数列表，比 </strong>mod_init_func 更早执行</li><li>__objc_const:　Objective-C 的常量</li><li>__data:　初始化的可变的变量</li><li>__bss:　未初始化的静态变量</li></ul><p>查看某段中某节的命令为： <code>otool -s __TEXT __text 可执行文件</code>。</p><h2 id="与-IDA-的对应地址"><a href="#与-IDA-的对应地址" class="headerlink" title="与 IDA 的对应地址"></a>与 IDA 的对应地址</h2><p>如果用 MachOView 来查看的话，界面左上角有一个 RAW、RVA 的选项。RAW 就是指该字节相对于文件开始部分的绝对偏移，文件头部的地址是从0x000开始的。RVA 是相对于某个基地址的偏移，也就是整体的绝对偏移值再加上某个基地址，文件头部的地址是从某个值（基地址）开始的。</p><p>这个所谓的基地址其实是 LC_SEGMENT_64(_PAGEZERO) 中的 VM_Size 字段的值，因为留出这段空白页面就是为了捕获程序的空指针，以及考虑到页面对齐。IDA 中就是使用的 RVA 地址。这个地址在 armv7 中是0x4000，arm64 中是0x10000 0000。</p><p>Section(<strong>TEXT,</strong>text ) 所在的 RVA 地址，对应的就是 IDA 解析的函数开始地址。 IDA 解析的 Mach-O 文件中的函数都位于 Section( <strong>TEXT) 段，然后还会接着解析 Section( </strong>DATA) 段，即 IDA 中的数据区。</p><p>LC_MAIN 加载命令中的 Entry Offset 字段 + 基地址（RVA 选项下的文件头部地址） = IDA 中左侧函数 _main 的地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://blog.devzou.com/img/ios/macho_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能调试之instruments</title>
    <link href="https://blog.devzou.com/2019/03/20/ios/2019-05-06-iOS%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E4%B9%8Binstruments/"/>
    <id>https://blog.devzou.com/2019/03/20/ios/2019-05-06-iOS性能调试之instruments/</id>
    <published>2019-03-20T00:10:09.000Z</published>
    <updated>2019-05-13T02:42:27.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于instruments"><a href="#关于instruments" class="headerlink" title="关于instruments"></a>关于instruments</h2><p>Instruments是功能强大且灵活的性能分析和测试工具，是Xcode工具集的一部分,它旨在帮助您分析您的iOS，watchOS，tvOS和macOS应用程序，流程和设备，以便更好地了解和优化应用程序的行为和性能。从应用程序开发过程开始，将仪器集成到您的工作流程中，可以帮助您在开发周期的早期发现问题，从而节省您的时间。<br>    在Instruments中，您使用专用工具（称为工具）来跟踪应用程序，流程和设备的不同方面。仪器在配置文件时收集数据，并将结果详细呈现给您以供分析。<br>    与其他性能和调试工具不同，Instruments允许您收集广泛不同类型的数据并并排查看。这样可以更轻松地识别可能被忽视的趋势。例如，您的应用可能会因多个开放式网络连接而出现大量内存增长。通过一起使用分配和连接工具，您可以识别未关闭的连接，从而实现快速的内存增长。</p><p>使用 Instruments 你可以做下面这些事：</p><ol><li>检查一个或多个应用或进程的行为。</li><li>检查设备相关的功能，比如：Wi-Fi、蓝牙等。</li><li>在真机或模拟器上进行性能测试。</li><li>创建自定义的 DTrace 来分析系统以及应用的各种行为。</li><li>跟踪源码中的问题。</li><li>对 App 进行性能分析。</li><li>查找 App 中的内存问题，比如：内存泄露(Leaked memory)、废弃内存(Abandoned memory)、僵尸(zombies)等。</li><li>给出程序优化的建议。</li><li>进行系统级别的问题定位。</li><li>通过脚本记录一个用户行为序列，从而可以通过运行脚本对你的 iOS 应用进行可重复多次的自动化测试。</li><li>保存测试配置模板以供复用。<br>虽然 Instruments 是 Xcode 的一个工具集，但是它是以一个独立的 App 的形式存在的，你可以在 Xcode -&gt; Open Developer Tool -&gt; Instruments 中打开它。<h2 id="内存性能"><a href="#内存性能" class="headerlink" title="内存性能"></a>内存性能</h2>Instruments 可以帮我们了解到应用程序使用内存的几个方面：</li></ol><ul><li><strong>全局内存使用情况(Overall Memory Use)</strong>: 从全局的角度监测应用程序的内存使用情况，捕捉非预期的或大幅度的内存增长。</li><li><strong>内存泄露(Leaked memory)</strong>: 未被你的程序引用，同时也不能被使用或释放的内存。</li><li><strong>废弃内存(Abandoned memory)</strong>: 被你的程序引用，但是没什么卵用的内存。</li><li><strong>僵尸对象(Zombies)</strong>: 僵尸对象指的是对应的内存已经被释放并且不再会使用到，但是你的程序却在某处依然有指向它的引用。在 iOS 中有一个 NSZombie 机制，这个是为了内存调试的目的而设计的一种机制。在这个机制下，当你 NSZombieEnabled 为 YES 时，当一个对应的引用计数减为 0 时，这个对象不会被释放，当这个对象再收到任何消息时，它会记录一条 warning，而不是直接崩溃，以方便我们进行程序调试。</li></ul><p>这里我们介绍下查找内存泄露的过程：<br>1.在products-&gt;profile中启动instruments面板<br><img src="/img/ios/performance_1_01.png" alt=""><br>2.选中Leaks模板<br><img src="/img/ios/performance_1_02.png" alt=""></p><ol><li>选择正确的设备和应用程序，点击红色按钮运行应用程序<br><img src="/img/ios/performance_1_03.png" alt=""><br>4.我们可以看到如下界面<br><img src="/img/ios/performance_1_04.png" alt=""></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://help.apple.com/instruments/mac/current/" target="_blank" rel="external"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于instruments&quot;&gt;&lt;a href=&quot;#关于instruments&quot; class=&quot;headerlink&quot; title=&quot;关于instruments&quot;&gt;&lt;/a&gt;关于instruments&lt;/h2&gt;&lt;p&gt;Instruments是功能强大且灵活的性能分析和测
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>webpack4入门教程</title>
    <link href="https://blog.devzou.com/2019/03/06/web%E5%89%8D%E7%AB%AF/2018-04-01-webpack4%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.devzou.com/2019/03/06/web前端/2018-04-01-webpack4入门教程/</id>
    <published>2019-03-06T13:04:24.000Z</published>
    <updated>2019-04-17T13:21:54.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。<br><a id="more"></a></p><h2 id="为什要使用WebPack"><a href="#为什要使用WebPack" class="headerlink" title="为什要使用WebPack"></a>为什要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p><p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常反锁的，这就为WebPack类的工具的出现提供了需求。</p><h2 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h2><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。</p><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。<br>Grunt和Gulp的工作流程<br><img src="/img/webpack_1_03.png" alt=""><br>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。<br><img src="/img/webpack_1_01.png" alt=""><br>Webpack工作方式</p><p>Webpack工作方式<br>如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。</p><p>开始使用Webpack</p><p>初步了解了Webpack工作方式后，我们一步步的开始学习使用Webpack。</p><h2 id="全局安装webpack及webpack-cli"><a href="#全局安装webpack及webpack-cli" class="headerlink" title="全局安装webpack及webpack-cli"></a>全局安装webpack及webpack-cli</h2><p>安装webpack</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g webpack</div></pre></td></tr></table></figure><p>安装webpack-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g webpack-cli</div></pre></td></tr></table></figure><h2 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h2><p>在桌面新建一个文件夹用于存放工程文件,文件夹名称为mywebpack。</p><p>在mywebpack文件夹中创建一个package.json文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init -y</div></pre></td></tr></table></figure><p>在mywebpack文件夹下创建index.html文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>在mywebpack文件夹创建src文件夹,在src文件夹下创建index.js,代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.write(<span class="string">"hello webpack"</span>);</div></pre></td></tr></table></figure></p><p>使用webpack进行打包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --mode development</div></pre></td></tr></table></figure></p><p>执行后结果如下<br><img src="/img/webpack_1_04.png" alt=""><br>【重要】webpack4.x的打包已经不能用webpack 文件a 文件b的方式，而是直接运行webpack –mode development或者webpack –mode production，这样便会默认进行打包，入口文件是’./src/index.js’，输出路径是’./dist/main.js’，其中src目录即index.js文件需要手动创建，而dist目录及main.js会自动生成。</p><p>因此我们不再按webpack 文件a 文件b的方式运行webpack指令，而是直接运行</p><p>　　webpack –mode development<br>或<br>　　webpack –mode production</p><p>这样便能够实现将’./src/index.js’打包成’./dist/main.js’。</p><p>不过每次都要输入这个命令，非常麻烦，我们在package.json中scripts中加入两个成员：</p><p>　　“dev”:”webpack –mode development”,</p><p>　　“build”:”webpack –mode production”</p><p>执行webpack –mode development<br>执行npm run dev，相当于执行webpack –mode development</p><p>执行完毕后打开index.html效果如下<br><img src="/img/webpack_1_02.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。
    
    </summary>
    
      <category term="前端" scheme="https://blog.devzou.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://blog.devzou.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Clang常用命令介绍</title>
    <link href="https://blog.devzou.com/2019/02/20/ios/2019-04-26-clang%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.devzou.com/2019/02/20/ios/2019-04-26-clang常用命令介绍/</id>
    <published>2019-02-20T00:10:09.000Z</published>
    <updated>2019-04-27T09:10:11.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。学习Clang有助于我们对Objective-C编译过程的理解</p><h2 id="Clang常用命令介绍"><a href="#Clang常用命令介绍" class="headerlink" title="Clang常用命令介绍"></a>Clang常用命令介绍</h2><h3 id="clang-ccc-print-phases-main-m"><a href="#clang-ccc-print-phases-main-m" class="headerlink" title="clang -ccc-print-phases main.m"></a>clang -ccc-print-phases main.m</h3><p>功能：查看编译的步骤<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: input, &quot;main.m&quot;, objective-c</div><div class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</div><div class="line">2: compiler, &#123;1&#125;, ir</div><div class="line">3: backend, &#123;2&#125;, assembler</div><div class="line">4: assembler, &#123;3&#125;, object</div><div class="line">5: linker, &#123;4&#125;, image</div><div class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image</div></pre></td></tr></table></figure></p><h3 id="clang-rewrite-objc-main-m"><a href="#clang-rewrite-objc-main-m" class="headerlink" title="clang -rewrite-objc main.m"></a>clang -rewrite-objc main.m</h3><p>功能：查看编译结果<br>输出结果：main.cpp文件</p><h3 id="clang-main-m-o-main"><a href="#clang-main-m-o-main" class="headerlink" title="clang -### main.m -o main"></a>clang -### main.m -o main</h3><p>功能：查看操作内部命令<br>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Apple LLVM version 10.0.1 (clang-1001.0.46.3)</div><div class="line">Target: x86_64-apple-darwin18.2.0</div><div class="line">Thread model: posix</div><div class="line">InstalledDir: /Library/Developer/CommandLineTools/usr/bin</div><div class="line"> &quot;/Library/Developer/CommandLineTools/usr/bin/clang&quot; &quot;-cc1&quot; &quot;-triple&quot; &quot;x86_64-apple-macosx10.14.0&quot; &quot;-Wdeprecated-objc-isa-usage&quot; &quot;-Werror=deprecated-objc-isa-usage&quot; &quot;-emit-obj&quot; &quot;-mrelax-all&quot; &quot;-disable-free&quot; &quot;-disable-llvm-verifier&quot; &quot;-discard-value-names&quot; &quot;-main-file-name&quot; &quot;main.m&quot; &quot;-mrelocation-model&quot; &quot;pic&quot; &quot;-pic-level&quot; &quot;2&quot; &quot;-mthread-model&quot; &quot;posix&quot; &quot;-mdisable-fp-elim&quot; &quot;-fno-strict-return&quot; &quot;-masm-verbose&quot; &quot;-munwind-tables&quot; &quot;-target-sdk-version=10.14&quot; &quot;-target-cpu&quot; &quot;penryn&quot; &quot;-dwarf-column-info&quot; &quot;-debugger-tuning=lldb&quot; &quot;-target-linker-version&quot; &quot;450.3&quot; &quot;-resource-dir&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/clang/10.0.1&quot; &quot;-isysroot&quot; &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk&quot; &quot;-I/usr/local/include&quot; &quot;-Wno-atomic-implicit-seq-cst&quot; &quot;-Wno-framework-include-private-from-public&quot; &quot;-Wno-atimport-in-framework-header&quot; &quot;-Wno-quoted-include-in-framework-header&quot; &quot;-fdebug-compilation-dir&quot; &quot;/Users/ZLY/Desktop&quot; &quot;-ferror-limit&quot; &quot;19&quot; &quot;-fmessage-length&quot; &quot;238&quot; &quot;-stack-protector&quot; &quot;1&quot; &quot;-fblocks&quot; &quot;-fencode-extended-block-signature&quot; &quot;-fregister-global-dtors-with-atexit&quot; &quot;-fobjc-runtime=macosx-10.14.0&quot; &quot;-fobjc-exceptions&quot; &quot;-fexceptions&quot; &quot;-fmax-type-align=16&quot; &quot;-fdiagnostics-show-option&quot; &quot;-fcolor-diagnostics&quot; &quot;-o&quot; &quot;/var/folders/kj/svm6s3rn6kdcvmbhds_grhvm0000gp/T/main-1301a5.o&quot; &quot;-x&quot; &quot;objective-c&quot; &quot;main.m&quot;</div><div class="line"> &quot;/Library/Developer/CommandLineTools/usr/bin/ld&quot; &quot;-demangle&quot; &quot;-lto_library&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/libLTO.dylib&quot; &quot;-no_deduplicate&quot; &quot;-dynamic&quot; &quot;-arch&quot; &quot;x86_64&quot; &quot;-macosx_version_min&quot; &quot;10.14.0&quot; &quot;-syslibroot&quot; &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk&quot; &quot;-o&quot; &quot;main&quot; &quot;/var/folders/kj/svm6s3rn6kdcvmbhds_grhvm0000gp/T/main-1301a5.o&quot; &quot;-L/usr/local/lib&quot; &quot;-lSystem&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/clang/10.0.1/lib/darwin/libclang_rt.osx.a&quot;</div></pre></td></tr></table></figure></p><h2 id="clang基本语法介绍"><a href="#clang基本语法介绍" class="headerlink" title="clang基本语法介绍"></a>clang基本语法介绍</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>-fmodules</td><td>允许modules的语言特性</td></tr><tr><td>-fsyntax-only</td><td>防止编译器生成代码,只是语法级别的说明和修改</td></tr><tr><td>-Xclang <arg></arg></td><td>向clang编译器传递参数</td></tr><tr><td>-dump-tokens</td><td>运行预处理器,拆分内部代码段为各种token</td></tr><tr><td>-ast-dump</td><td>构建抽象语法树AST,然后对其进行拆解和调试</td></tr><tr><td>-S</td><td>只运行预处理和编译步骤</td></tr><tr><td>-fobjc-arc</td><td>为OC对象生成retain和release的调用</td></tr><tr><td>-emit-llvm</td><td>使用LLVM描述汇编和对象文件</td></tr><tr><td>-o <file></file></td><td>输出到目标文件</td></tr><tr><td>-c</td><td>只运行预处理,编译和汇编步骤</td></tr></tbody></table><h2 id="代码编译的执行步骤拆解"><a href="#代码编译的执行步骤拆解" class="headerlink" title="代码编译的执行步骤拆解"></a>代码编译的执行步骤拆解</h2><p>下面我们对iOS代码编译的步骤进行一个简单的拆解,看看内部是如何实现的.<br>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p><p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p><p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p><p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="external">Writing an LLVM Pass — LLVM 5 documentation</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p><p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。<br>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure></p><p>生成汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure></p><p>生成目标文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure></p><p>生成可执行文件，这样就能够执行看到输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">clang main.o -o main</div><div class="line">执行</div><div class="line">./main</div><div class="line">输出</div><div class="line">starming rank 14</div></pre></td></tr></table></figure></p><p>下面是完整步骤：</p><ol><li>编译信息写入辅助文件，创建文件架构 .app 文件</li><li>处理文件打包信息</li><li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li><li>编译.m文件，使用 CompileC 和 clang 命令</li><li>链接需要的 Framework</li><li>编译 xib</li><li>拷贝 xib ，资源文件</li><li>编译 ImageAssets</li><li>处理 info.plist</li><li>执行 CocoaPod 脚本</li><li>拷贝标准库</li><li>创建 .app 文件和签名</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。学习Clang有助于我们对Objective-C编译过程的理
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Python高级编程之爬虫Scrapy框架安装配置</title>
    <link href="https://blog.devzou.com/2018/11/28/python/2017-03-18-python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABScrapy%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.devzou.com/2018/11/28/python/2017-03-18-python高级编程之爬虫Scrapy框架安装配置/</id>
    <published>2018-11-28T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:35.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac下安装Scrapy框架"><a href="#Mac下安装Scrapy框架" class="headerlink" title="Mac下安装Scrapy框架"></a>Mac下安装Scrapy框架</h2><p>刚刚试了下可以，可以简化为下面三个步骤<br>一、删除Mac自带的Python<br>sudo rm -rf /usr/bin/python<br>二、homebrew安装最新的Python<br>brew install python<br>创建一个软链接<br>sudo ln -s /usr/local/bin/python /usr/bin/python<br>三、使用pip安装scrapy<br>使用homebrew安装完python后会自动安装好包管理工具pip，所以执行下面安装命令<br>pip install scrapy<br>安装完成后如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">machaismile$ scrapy</div><div class="line">Scrapy 0.22.2 - no active project</div><div class="line"></div><div class="line">Usage:</div><div class="line">  scrapy &lt;command&gt; [options] [args]</div><div class="line"></div><div class="line">Available commands:</div><div class="line">  bench         Run quick benchmark test</div><div class="line">  fetch         Fetch a URL using the Scrapy downloader</div><div class="line">  runspider     Run a self-contained spider (without creating a project)</div><div class="line">  settings      Get settings values</div><div class="line">  shell         Interactive scraping console</div><div class="line">  startproject  Create new project</div><div class="line">  version       Print Scrapy version</div><div class="line">  view          Open URL in browser, as seen by Scrapy</div><div class="line"></div><div class="line">  [ more ]      More commands available when run from project directory</div><div class="line"></div><div class="line">Use &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command</div></pre></td></tr></table></figure></p><p>出现 zsh: command not found: scrapy 执行</p><p> ln -s  /Library/Frameworks/Python.framework/Versions/2.7/bin/scrapy /usr/local/bin/scrapy</p>]]></content>
    
    <summary type="html">
    
      初级的爬虫我们利用urllib和urllib2库以及正则表达式就可以完成了，不过还有更加强大的工具，爬虫框架Scrapy
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级教程之爬虫urllib基本使用</title>
    <link href="https://blog.devzou.com/2018/11/17/python/2017-03-17-python%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABurllib%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.devzou.com/2018/11/17/python/2017-03-17-python高级教程之爬虫urllib基本使用/</id>
    <published>2018-11-17T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:10.747Z</updated>
    
    <content type="html"><![CDATA[<p>如下程序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure></p><p>把它保存成 demo.py，进入该文件的目录，执行命令<code>python demo.py</code>查看运行结果，感受一下。</p><h2 id="分析扒网页的方法"><a href="#分析扒网页的方法" class="headerlink" title="分析扒网页的方法"></a>分析扒网页的方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</div></pre></td></tr></table></figure><p>首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，当然你也可以把HTTP换做FTP,FILE,HTTPS 等等，只是代表了一种访问控制协议，urlopen一般接受三个参数，它的参数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">urlopen(url, data, timeout)</div></pre></td></tr></table></figure></p><p>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。<br>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT<br>第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><p>response对象有一个read方法，可以返回获取到的网页内容。</p><h2 id="构造Request"><a href="#构造Request" class="headerlink" title="构造Request"></a>构造Request</h2><p>其实上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。比如上面的两行代码，我们可以这么改写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">request = urllib2.Request(<span class="string">"http://www.baidu.com"</span>)</div><div class="line">response = urllib2.urlopen(request)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure></p><p>运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</p><h2 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h2><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。最常见的情况是什么？对了，就是登录注册的时候呀。</p><p>把数据用户名和密码传送到一个URL，然后你得到服务器处理之后的响应，这个该怎么办？下面让我来为小伙伴们揭晓吧！</p><p>数据传送分为POST和GET两种方式，两种方式有什么区别呢？</p><p>最重要的区别是GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。</p><p>POST方式：</p><p>上面我们说了data参数是干嘛的？对了，它就是用在这里的，我们传送的数据就是这个参数data，下面演示一下POST方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">values = &#123;<span class="string">"username"</span>:<span class="string">"1315751082@qq.com"</span>,<span class="string">"password"</span>:<span class="string">"XXXX"</span>&#125;</div><div class="line">data = urllib.urlencode(values) </div><div class="line">url = <span class="string">"https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"</span></div><div class="line">request = urllib2.Request(url,data)</div><div class="line">response = urllib2.urlopen(request)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><p>【抓取糗事百科页面的数据例子】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">import</span> re</div><div class="line"> </div><div class="line">page = <span class="number">1</span></div><div class="line">url = <span class="string">'https://www.qiushibaike.com/text/'</span> + str(page)</div><div class="line">user_agent = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6)'</span></div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    request = urllib2.Request(url,headers = headers)</div><div class="line">    response = urllib2.urlopen(request)</div><div class="line"><span class="comment">#    print response.read()</span></div><div class="line">    content = response.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">    pattern = re.compile(<span class="string">'&lt;div.*?author.*?&lt;a.*?&lt;img.*?&gt;(.*?)&lt;/a&gt;.*?&lt;div.*?'</span>+</div><div class="line">                         <span class="string">'content"&gt;(.*?)&lt;/div&gt;(.*?)&lt;div class="stats.*?class="number"&gt;(.*?)&lt;/i&gt;'</span>,re.S)</div><div class="line">    items = re.findall(pattern,content)</div><div class="line"><span class="comment">#    print items</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">        <span class="keyword">print</span> item</div><div class="line"><span class="comment">#        haveImg = re.search("img",item[3])</span></div><div class="line"><span class="comment">#        if not haveImg:</span></div><div class="line"><span class="comment">#           print item[0],item[1],item[2],item[4]</span></div><div class="line"><span class="keyword">except</span> urllib2.URLError, e:</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"code"</span>):</div><div class="line">        <span class="keyword">print</span> e.code</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"reason"</span>):</div><div class="line">        <span class="keyword">print</span> e.reason</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      怎样扒网页呢？其实就是根据URL来获取它的网页信息，虽然我们在浏览器中看到的是一幅幅优美的画面，但是其实是由浏览器解释才呈现出来的，实质它是一段HTML代码，加 JS、CSS，如果把网页比作一个人，那么HTML便是他的骨架，JS便是他的肌肉，CSS便是它的衣服。所以最重要的部分是存在于HTML中的，下面我们就写个例子来扒一个网页下来。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级教程之爬虫urllib库高级使用</title>
    <link href="https://blog.devzou.com/2018/11/17/python/2017-03-17.-Python%20%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABurllib%E5%BA%93%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.devzou.com/2018/11/17/python/2017-03-17.-Python 高级教程之爬虫urllib库高级使用/</id>
    <published>2018-11-17T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:00.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设置Headers"><a href="#1-设置Headers" class="headerlink" title="1.设置Headers"></a>1.设置Headers</h2><p>有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，我们需要设置一些Headers 的属性。</p><p>首先，打开我们的浏览器，调试浏览器F12，我用的是Chrome，打开网络监听，示意如下，比如知乎，点登录之后，我们会发现登陆之后界面都变化了，出现一个新的界面，实质上这个页面包含了许许多多的内容，这些内容也不是一次性就加载完成的，实质上是执行了好多次请求，一般是首先请求HTML文件，然后加载JS，CSS 等等，经过多次请求之后，网页的骨架和肌肉全了，整个网页的效果也就出来了。<br><img src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/02/2015-02-13-013155-%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-e1423762350360.png" alt=""><br>拆分这些请求，我们只看一第一个请求，你可以看到，有个Request URL，还有headers，下面便是response，图片显示得不全，小伙伴们可以亲身实验一下。那么这个头中包含了许许多多是信息，有文件编码啦，压缩方式啦，请求的agent啦等等。<br>其中，agent就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在headers中设置agent,例如下面的例子，这个例子只是说明了怎样设置的headers，小伙伴们看一下设置格式就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib  </div><div class="line"><span class="keyword">import</span> urllib2  </div><div class="line"></div><div class="line">url = <span class="string">'http://www.server.com/login'</span></div><div class="line">user_agent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>  </div><div class="line">values = &#123;<span class="string">'username'</span> : <span class="string">'cqc'</span>,  <span class="string">'password'</span> : <span class="string">'XXXX'</span> &#125;  </div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;  </div><div class="line">data = urllib.urlencode(values)  </div><div class="line">request = urllib2.Request(url, data, headers)  </div><div class="line">response = urllib2.urlopen(request)  </div><div class="line">page = response.read()</div></pre></td></tr></table></figure><p>另外，我们还有对付”反盗链”的方式，对付防盗链，服务器会识别headers中的referer是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在headers中加入referer</p><p>例如我们可以构建下面的headers<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>  ,</div><div class="line">                        <span class="string">'Referer'</span>:<span class="string">'http://www.zhihu.com/articles'</span> &#125;</div></pre></td></tr></table></figure></p><p>同上面的方法，在传送请求时把headers传入Request参数里，这样就能应付防盗链了。</p><p>另外headers的一些属性，下面的需要特别注意一下：</p><blockquote><p>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求<br>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。<br>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用<br>application/json ： 在 JSON RPC 调用时使用<br>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用<br>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p><h2 id="Proxy（代理）的设置"><a href="#Proxy（代理）的设置" class="headerlink" title="Proxy（代理）的设置"></a>Proxy（代理）的设置</h2></blockquote><p>urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！</p><p>下面一段代码说明了代理的设置用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">enable_proxy = <span class="keyword">True</span></div><div class="line">proxy_handler = urllib2.ProxyHandler(&#123;<span class="string">"http"</span> : <span class="string">'http://some-proxy.com:8080'</span>&#125;)</div><div class="line">null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)</div><div class="line"><span class="keyword">if</span> enable_proxy:</div><div class="line">    opener = urllib2.build_opener(proxy_handler)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    opener = urllib2.build_opener(null_proxy_handler)</div><div class="line">urllib2.install_opener(opener)</div></pre></td></tr></table></figure></p><h2 id="Timeout-设置"><a href="#Timeout-设置" class="headerlink" title="Timeout 设置"></a>Timeout 设置</h2><p>上一节已经说过urlopen方法了，第三个参数就是timeout的设置，可以设置等待多久超时，为了解决一些网站实在响应过慢而造成的影响。</p><p>例如下面的代码,如果第二个参数data为空那么要特别指定是timeout是多少，写明形参，如果data已经传入，则不必声明。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com'</span>, timeout=<span class="number">10</span>)</div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com'</span>,data, <span class="number">10</span>)</div></pre></td></tr></table></figure><h2 id="使用-HTTP-的-PUT-和-DELETE-方法"><a href="#使用-HTTP-的-PUT-和-DELETE-方法" class="headerlink" title="使用 HTTP 的 PUT 和 DELETE 方法"></a>使用 HTTP 的 PUT 和 DELETE 方法</h2><p>http协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求</p><blockquote><p>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。<br>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。<br> 如果要使用 HTTP PUT 和 DELETE ，只能使用比较低层的 httplib 库。虽然如此，我们还是能通过下面的方式，使 urllib2 能够发出 PUT 或DELETE 的请求，不过用的次数的确是少，在这里提一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">request = urllib2.Request(uri, data=data)</div><div class="line">request.get_method = <span class="keyword">lambda</span>: <span class="string">'PUT'</span> <span class="comment"># or 'DELETE'</span></div><div class="line">response = urllib2.urlopen(request)</div></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      urllib库的高级使用
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫实战之爬取糗事百科段子</title>
    <link href="https://blog.devzou.com/2018/10/16/python/2017-03-16-Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%E6%AE%B5%E5%AD%90/"/>
    <id>https://blog.devzou.com/2018/10/16/python/2017-03-16-Python爬虫实战之爬取糗事百科段子/</id>
    <published>2018-10-16T00:10:09.000Z</published>
    <updated>2019-04-24T06:59:24.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="确定URL并抓取页面代码"><a href="#确定URL并抓取页面代码" class="headerlink" title="确定URL并抓取页面代码"></a>确定URL并抓取页面代码</h2><p>首先我们确定好页面的URL是 <a href="http://www.qiushibaike.com/hot/page/1，其中最后一个数字1代表页数，我们可以传入不同的值来获得某一页的段子内容。" target="_blank" rel="external">http://www.qiushibaike.com/hot/page/1，其中最后一个数字1代表页数，我们可以传入不同的值来获得某一页的段子内容。</a></p><p>我们初步构建如下的代码来打印页面代码内容试试看，先构造最基本的页面抓取方式，看看会不会成功<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">page = <span class="number">1</span></div><div class="line">url = <span class="string">'http://www.qiushibaike.com/hot/page/'</span> + str(page)</div><div class="line">user_agent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span></div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    request = urllib2.Request(url,headers = headers)</div><div class="line">    response = urllib2.urlopen(request)</div><div class="line">    <span class="keyword">print</span> response.read()</div><div class="line"><span class="keyword">except</span> urllib2.URLError, e:</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"code"</span>):</div><div class="line">        <span class="keyword">print</span> e.code</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"reason"</span>):</div><div class="line">        <span class="keyword">print</span> e.reason</div></pre></td></tr></table></figure></p><h2 id="提取某一页的所有段子"><a href="#提取某一页的所有段子" class="headerlink" title="提取某一页的所有段子"></a>提取某一页的所有段子</h2><p>好，获取了HTML代码之后，我们开始分析怎样获取某一页的所有段子。</p><p>首先我们审查元素看一下，按浏览器的F12，截图如下</p><p>我们可以看到，每一个段子都是<div class="”article" block="" untagged="" mb15″="" id="”…”">…</div>包裹的内容。</p><p>现在我们想获取发布人，发布日期，段子内容，以及点赞的个数。不过另外注意的是，段子有些是带图片的，如果我们想在控制台显示图片是不现实的，所以我们直接把带有图片的段子给它剔除掉，只保存仅含文本的段子。</p><p>所以我们加入如下正则表达式来匹配一下，用到的方法是 re.findall 是找寻所有匹配的内容。方法的用法详情可以看前面说的正则表达式的介绍。</p><p>好，我们的正则表达式匹配语句书写如下，在原来的基础上追加如下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">content = response.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">pattern = re.compile(<span class="string">'&lt;div.*?author"&gt;.*?&lt;a.*?&lt;img.*?&gt;(.*?)&lt;/a&gt;.*?&lt;div.*?'</span>+</div><div class="line">                         <span class="string">'content"&gt;(.*?)&lt;!--(.*?)--&gt;.*?&lt;/div&gt;(.*?)&lt;div class="stats.*?class="number"&gt;(.*?)&lt;/i&gt;'</span>,re.S)</div><div class="line">items = re.findall(pattern,content)</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">    <span class="keyword">print</span> item[<span class="number">0</span>],item[<span class="number">1</span>],item[<span class="number">2</span>],item[<span class="number">3</span>],item[<span class="number">4</span>]</div></pre></td></tr></table></figure></p><p>现在正则表达式在这里稍作说明</p><p>1）.<em>? 是一个固定的搭配，.和</em>代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配，以后我们还会大量用到 .*? 的搭配。</p><p>2）(.<em>?)代表一个分组，在这个正则表达式中我们匹配了五个分组，在后面的遍历item中，item[0]就代表第一个(.</em>?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。</p><p>3）re.S 标志代表在匹配时为点任意匹配模式，点 . 也可以代表换行符。</p><p>这样我们就获取了发布人，发布时间，发布内容，附加图片以及点赞数。</p><p>在这里注意一下，我们要获取的内容如果是带有图片，直接输出出来比较繁琐，所以这里我们只获取不带图片的段子就好了。</p><p>所以，在这里我们就需要对带图片的段子进行过滤。</p><p>我们可以发现，带有图片的段子会带有类似下面的代码，而不带图片的则没有，所以，我们的正则表达式的item[3]就是获取了下面的内容，如果不带图片，item[3]获取的内容便是空。</p>]]></content>
    
    <summary type="html">
    
      抓取糗事百科上面的段子
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
</feed>
