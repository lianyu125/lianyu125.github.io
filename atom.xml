<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小玉的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.devzou.com/"/>
  <updated>2019-05-16T00:06:56.683Z</updated>
  <id>https://blog.devzou.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ios 证书无法生成p12 文件解决，或者无法生成秘钥问题</title>
    <link href="https://blog.devzou.com/2019/05/12/ios/2019-05-11-ios%20%E8%AF%81%E4%B9%A6%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90p12%20%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%88%96%E8%80%85%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E7%A7%98%E9%92%A5/"/>
    <id>https://blog.devzou.com/2019/05/12/ios/2019-05-11-ios 证书无法生成p12 文件解决，或者无法生成秘钥/</id>
    <published>2019-05-12T01:10:09.000Z</published>
    <updated>2019-05-16T00:06:56.683Z</updated>
    
    <content type="html"><![CDATA[<p><img src="img/ios/ioscer_1_01.png" alt=""></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>发布证书即将过期，按照相应的步骤去生成证书后，在本机电脑安装后没有秘钥(就是看不到钥匙串证书左边的那个三角符号)。如下图证书没有秘钥是无法导出p12文件的。<br><img src="/img/ios/ioscer_1_02.png" alt=""></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>1.证书类型选择错误，左侧有两个分类，选择 登录–证书，找到需要导出的文件，右键点击可导出p12文件，如果在 登录–证书 中找不到需要的证书，而在 系统–证书 中能找到，拖动证书到登录即可解决。<br>2.生成证书时选择的CSR文件为非本机电脑生成的。重新在本机上生成CSR文件，然后再重新生成证书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;img/ios/ioscer_1_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;发布证书即将过期，按照相
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS日志收集设计思路</title>
    <link href="https://blog.devzou.com/2019/05/11/ios/2019-05-11-iOS%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <id>https://blog.devzou.com/2019/05/11/ios/2019-05-11-iOS日志收集设计思路/</id>
    <published>2019-05-11T01:10:09.000Z</published>
    <updated>2019-05-11T01:58:22.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在应用开发中，为了能给用户提供更好的操作体验及更准确的信息展示，我们往往会在应用中添加埋点(收集用户的一些行为信息)，比如用户的操作流程，相关页面的访问次数，设备信息等等。一般app开发前期会集成第三方厂商提供的服务来统计这些数据，当然这样做带来的好处就是不用花费时间来写相关日志收集的功能，后台也不用专门搭建相关的服务，而且第三方提供的工具也比较稳定。这让我们能有更多的时间去开发产品主要业务功能上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在应用开发中，为了能给用户提供更好的操作体验及更准确的信息展示，我们往往会在应用中添加埋点(收集用户的一些行为信息)，比如用户的操作流程，相
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Mach-O 可执行文件</title>
    <link href="https://blog.devzou.com/2019/04/20/ios/2019-05-06-Mach-O%20%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://blog.devzou.com/2019/04/20/ios/2019-05-06-Mach-O 可执行文件/</id>
    <published>2019-04-20T00:10:09.000Z</published>
    <updated>2019-05-15T23:54:17.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mach-O 是 Apple 系统上（包括 MacOS 以及 iOS）的可执行文件格式，类似于 windows 上的 PE 文件以及 linux 上的 ELF 文件。上图左边为官方图，右边为用<a href="https://github.com/gdbinit/MachOView" target="_blank" rel="external">MachOView</a>软件打开的 Mach-O 文件图。可以非常清晰的看到，这种文件格式由文件头（Header）、加载命令（Load Commands）以及具体数据（Segment&amp;Section）组成。下面一一介绍。</p><p><img src="img/ios/macho_01.png" alt=""></p><h2 id="Header-文件头"><a href="#Header-文件头" class="headerlink" title="Header(文件头)"></a>Header(文件头)</h2><p>Header(文件头)的作用是使系统能够快速定位其运行环境以及文件类型等等<br>源码如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The 32-bit mach header appears at the very beginning of the object file for</span></div><div class="line"><span class="comment"> * 32-bit architectures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> mach_header &#123;</div><div class="line">uint32_tmagic;<span class="comment">/* mach magic number identifier */</span></div><div class="line">cpu_type_tcputype;<span class="comment">/* cpu specifier */</span></div><div class="line">cpu_subtype_tcpusubtype;<span class="comment">/* machine specifier */</span></div><div class="line">uint32_tfiletype;<span class="comment">/* type of file */</span></div><div class="line">uint32_tncmds;<span class="comment">/* number of load commands */</span></div><div class="line">uint32_tsizeofcmds;<span class="comment">/* the size of all the load commands */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">/* Constant for the magic field of the mach_header (32-bit architectures) */</span></div><div class="line"><span class="meta">#defineMH_MAGIC0xfeedface/* the mach magic number */</span></div><div class="line"><span class="meta">#define MH_CIGAM0xcefaedfe/* NXSwapInt(MH_MAGIC) */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The 64-bit mach header appears at the very beginning of object files for</span></div><div class="line"><span class="comment"> * 64-bit architectures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> mach_header_64 &#123;</div><div class="line">uint32_tmagic;<span class="comment">/* mach magic number identifier */</span></div><div class="line">cpu_type_tcputype;<span class="comment">/* cpu specifier */</span></div><div class="line">cpu_subtype_tcpusubtype;<span class="comment">/* machine specifier */</span></div><div class="line">uint32_tfiletype;<span class="comment">/* type of file */</span></div><div class="line">uint32_tncmds;<span class="comment">/* number of load commands */</span></div><div class="line">uint32_tsizeofcmds;<span class="comment">/* the size of all the load commands */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">uint32_treserved;<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span></div><div class="line"><span class="meta">#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */</span></div><div class="line"><span class="meta">#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */</span></div></pre></td></tr></table></figure></p><p>分析文件头的 otool 命令为： <code>otool -h 可执行文件</code> ，或者可视化强一点的 <code>otool -hv 可执行文件</code>。</p><h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><p>Load Commands 是跟在 Header 后面的加载命令区，所有 commands 的大小总和即为 Header-&gt;sizeofcmds 字段，共有 Header-&gt;ncmds 条加载命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct load_command &#123;</div><div class="line">    uint32_t cmd;        /* type of load command */</div><div class="line">    uint32_t cmdsize;    /* total size of command in bytes */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>Command 以 LC 开头，不同的加载命令有不同的专有的结构体，cmd 和 cmdsize 是都有的，分别为命令类型（即命令名称），这条命令的长度。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。如果当前 LC_SEGMENT 包含 section，那么 section 的结构体紧跟在 LC_SEGMENT 的结构体之后，所占字节数由 SEGMENT 的 cmdsize 字段给出。</p><table><thead><tr><th style="text-align:center">Cmd</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">LC_SEGMENT/LC_SEGMENT_64</td><td style="text-align:center">将对应的段中的数据加载并映射到进程的内存空间去</td></tr><tr><td style="text-align:center">LC_SYMTAB</td><td style="text-align:center">符号表信息</td></tr><tr><td style="text-align:center">LC_DYSYMTAB</td><td style="text-align:center">动态符号表信息</td></tr><tr><td style="text-align:center">LC_LOAD_DYLINKER</td><td style="text-align:center">启动动态加载连接器/usr/lib/dyld程序</td></tr><tr><td style="text-align:center">LC_UUID</td><td style="text-align:center">唯一的 UUID，标示该二进制文件，128bit</td></tr><tr><td style="text-align:center">LC_VERSION_MIN_IPHONEOS/MACOSX</td><td style="text-align:center">要求的最低系统版本（Xcode中的Deployment Target）</td></tr><tr><td style="text-align:center">LC_MAIN</td><td style="text-align:center">设置程序主线程的入口地址和栈大小</td></tr><tr><td style="text-align:center">LC_ENCRYPTION_INFO</td><td style="text-align:center">加密信息</td></tr><tr><td style="text-align:center">LC_LOAD_DYLIB</td><td style="text-align:center">加载的动态库，包括动态库地址、名称、版本号等</td></tr><tr><td style="text-align:center">LC_FUNCTION_STARTS</td><td style="text-align:center">函数地址起始表</td></tr><tr><td style="text-align:center">LC_CODE_SIGNATURE</td><td style="text-align:center">代码签名信息</td></tr></tbody></table><p>使用命令 <code>otool -l 可执行文件</code> 可以查看加载命令区，使用<code>otool -l 可执行文件|grep cryptid</code> 可以查看是否加密</p><h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><p>Mach-O 文件有多个段（Segment），每个段有不同的功能。然后每个段又分为很多小的 Section。 LC_SEGMENT 意味着这部分文件需要映射到进程的地址空间去。一般有以下段名：<br><strong>__PAGEZERO:</strong>　空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用。<br><strong>__TEXT:</strong>　包含了执行代码以及其他只读数据。该段数据可以 VM_PROT_READ(读)、VM_PROT_EXECUTE(执行)，不能被修改。<br><strong>__DATA:</strong>　程序数据，该段可写 VM_PROT_WRITE/READ/EXECUTE。<br><strong>__LINKEDIT:</strong>　链接器使用的符号以及其他表。</p><p>段的结构体定义为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> segment_command &#123; <span class="comment">/* for 32-bit architectures */</span></div><div class="line">uint32_tcmd;<span class="comment">/* LC_SEGMENT */</span></div><div class="line">uint32_tcmdsize;<span class="comment">/* includes sizeof section structs */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment name */</span></div><div class="line">uint32_tvmaddr;<span class="comment">/* memory address of this segment 段的虚拟内存地址*/</span></div><div class="line">uint32_tvmsize;<span class="comment">/* memory size of this segment  段的虚拟内存大小*/</span></div><div class="line">uint32_tfileoff;<span class="comment">/* file offset of this segment  段在文件中的偏移量*/</span></div><div class="line">uint32_tfilesize;<span class="comment">/* amount to map from the file  段在文件中的大小*/</span></div><div class="line">vm_prot_tmaxprot;<span class="comment">/* maximum VM protection */</span></div><div class="line">vm_prot_tinitprot;<span class="comment">/* initial VM protection */</span></div><div class="line">uint32_tnsects;<span class="comment">/* number of sections in segment */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> segment_command_64 &#123; <span class="comment">/* for 64-bit architectures */</span></div><div class="line">uint32_tcmd;<span class="comment">/* LC_SEGMENT_64 */</span></div><div class="line">uint32_tcmdsize;<span class="comment">/* includes sizeof section_64 structs */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment name */</span></div><div class="line">uint64_tvmaddr;<span class="comment">/* memory address of this segment */</span></div><div class="line">uint64_tvmsize;<span class="comment">/* memory size of this segment */</span></div><div class="line">uint64_tfileoff;<span class="comment">/* file offset of this segment */</span></div><div class="line">uint64_tfilesize;<span class="comment">/* amount to map from the file */</span></div><div class="line">vm_prot_tmaxprot;<span class="comment">/* maximum VM protection */</span></div><div class="line">vm_prot_tinitprot;<span class="comment">/* initial VM protection */</span></div><div class="line">uint32_tnsects;<span class="comment">/* number of sections in segment */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>其中 nsects 字段就是表明该段中有多少个 section。文件映射的起始位置是由 fileoff 给出，映射到地址空间的 vmaddr 处。</p><h2 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h2><p>Section 是具体有用的数据存放的地方。它的结构体跟随在 LC_SEGMENT 结构体之后，LC_SEGMENT 又在 Load Commands 中，但是 segment 的数据内容是跟在 Load Commands 之后的。它的结构体为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></div><div class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></div><div class="line">uint32_taddr;<span class="comment">/* memory address of this section 该节在内存中的起始位置*/</span></div><div class="line">uint32_tsize;<span class="comment">/* size in bytes of this section 该节的大小*/</span></div><div class="line">uint32_toffset;<span class="comment">/* file offset of this section 该节的文件偏移*/</span></div><div class="line">uint32_talign;<span class="comment">/* section alignment (power of 2) 字节大小对齐*/</span></div><div class="line">uint32_treloff;<span class="comment">/* file offset of relocation entries 重定位入口的文件偏移*/</span></div><div class="line">uint32_tnreloc;<span class="comment">/* number of relocation entries 需要重定位的入口数量*/</span></div><div class="line">uint32_tflags;<span class="comment">/* flags (section type and attributes) */</span></div><div class="line">uint32_treserved1;<span class="comment">/* reserved (for offset or index) */</span></div><div class="line">uint32_treserved2;<span class="comment">/* reserved (for count or sizeof) */</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></div><div class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></div><div class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></div><div class="line">uint64_taddr;<span class="comment">/* memory address of this section */</span></div><div class="line">uint64_tsize;<span class="comment">/* size in bytes of this section */</span></div><div class="line">uint32_toffset;<span class="comment">/* file offset of this section */</span></div><div class="line">uint32_talign;<span class="comment">/* section alignment (power of 2) */</span></div><div class="line">uint32_treloff;<span class="comment">/* file offset of relocation entries */</span></div><div class="line">uint32_tnreloc;<span class="comment">/* number of relocation entries */</span></div><div class="line">uint32_tflags;<span class="comment">/* flags (section type and attributes)*/</span></div><div class="line">uint32_treserved1;<span class="comment">/* reserved (for offset or index) */</span></div><div class="line">uint32_treserved2;<span class="comment">/* reserved (for count or sizeof) */</span></div><div class="line">uint32_treserved3;<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>其中 flag 字段分为两个部分，一个是区域类型（section type），一个是区域属性（section attributes）。其中 type 是互斥的，即只能有一个类型，而 attributes 不是互斥的，可以有多个属性。如果段（segment）中的任何一个 section 拥有属性 S_ATTR_DEBUG，那么该段所有的 section 都必须拥有这个属性。具体的flag字段内容以及意义请参考 /usr/include/mach-o/loader.h。</p><p>段名为大写，节名为小写。各节的作用主要有：</p><ul><li>__text:　主程序代码</li><li>__stub_helper:　用于动态链接的存根</li><li>__symbolstub1:　用于动态链接的存根</li><li>__objc_methname:　Objective-C 的方法名</li><li>__objc_classname:　Objective-C 的类名</li><li><p>__cstring:　硬编码的字符串</p></li><li><p>__lazy_symbol:　懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接</p></li><li>_got:　存储引用符号的实际地址，类似于动态符号表</li><li>__nl_symbol_ptr:　非延迟加载节</li><li>__mod_init_func:　初始化的全局函数地址，在 main 之前被调用</li><li>__mod_term_func:　结束函数地址</li><li><p>__cfstring:　Core Foundation 用到的字符串（OC字符串）</p></li><li><p>__objc_clsslist:　Objective-C 的类列表</p></li><li><strong>objc_nlclslist:　Objective-C 的 +load 函数列表，比 </strong>mod_init_func 更早执行</li><li>__objc_const:　Objective-C 的常量</li><li>__data:　初始化的可变的变量</li><li>__bss:　未初始化的静态变量</li></ul><p>查看某段中某节的命令为： <code>otool -s __TEXT __text 可执行文件</code>。</p><h2 id="与-IDA-的对应地址"><a href="#与-IDA-的对应地址" class="headerlink" title="与 IDA 的对应地址"></a>与 IDA 的对应地址</h2><p>如果用 MachOView 来查看的话，界面左上角有一个 RAW、RVA 的选项。RAW 就是指该字节相对于文件开始部分的绝对偏移，文件头部的地址是从0x000开始的。RVA 是相对于某个基地址的偏移，也就是整体的绝对偏移值再加上某个基地址，文件头部的地址是从某个值（基地址）开始的。</p><p>这个所谓的基地址其实是 LC_SEGMENT_64(_PAGEZERO) 中的 VM_Size 字段的值，因为留出这段空白页面就是为了捕获程序的空指针，以及考虑到页面对齐。IDA 中就是使用的 RVA 地址。这个地址在 armv7 中是0x4000，arm64 中是0x10000 0000。</p><p>Section(<strong>TEXT,</strong>text ) 所在的 RVA 地址，对应的就是 IDA 解析的函数开始地址。 IDA 解析的 Mach-O 文件中的函数都位于 Section( <strong>TEXT) 段，然后还会接着解析 Section( </strong>DATA) 段，即 IDA 中的数据区。</p><p>LC_MAIN 加载命令中的 Entry Offset 字段 + 基地址（RVA 选项下的文件头部地址） = IDA 中左侧函数 _main 的地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Mach-O 是 Apple 系统上（包括 MacOS 以及 iOS）的可执行文件格式，类似于 windows 上的 PE 文件以及 lin
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能调试之instruments</title>
    <link href="https://blog.devzou.com/2019/03/20/ios/2019-05-06-iOS%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E4%B9%8Binstruments/"/>
    <id>https://blog.devzou.com/2019/03/20/ios/2019-05-06-iOS性能调试之instruments/</id>
    <published>2019-03-20T00:10:09.000Z</published>
    <updated>2019-05-13T02:42:27.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于instruments"><a href="#关于instruments" class="headerlink" title="关于instruments"></a>关于instruments</h2><p>Instruments是功能强大且灵活的性能分析和测试工具，是Xcode工具集的一部分,它旨在帮助您分析您的iOS，watchOS，tvOS和macOS应用程序，流程和设备，以便更好地了解和优化应用程序的行为和性能。从应用程序开发过程开始，将仪器集成到您的工作流程中，可以帮助您在开发周期的早期发现问题，从而节省您的时间。<br>    在Instruments中，您使用专用工具（称为工具）来跟踪应用程序，流程和设备的不同方面。仪器在配置文件时收集数据，并将结果详细呈现给您以供分析。<br>    与其他性能和调试工具不同，Instruments允许您收集广泛不同类型的数据并并排查看。这样可以更轻松地识别可能被忽视的趋势。例如，您的应用可能会因多个开放式网络连接而出现大量内存增长。通过一起使用分配和连接工具，您可以识别未关闭的连接，从而实现快速的内存增长。</p><p>使用 Instruments 你可以做下面这些事：</p><ol><li>检查一个或多个应用或进程的行为。</li><li>检查设备相关的功能，比如：Wi-Fi、蓝牙等。</li><li>在真机或模拟器上进行性能测试。</li><li>创建自定义的 DTrace 来分析系统以及应用的各种行为。</li><li>跟踪源码中的问题。</li><li>对 App 进行性能分析。</li><li>查找 App 中的内存问题，比如：内存泄露(Leaked memory)、废弃内存(Abandoned memory)、僵尸(zombies)等。</li><li>给出程序优化的建议。</li><li>进行系统级别的问题定位。</li><li>通过脚本记录一个用户行为序列，从而可以通过运行脚本对你的 iOS 应用进行可重复多次的自动化测试。</li><li>保存测试配置模板以供复用。<br>虽然 Instruments 是 Xcode 的一个工具集，但是它是以一个独立的 App 的形式存在的，你可以在 Xcode -&gt; Open Developer Tool -&gt; Instruments 中打开它。<h2 id="内存性能"><a href="#内存性能" class="headerlink" title="内存性能"></a>内存性能</h2>Instruments 可以帮我们了解到应用程序使用内存的几个方面：</li></ol><ul><li><strong>全局内存使用情况(Overall Memory Use)</strong>: 从全局的角度监测应用程序的内存使用情况，捕捉非预期的或大幅度的内存增长。</li><li><strong>内存泄露(Leaked memory)</strong>: 未被你的程序引用，同时也不能被使用或释放的内存。</li><li><strong>废弃内存(Abandoned memory)</strong>: 被你的程序引用，但是没什么卵用的内存。</li><li><strong>僵尸对象(Zombies)</strong>: 僵尸对象指的是对应的内存已经被释放并且不再会使用到，但是你的程序却在某处依然有指向它的引用。在 iOS 中有一个 NSZombie 机制，这个是为了内存调试的目的而设计的一种机制。在这个机制下，当你 NSZombieEnabled 为 YES 时，当一个对应的引用计数减为 0 时，这个对象不会被释放，当这个对象再收到任何消息时，它会记录一条 warning，而不是直接崩溃，以方便我们进行程序调试。</li></ul><p>这里我们介绍下查找内存泄露的过程：<br>1.在products-&gt;profile中启动instruments面板<br><img src="/img/ios/performance_1_01.png" alt=""><br>2.选中Leaks模板<br><img src="/img/ios/performance_1_02.png" alt=""></p><ol><li>选择正确的设备和应用程序，点击红色按钮运行应用程序<br><img src="/img/ios/performance_1_03.png" alt=""><br>4.我们可以看到如下界面<br><img src="/img/ios/performance_1_04.png" alt=""></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://help.apple.com/instruments/mac/current/" target="_blank" rel="external"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于instruments&quot;&gt;&lt;a href=&quot;#关于instruments&quot; class=&quot;headerlink&quot; title=&quot;关于instruments&quot;&gt;&lt;/a&gt;关于instruments&lt;/h2&gt;&lt;p&gt;Instruments是功能强大且灵活的性能分析和测
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>webpack4入门教程</title>
    <link href="https://blog.devzou.com/2019/03/06/web%E5%89%8D%E7%AB%AF/2018-04-01-webpack4%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.devzou.com/2019/03/06/web前端/2018-04-01-webpack4入门教程/</id>
    <published>2019-03-06T13:04:24.000Z</published>
    <updated>2019-04-17T13:21:54.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。<br><a id="more"></a></p><h2 id="为什要使用WebPack"><a href="#为什要使用WebPack" class="headerlink" title="为什要使用WebPack"></a>为什要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p><p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常反锁的，这就为WebPack类的工具的出现提供了需求。</p><h2 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h2><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。</p><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。<br>Grunt和Gulp的工作流程<br><img src="/img/webpack_1_03.png" alt=""><br>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。<br><img src="/img/webpack_1_01.png" alt=""><br>Webpack工作方式</p><p>Webpack工作方式<br>如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。</p><p>开始使用Webpack</p><p>初步了解了Webpack工作方式后，我们一步步的开始学习使用Webpack。</p><h2 id="全局安装webpack及webpack-cli"><a href="#全局安装webpack及webpack-cli" class="headerlink" title="全局安装webpack及webpack-cli"></a>全局安装webpack及webpack-cli</h2><p>安装webpack</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g webpack</div></pre></td></tr></table></figure><p>安装webpack-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g webpack-cli</div></pre></td></tr></table></figure><h2 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h2><p>在桌面新建一个文件夹用于存放工程文件,文件夹名称为mywebpack。</p><p>在mywebpack文件夹中创建一个package.json文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init -y</div></pre></td></tr></table></figure><p>在mywebpack文件夹下创建index.html文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>在mywebpack文件夹创建src文件夹,在src文件夹下创建index.js,代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.write(<span class="string">"hello webpack"</span>);</div></pre></td></tr></table></figure></p><p>使用webpack进行打包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --mode development</div></pre></td></tr></table></figure></p><p>执行后结果如下<br><img src="/img/webpack_1_04.png" alt=""><br>【重要】webpack4.x的打包已经不能用webpack 文件a 文件b的方式，而是直接运行webpack –mode development或者webpack –mode production，这样便会默认进行打包，入口文件是’./src/index.js’，输出路径是’./dist/main.js’，其中src目录即index.js文件需要手动创建，而dist目录及main.js会自动生成。</p><p>因此我们不再按webpack 文件a 文件b的方式运行webpack指令，而是直接运行</p><p>　　webpack –mode development<br>或<br>　　webpack –mode production</p><p>这样便能够实现将’./src/index.js’打包成’./dist/main.js’。</p><p>不过每次都要输入这个命令，非常麻烦，我们在package.json中scripts中加入两个成员：</p><p>　　“dev”:”webpack –mode development”,</p><p>　　“build”:”webpack –mode production”</p><p>执行webpack –mode development<br>执行npm run dev，相当于执行webpack –mode development</p><p>执行完毕后打开index.html效果如下<br><img src="/img/webpack_1_02.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。
    
    </summary>
    
      <category term="前端" scheme="https://blog.devzou.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://blog.devzou.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Clang常用命令介绍</title>
    <link href="https://blog.devzou.com/2019/02/20/ios/2019-04-26-clang%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.devzou.com/2019/02/20/ios/2019-04-26-clang常用命令介绍/</id>
    <published>2019-02-20T00:10:09.000Z</published>
    <updated>2019-04-27T09:10:11.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。学习Clang有助于我们对Objective-C编译过程的理解</p><h2 id="Clang常用命令介绍"><a href="#Clang常用命令介绍" class="headerlink" title="Clang常用命令介绍"></a>Clang常用命令介绍</h2><h3 id="clang-ccc-print-phases-main-m"><a href="#clang-ccc-print-phases-main-m" class="headerlink" title="clang -ccc-print-phases main.m"></a>clang -ccc-print-phases main.m</h3><p>功能：查看编译的步骤<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: input, &quot;main.m&quot;, objective-c</div><div class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</div><div class="line">2: compiler, &#123;1&#125;, ir</div><div class="line">3: backend, &#123;2&#125;, assembler</div><div class="line">4: assembler, &#123;3&#125;, object</div><div class="line">5: linker, &#123;4&#125;, image</div><div class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image</div></pre></td></tr></table></figure></p><h3 id="clang-rewrite-objc-main-m"><a href="#clang-rewrite-objc-main-m" class="headerlink" title="clang -rewrite-objc main.m"></a>clang -rewrite-objc main.m</h3><p>功能：查看编译结果<br>输出结果：main.cpp文件</p><h3 id="clang-main-m-o-main"><a href="#clang-main-m-o-main" class="headerlink" title="clang -### main.m -o main"></a>clang -### main.m -o main</h3><p>功能：查看操作内部命令<br>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Apple LLVM version 10.0.1 (clang-1001.0.46.3)</div><div class="line">Target: x86_64-apple-darwin18.2.0</div><div class="line">Thread model: posix</div><div class="line">InstalledDir: /Library/Developer/CommandLineTools/usr/bin</div><div class="line"> &quot;/Library/Developer/CommandLineTools/usr/bin/clang&quot; &quot;-cc1&quot; &quot;-triple&quot; &quot;x86_64-apple-macosx10.14.0&quot; &quot;-Wdeprecated-objc-isa-usage&quot; &quot;-Werror=deprecated-objc-isa-usage&quot; &quot;-emit-obj&quot; &quot;-mrelax-all&quot; &quot;-disable-free&quot; &quot;-disable-llvm-verifier&quot; &quot;-discard-value-names&quot; &quot;-main-file-name&quot; &quot;main.m&quot; &quot;-mrelocation-model&quot; &quot;pic&quot; &quot;-pic-level&quot; &quot;2&quot; &quot;-mthread-model&quot; &quot;posix&quot; &quot;-mdisable-fp-elim&quot; &quot;-fno-strict-return&quot; &quot;-masm-verbose&quot; &quot;-munwind-tables&quot; &quot;-target-sdk-version=10.14&quot; &quot;-target-cpu&quot; &quot;penryn&quot; &quot;-dwarf-column-info&quot; &quot;-debugger-tuning=lldb&quot; &quot;-target-linker-version&quot; &quot;450.3&quot; &quot;-resource-dir&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/clang/10.0.1&quot; &quot;-isysroot&quot; &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk&quot; &quot;-I/usr/local/include&quot; &quot;-Wno-atomic-implicit-seq-cst&quot; &quot;-Wno-framework-include-private-from-public&quot; &quot;-Wno-atimport-in-framework-header&quot; &quot;-Wno-quoted-include-in-framework-header&quot; &quot;-fdebug-compilation-dir&quot; &quot;/Users/ZLY/Desktop&quot; &quot;-ferror-limit&quot; &quot;19&quot; &quot;-fmessage-length&quot; &quot;238&quot; &quot;-stack-protector&quot; &quot;1&quot; &quot;-fblocks&quot; &quot;-fencode-extended-block-signature&quot; &quot;-fregister-global-dtors-with-atexit&quot; &quot;-fobjc-runtime=macosx-10.14.0&quot; &quot;-fobjc-exceptions&quot; &quot;-fexceptions&quot; &quot;-fmax-type-align=16&quot; &quot;-fdiagnostics-show-option&quot; &quot;-fcolor-diagnostics&quot; &quot;-o&quot; &quot;/var/folders/kj/svm6s3rn6kdcvmbhds_grhvm0000gp/T/main-1301a5.o&quot; &quot;-x&quot; &quot;objective-c&quot; &quot;main.m&quot;</div><div class="line"> &quot;/Library/Developer/CommandLineTools/usr/bin/ld&quot; &quot;-demangle&quot; &quot;-lto_library&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/libLTO.dylib&quot; &quot;-no_deduplicate&quot; &quot;-dynamic&quot; &quot;-arch&quot; &quot;x86_64&quot; &quot;-macosx_version_min&quot; &quot;10.14.0&quot; &quot;-syslibroot&quot; &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk&quot; &quot;-o&quot; &quot;main&quot; &quot;/var/folders/kj/svm6s3rn6kdcvmbhds_grhvm0000gp/T/main-1301a5.o&quot; &quot;-L/usr/local/lib&quot; &quot;-lSystem&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/clang/10.0.1/lib/darwin/libclang_rt.osx.a&quot;</div></pre></td></tr></table></figure></p><h2 id="clang基本语法介绍"><a href="#clang基本语法介绍" class="headerlink" title="clang基本语法介绍"></a>clang基本语法介绍</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>-fmodules</td><td>允许modules的语言特性</td></tr><tr><td>-fsyntax-only</td><td>防止编译器生成代码,只是语法级别的说明和修改</td></tr><tr><td>-Xclang <arg></arg></td><td>向clang编译器传递参数</td></tr><tr><td>-dump-tokens</td><td>运行预处理器,拆分内部代码段为各种token</td></tr><tr><td>-ast-dump</td><td>构建抽象语法树AST,然后对其进行拆解和调试</td></tr><tr><td>-S</td><td>只运行预处理和编译步骤</td></tr><tr><td>-fobjc-arc</td><td>为OC对象生成retain和release的调用</td></tr><tr><td>-emit-llvm</td><td>使用LLVM描述汇编和对象文件</td></tr><tr><td>-o <file></file></td><td>输出到目标文件</td></tr><tr><td>-c</td><td>只运行预处理,编译和汇编步骤</td></tr></tbody></table><h2 id="代码编译的执行步骤拆解"><a href="#代码编译的执行步骤拆解" class="headerlink" title="代码编译的执行步骤拆解"></a>代码编译的执行步骤拆解</h2><p>下面我们对iOS代码编译的步骤进行一个简单的拆解,看看内部是如何实现的.<br>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p><p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p><p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p><p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="external">Writing an LLVM Pass — LLVM 5 documentation</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p><p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。<br>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure></p><p>生成汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure></p><p>生成目标文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure></p><p>生成可执行文件，这样就能够执行看到输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">clang main.o -o main</div><div class="line">执行</div><div class="line">./main</div><div class="line">输出</div><div class="line">starming rank 14</div></pre></td></tr></table></figure></p><p>下面是完整步骤：</p><ol><li>编译信息写入辅助文件，创建文件架构 .app 文件</li><li>处理文件打包信息</li><li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li><li>编译.m文件，使用 CompileC 和 clang 命令</li><li>链接需要的 Framework</li><li>编译 xib</li><li>拷贝 xib ，资源文件</li><li>编译 ImageAssets</li><li>处理 info.plist</li><li>执行 CocoaPod 脚本</li><li>拷贝标准库</li><li>创建 .app 文件和签名</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。学习Clang有助于我们对Objective-C编译过程的理
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Python高级编程之爬虫Scrapy框架安装配置</title>
    <link href="https://blog.devzou.com/2018/11/28/python/2017-03-18-python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABScrapy%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.devzou.com/2018/11/28/python/2017-03-18-python高级编程之爬虫Scrapy框架安装配置/</id>
    <published>2018-11-28T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:35.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac下安装Scrapy框架"><a href="#Mac下安装Scrapy框架" class="headerlink" title="Mac下安装Scrapy框架"></a>Mac下安装Scrapy框架</h2><p>刚刚试了下可以，可以简化为下面三个步骤<br>一、删除Mac自带的Python<br>sudo rm -rf /usr/bin/python<br>二、homebrew安装最新的Python<br>brew install python<br>创建一个软链接<br>sudo ln -s /usr/local/bin/python /usr/bin/python<br>三、使用pip安装scrapy<br>使用homebrew安装完python后会自动安装好包管理工具pip，所以执行下面安装命令<br>pip install scrapy<br>安装完成后如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">machaismile$ scrapy</div><div class="line">Scrapy 0.22.2 - no active project</div><div class="line"></div><div class="line">Usage:</div><div class="line">  scrapy &lt;command&gt; [options] [args]</div><div class="line"></div><div class="line">Available commands:</div><div class="line">  bench         Run quick benchmark test</div><div class="line">  fetch         Fetch a URL using the Scrapy downloader</div><div class="line">  runspider     Run a self-contained spider (without creating a project)</div><div class="line">  settings      Get settings values</div><div class="line">  shell         Interactive scraping console</div><div class="line">  startproject  Create new project</div><div class="line">  version       Print Scrapy version</div><div class="line">  view          Open URL in browser, as seen by Scrapy</div><div class="line"></div><div class="line">  [ more ]      More commands available when run from project directory</div><div class="line"></div><div class="line">Use &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command</div></pre></td></tr></table></figure></p><p>出现 zsh: command not found: scrapy 执行</p><p> ln -s  /Library/Frameworks/Python.framework/Versions/2.7/bin/scrapy /usr/local/bin/scrapy</p>]]></content>
    
    <summary type="html">
    
      初级的爬虫我们利用urllib和urllib2库以及正则表达式就可以完成了，不过还有更加强大的工具，爬虫框架Scrapy
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级教程之爬虫urllib基本使用</title>
    <link href="https://blog.devzou.com/2018/11/17/python/2017-03-17-python%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABurllib%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.devzou.com/2018/11/17/python/2017-03-17-python高级教程之爬虫urllib基本使用/</id>
    <published>2018-11-17T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:10.747Z</updated>
    
    <content type="html"><![CDATA[<p>如下程序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure></p><p>把它保存成 demo.py，进入该文件的目录，执行命令<code>python demo.py</code>查看运行结果，感受一下。</p><h2 id="分析扒网页的方法"><a href="#分析扒网页的方法" class="headerlink" title="分析扒网页的方法"></a>分析扒网页的方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</div></pre></td></tr></table></figure><p>首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，当然你也可以把HTTP换做FTP,FILE,HTTPS 等等，只是代表了一种访问控制协议，urlopen一般接受三个参数，它的参数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">urlopen(url, data, timeout)</div></pre></td></tr></table></figure></p><p>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。<br>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT<br>第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><p>response对象有一个read方法，可以返回获取到的网页内容。</p><h2 id="构造Request"><a href="#构造Request" class="headerlink" title="构造Request"></a>构造Request</h2><p>其实上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。比如上面的两行代码，我们可以这么改写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">request = urllib2.Request(<span class="string">"http://www.baidu.com"</span>)</div><div class="line">response = urllib2.urlopen(request)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure></p><p>运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</p><h2 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h2><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。最常见的情况是什么？对了，就是登录注册的时候呀。</p><p>把数据用户名和密码传送到一个URL，然后你得到服务器处理之后的响应，这个该怎么办？下面让我来为小伙伴们揭晓吧！</p><p>数据传送分为POST和GET两种方式，两种方式有什么区别呢？</p><p>最重要的区别是GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。</p><p>POST方式：</p><p>上面我们说了data参数是干嘛的？对了，它就是用在这里的，我们传送的数据就是这个参数data，下面演示一下POST方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">values = &#123;<span class="string">"username"</span>:<span class="string">"1315751082@qq.com"</span>,<span class="string">"password"</span>:<span class="string">"XXXX"</span>&#125;</div><div class="line">data = urllib.urlencode(values) </div><div class="line">url = <span class="string">"https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"</span></div><div class="line">request = urllib2.Request(url,data)</div><div class="line">response = urllib2.urlopen(request)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><p>【抓取糗事百科页面的数据例子】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">import</span> re</div><div class="line"> </div><div class="line">page = <span class="number">1</span></div><div class="line">url = <span class="string">'https://www.qiushibaike.com/text/'</span> + str(page)</div><div class="line">user_agent = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6)'</span></div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    request = urllib2.Request(url,headers = headers)</div><div class="line">    response = urllib2.urlopen(request)</div><div class="line"><span class="comment">#    print response.read()</span></div><div class="line">    content = response.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">    pattern = re.compile(<span class="string">'&lt;div.*?author.*?&lt;a.*?&lt;img.*?&gt;(.*?)&lt;/a&gt;.*?&lt;div.*?'</span>+</div><div class="line">                         <span class="string">'content"&gt;(.*?)&lt;/div&gt;(.*?)&lt;div class="stats.*?class="number"&gt;(.*?)&lt;/i&gt;'</span>,re.S)</div><div class="line">    items = re.findall(pattern,content)</div><div class="line"><span class="comment">#    print items</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">        <span class="keyword">print</span> item</div><div class="line"><span class="comment">#        haveImg = re.search("img",item[3])</span></div><div class="line"><span class="comment">#        if not haveImg:</span></div><div class="line"><span class="comment">#           print item[0],item[1],item[2],item[4]</span></div><div class="line"><span class="keyword">except</span> urllib2.URLError, e:</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"code"</span>):</div><div class="line">        <span class="keyword">print</span> e.code</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"reason"</span>):</div><div class="line">        <span class="keyword">print</span> e.reason</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      怎样扒网页呢？其实就是根据URL来获取它的网页信息，虽然我们在浏览器中看到的是一幅幅优美的画面，但是其实是由浏览器解释才呈现出来的，实质它是一段HTML代码，加 JS、CSS，如果把网页比作一个人，那么HTML便是他的骨架，JS便是他的肌肉，CSS便是它的衣服。所以最重要的部分是存在于HTML中的，下面我们就写个例子来扒一个网页下来。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级教程之爬虫urllib库高级使用</title>
    <link href="https://blog.devzou.com/2018/11/17/python/2017-03-17.-Python%20%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABurllib%E5%BA%93%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.devzou.com/2018/11/17/python/2017-03-17.-Python 高级教程之爬虫urllib库高级使用/</id>
    <published>2018-11-17T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:00.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设置Headers"><a href="#1-设置Headers" class="headerlink" title="1.设置Headers"></a>1.设置Headers</h2><p>有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，我们需要设置一些Headers 的属性。</p><p>首先，打开我们的浏览器，调试浏览器F12，我用的是Chrome，打开网络监听，示意如下，比如知乎，点登录之后，我们会发现登陆之后界面都变化了，出现一个新的界面，实质上这个页面包含了许许多多的内容，这些内容也不是一次性就加载完成的，实质上是执行了好多次请求，一般是首先请求HTML文件，然后加载JS，CSS 等等，经过多次请求之后，网页的骨架和肌肉全了，整个网页的效果也就出来了。<br><img src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/02/2015-02-13-013155-%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-e1423762350360.png" alt=""><br>拆分这些请求，我们只看一第一个请求，你可以看到，有个Request URL，还有headers，下面便是response，图片显示得不全，小伙伴们可以亲身实验一下。那么这个头中包含了许许多多是信息，有文件编码啦，压缩方式啦，请求的agent啦等等。<br>其中，agent就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在headers中设置agent,例如下面的例子，这个例子只是说明了怎样设置的headers，小伙伴们看一下设置格式就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib  </div><div class="line"><span class="keyword">import</span> urllib2  </div><div class="line"></div><div class="line">url = <span class="string">'http://www.server.com/login'</span></div><div class="line">user_agent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>  </div><div class="line">values = &#123;<span class="string">'username'</span> : <span class="string">'cqc'</span>,  <span class="string">'password'</span> : <span class="string">'XXXX'</span> &#125;  </div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;  </div><div class="line">data = urllib.urlencode(values)  </div><div class="line">request = urllib2.Request(url, data, headers)  </div><div class="line">response = urllib2.urlopen(request)  </div><div class="line">page = response.read()</div></pre></td></tr></table></figure><p>另外，我们还有对付”反盗链”的方式，对付防盗链，服务器会识别headers中的referer是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在headers中加入referer</p><p>例如我们可以构建下面的headers<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>  ,</div><div class="line">                        <span class="string">'Referer'</span>:<span class="string">'http://www.zhihu.com/articles'</span> &#125;</div></pre></td></tr></table></figure></p><p>同上面的方法，在传送请求时把headers传入Request参数里，这样就能应付防盗链了。</p><p>另外headers的一些属性，下面的需要特别注意一下：</p><blockquote><p>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求<br>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。<br>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用<br>application/json ： 在 JSON RPC 调用时使用<br>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用<br>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p><h2 id="Proxy（代理）的设置"><a href="#Proxy（代理）的设置" class="headerlink" title="Proxy（代理）的设置"></a>Proxy（代理）的设置</h2></blockquote><p>urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！</p><p>下面一段代码说明了代理的设置用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">enable_proxy = <span class="keyword">True</span></div><div class="line">proxy_handler = urllib2.ProxyHandler(&#123;<span class="string">"http"</span> : <span class="string">'http://some-proxy.com:8080'</span>&#125;)</div><div class="line">null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)</div><div class="line"><span class="keyword">if</span> enable_proxy:</div><div class="line">    opener = urllib2.build_opener(proxy_handler)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    opener = urllib2.build_opener(null_proxy_handler)</div><div class="line">urllib2.install_opener(opener)</div></pre></td></tr></table></figure></p><h2 id="Timeout-设置"><a href="#Timeout-设置" class="headerlink" title="Timeout 设置"></a>Timeout 设置</h2><p>上一节已经说过urlopen方法了，第三个参数就是timeout的设置，可以设置等待多久超时，为了解决一些网站实在响应过慢而造成的影响。</p><p>例如下面的代码,如果第二个参数data为空那么要特别指定是timeout是多少，写明形参，如果data已经传入，则不必声明。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com'</span>, timeout=<span class="number">10</span>)</div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com'</span>,data, <span class="number">10</span>)</div></pre></td></tr></table></figure><h2 id="使用-HTTP-的-PUT-和-DELETE-方法"><a href="#使用-HTTP-的-PUT-和-DELETE-方法" class="headerlink" title="使用 HTTP 的 PUT 和 DELETE 方法"></a>使用 HTTP 的 PUT 和 DELETE 方法</h2><p>http协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求</p><blockquote><p>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。<br>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。<br> 如果要使用 HTTP PUT 和 DELETE ，只能使用比较低层的 httplib 库。虽然如此，我们还是能通过下面的方式，使 urllib2 能够发出 PUT 或DELETE 的请求，不过用的次数的确是少，在这里提一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">request = urllib2.Request(uri, data=data)</div><div class="line">request.get_method = <span class="keyword">lambda</span>: <span class="string">'PUT'</span> <span class="comment"># or 'DELETE'</span></div><div class="line">response = urllib2.urlopen(request)</div></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      urllib库的高级使用
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫实战之爬取糗事百科段子</title>
    <link href="https://blog.devzou.com/2018/10/16/python/2017-03-16-Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%E6%AE%B5%E5%AD%90/"/>
    <id>https://blog.devzou.com/2018/10/16/python/2017-03-16-Python爬虫实战之爬取糗事百科段子/</id>
    <published>2018-10-16T00:10:09.000Z</published>
    <updated>2019-04-24T06:59:24.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="确定URL并抓取页面代码"><a href="#确定URL并抓取页面代码" class="headerlink" title="确定URL并抓取页面代码"></a>确定URL并抓取页面代码</h2><p>首先我们确定好页面的URL是 <a href="http://www.qiushibaike.com/hot/page/1，其中最后一个数字1代表页数，我们可以传入不同的值来获得某一页的段子内容。" target="_blank" rel="external">http://www.qiushibaike.com/hot/page/1，其中最后一个数字1代表页数，我们可以传入不同的值来获得某一页的段子内容。</a></p><p>我们初步构建如下的代码来打印页面代码内容试试看，先构造最基本的页面抓取方式，看看会不会成功<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">page = <span class="number">1</span></div><div class="line">url = <span class="string">'http://www.qiushibaike.com/hot/page/'</span> + str(page)</div><div class="line">user_agent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span></div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    request = urllib2.Request(url,headers = headers)</div><div class="line">    response = urllib2.urlopen(request)</div><div class="line">    <span class="keyword">print</span> response.read()</div><div class="line"><span class="keyword">except</span> urllib2.URLError, e:</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"code"</span>):</div><div class="line">        <span class="keyword">print</span> e.code</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"reason"</span>):</div><div class="line">        <span class="keyword">print</span> e.reason</div></pre></td></tr></table></figure></p><h2 id="提取某一页的所有段子"><a href="#提取某一页的所有段子" class="headerlink" title="提取某一页的所有段子"></a>提取某一页的所有段子</h2><p>好，获取了HTML代码之后，我们开始分析怎样获取某一页的所有段子。</p><p>首先我们审查元素看一下，按浏览器的F12，截图如下</p><p>我们可以看到，每一个段子都是<div class="”article" block="" untagged="" mb15″="" id="”…”">…</div>包裹的内容。</p><p>现在我们想获取发布人，发布日期，段子内容，以及点赞的个数。不过另外注意的是，段子有些是带图片的，如果我们想在控制台显示图片是不现实的，所以我们直接把带有图片的段子给它剔除掉，只保存仅含文本的段子。</p><p>所以我们加入如下正则表达式来匹配一下，用到的方法是 re.findall 是找寻所有匹配的内容。方法的用法详情可以看前面说的正则表达式的介绍。</p><p>好，我们的正则表达式匹配语句书写如下，在原来的基础上追加如下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">content = response.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">pattern = re.compile(<span class="string">'&lt;div.*?author"&gt;.*?&lt;a.*?&lt;img.*?&gt;(.*?)&lt;/a&gt;.*?&lt;div.*?'</span>+</div><div class="line">                         <span class="string">'content"&gt;(.*?)&lt;!--(.*?)--&gt;.*?&lt;/div&gt;(.*?)&lt;div class="stats.*?class="number"&gt;(.*?)&lt;/i&gt;'</span>,re.S)</div><div class="line">items = re.findall(pattern,content)</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">    <span class="keyword">print</span> item[<span class="number">0</span>],item[<span class="number">1</span>],item[<span class="number">2</span>],item[<span class="number">3</span>],item[<span class="number">4</span>]</div></pre></td></tr></table></figure></p><p>现在正则表达式在这里稍作说明</p><p>1）.<em>? 是一个固定的搭配，.和</em>代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配，以后我们还会大量用到 .*? 的搭配。</p><p>2）(.<em>?)代表一个分组，在这个正则表达式中我们匹配了五个分组，在后面的遍历item中，item[0]就代表第一个(.</em>?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。</p><p>3）re.S 标志代表在匹配时为点任意匹配模式，点 . 也可以代表换行符。</p><p>这样我们就获取了发布人，发布时间，发布内容，附加图片以及点赞数。</p><p>在这里注意一下，我们要获取的内容如果是带有图片，直接输出出来比较繁琐，所以这里我们只获取不带图片的段子就好了。</p><p>所以，在这里我们就需要对带图片的段子进行过滤。</p><p>我们可以发现，带有图片的段子会带有类似下面的代码，而不带图片的则没有，所以，我们的正则表达式的item[3]就是获取了下面的内容，如果不带图片，item[3]获取的内容便是空。</p>]]></content>
    
    <summary type="html">
    
      抓取糗事百科上面的段子
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python高级编程之正则表达式</title>
    <link href="https://blog.devzou.com/2018/09/18/python/2017-03-18-python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blog.devzou.com/2018/09/18/python/2017-03-18-python高级编程之正则表达式/</id>
    <published>2018-09-18T00:10:09.000Z</published>
    <updated>2019-04-24T06:59:35.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-Re模块"><a href="#Python-Re模块" class="headerlink" title="Python Re模块"></a>Python Re模块</h2><p>Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#返回pattern对象</span></div><div class="line">re.compile(string[,flag])  </div><div class="line"><span class="comment">#以下为匹配所用函数</span></div><div class="line">re.match(pattern, string[, flags])</div><div class="line">re.search(pattern, string[, flags])</div><div class="line">re.split(pattern, string[, maxsplit])</div><div class="line">re.findall(pattern, string[, flags])</div><div class="line">re.finditer(pattern, string[, flags])</div><div class="line">re.sub(pattern, repl, string[, count])</div><div class="line">re.subn(pattern, repl, string[, count])</div></pre></td></tr></table></figure></p><p>在介绍这几个方法之前，我们先来介绍一下pattern的概念，pattern可以理解为一个匹配模式，那么我们怎么获得这个匹配模式呢？很简单，我们需要利用re.compile方法就可以。例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pattern = re.compile(<span class="string">r'hello'</span>)</div></pre></td></tr></table></figure></p><p>在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配。</p><p>另外大家可能注意到了另一个参数 flags，在这里解释一下这个参数的含义：</p><p>参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。</p><p>可选值有：<br> • re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）<br> • re.M(全拼：MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）<br> • re.S(全拼：DOTALL): 点任意匹配模式，改变’.’的行为<br> • re.L(全拼：LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定<br> • re.U(全拼：UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性<br> • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。<br><strong> re.match(pattern, string[, flags])</strong><br>这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败，否则匹配pattern成功，同时匹配终止，不再对string向后匹配。下面我们通过一个例子理解一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">__author__ = <span class="string">'CQC'</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment">#导入re模块</span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment"># 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串”</span></div><div class="line">pattern = re.compile(<span class="string">r'hello'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 使用re.match匹配文本，获得匹配结果，无法匹配时将返回None</span></div><div class="line">result1 = re.match(pattern,<span class="string">'hello'</span>)</div><div class="line">result2 = re.match(pattern,<span class="string">'helloo CQC!'</span>)</div><div class="line">result3 = re.match(pattern,<span class="string">'helo CQC!'</span>)</div><div class="line">result4 = re.match(pattern,<span class="string">'hello CQC!'</span>)</div><div class="line"></div><div class="line"><span class="comment">#如果1匹配成功</span></div><div class="line"><span class="keyword">if</span> result1:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> result1.group()</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'1匹配失败！'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如果2匹配成功</span></div><div class="line"><span class="keyword">if</span> result2:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> result2.group()</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'2匹配失败！'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如果3匹配成功</span></div><div class="line"><span class="keyword">if</span> result3:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> result3.group()</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'3匹配失败！'</span></div><div class="line"></div><div class="line"><span class="comment">#如果4匹配成功</span></div><div class="line"><span class="keyword">if</span> result4:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> result4.group()</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'4匹配失败！'</span></div></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hello</div><div class="line">hello</div><div class="line">3匹配失败！</div><div class="line">hello</div></pre></td></tr></table></figure></p><p>匹配分析<br>1.第一个匹配，pattern正则表达式为’hello’，我们匹配的目标字符串string也为hello，从头至尾完全匹配，匹配成功。<br>2.第二个匹配，string为helloo CQC，从string头开始匹配pattern完全可以匹配，pattern匹配结束，同时匹配终止，后面的o CQC不再匹配，返回匹配成功的信息。<br>3.第三个匹配，string为helo CQC，从string头开始匹配pattern，发现到 ‘o’ 时无法完成匹配，匹配终止，返回None<br>4.第四个匹配，同第二个匹配原理，即使遇到了空格符也不会受影响。<br>我们还看到最后打印出了result.group()，这个是什么意思呢？下面我们说一下关于match对象的的属性和方法<br>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。<br><strong>re.search(pattern, string[, flags])</strong><br>search方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。同样，search方法的返回对象同样match()返回对象的方法和属性。我们用一个例子感受一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#导入re模块</span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment"># 将正则表达式编译成Pattern对象</span></div><div class="line">pattern = re.compile(<span class="string">r'world'</span>)</div><div class="line"><span class="comment"># 使用search()查找匹配的子串，不存在能匹配的子串时将返回None</span></div><div class="line"><span class="comment"># 这个例子中使用match()无法成功匹配</span></div><div class="line">match = re.search(pattern,<span class="string">'hello world!'</span>)</div><div class="line"><span class="keyword">if</span> match:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> match.group()</div><div class="line"><span class="comment">### 输出 ###</span></div><div class="line"><span class="comment"># world</span></div></pre></td></tr></table></figure></p><p><strong>re.split(pattern, string[, maxsplit])</strong><br>按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。我们通过下面的例子感受一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</div><div class="line"><span class="keyword">print</span> re.split(pattern,<span class="string">'one1two2three3four4'</span>)</div><div class="line"></div><div class="line"><span class="comment">### 输出 ###</span></div><div class="line"><span class="comment"># ['one', 'two', 'three', 'four', '']</span></div></pre></td></tr></table></figure></p><p><strong>re.findall(pattern, string[, flags])</strong></p><p>搜索string，以列表形式返回全部能匹配的子串。我们通过这个例子来感受一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</div><div class="line"><span class="keyword">print</span> re.findall(pattern,<span class="string">'one1two2three3four4'</span>)</div><div class="line"></div><div class="line"><span class="comment">### 输出 ###</span></div><div class="line"><span class="comment"># ['1', '2', '3', '4']</span></div></pre></td></tr></table></figure></p><p><strong>re.finditer(pattern, string[, flags])</strong></p><p>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。我们通过下面的例子来感受一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</div><div class="line"><span class="keyword">for</span> m <span class="keyword">in</span> re.finditer(pattern,<span class="string">'one1two2three3four4'</span>):</div><div class="line">    <span class="keyword">print</span> m.group(),</div><div class="line"></div><div class="line"><span class="comment">### 输出 ###</span></div><div class="line"><span class="comment"># 1 2 3 4</span></div></pre></td></tr></table></figure></p><p><strong>re.sub(pattern, repl, string[, count])</strong></p><p>使用repl替换string中每一个匹配的子串后返回替换后的字符串。<br>当repl是一个字符串时，可以使用\id或\g、\g引用分组，但不能使用编号0。<br>当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。<br>count用于指定最多替换次数，不指定时全部替换。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">pattern = re.compile(<span class="string">r'(\w+) (\w+)'</span>)</div><div class="line">s = <span class="string">'i say, hello world!'</span></div><div class="line"><span class="keyword">print</span> re.sub(pattern,<span class="string">r'\2 \1'</span>, s)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(m)</span>:</span></div><div class="line">    <span class="keyword">return</span> m.group(<span class="number">1</span>).title() + <span class="string">' '</span> + m.group(<span class="number">2</span>).title()</div><div class="line"><span class="keyword">print</span> re.sub(pattern,func, s)</div><div class="line"><span class="comment">### output ###</span></div><div class="line"><span class="comment"># say i, world hello!</span></div><div class="line"><span class="comment"># I Say, Hello World!</span></div></pre></td></tr></table></figure></p><p><strong>re.subn(pattern, repl, string[, count])</strong><br>返回 (sub(repl, string[, count]), 替换次数)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">pattern = re.compile(<span class="string">r'(\w+) (\w+)'</span>)</div><div class="line">s = <span class="string">'i say, hello world!'</span></div><div class="line"><span class="keyword">print</span> re.subn(pattern,<span class="string">r'\2 \1'</span>, s) </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(m)</span>:</span></div><div class="line">    <span class="keyword">return</span> m.group(<span class="number">1</span>).title() + <span class="string">' '</span> + m.group(<span class="number">2</span>).title() </div><div class="line"><span class="keyword">print</span> re.subn(pattern,func, s)</div><div class="line"> </div><div class="line"><span class="comment">### output ###</span></div><div class="line"><span class="comment"># ('say i, world hello!', 2)</span></div><div class="line"><span class="comment"># ('I Say, Hello World!', 2)</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy入门教程</title>
    <link href="https://blog.devzou.com/2018/08/19/python/2017-03-19-scrapy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.devzou.com/2018/08/19/python/2017-03-19-scrapy入门教程/</id>
    <published>2018-08-19T00:10:09.000Z</published>
    <updated>2019-04-24T06:58:17.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个scrapy项目"><a href="#创建一个scrapy项目" class="headerlink" title="创建一个scrapy项目"></a>创建一个scrapy项目</h2><p>在开始爬取之前，您必须创建一个新的Scrapy项目。 进入您打算存储代码的目录中，运行下列命令:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject  scrapyProject</div></pre></td></tr></table></figure></p><p>该命令将会创建包含下列内容的 scrapyProject 目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">scrapyProject/</div><div class="line">    scrapy.cfg</div><div class="line">    scrapyProject/</div><div class="line">        __init__.py</div><div class="line">        items.py</div><div class="line">        pipelines.py</div><div class="line">        settings.py</div><div class="line">        spiders/</div><div class="line">            __init__.py</div><div class="line">            ...</div></pre></td></tr></table></figure></p><p>这些文件分别是:</p><p>scrapy.cfg: 项目的配置文件<br>scrapyProject/: 该项目的python模块。之后您将在此加入代码。<br>scrapyProject/items.py: 项目中的item文件.<br>scrapyProject/pipelines.py: 项目中的pipelines文件.<br>scrapyProject/settings.py: 项目的设置文件.<br>scrapyProject/spiders/: 放置spider代码的目录.</p><h2 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h2><p>Item 是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。</p><p>类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field 的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单)</p><p>首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 scrapyProject 目录中的 items.py 文件:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozItem</span><span class="params">(scrapy.Item)</span>:</span></div><div class="line">    title = scrapy.Field()</div><div class="line">    link = scrapy.Field()</div><div class="line">    desc = scrapy.Field()</div></pre></td></tr></table></figure></p><p>一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义。</p><h2 id="编写第一个爬虫-Spider"><a href="#编写第一个爬虫-Spider" class="headerlink" title="编写第一个爬虫(Spider)"></a>编写第一个爬虫(Spider)</h2><p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。<br>其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。<br>为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:<br>name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。<br>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。<br>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。<br>以下为我们的第一个Spider代码，保存在 scrapyProject/spiders 目录下的 dmoz_spider.py 文件中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">"dmoz"</span></div><div class="line">    allowed_domains = [<span class="string">"dmoz.org"</span>]</div><div class="line">    start_urls = [</div><div class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Books/"</span>,</div><div class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        filename = response.url.split(<span class="string">"/"</span>)[<span class="number">-2</span>]</div><div class="line">        <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(response.body)</div></pre></td></tr></table></figure></p><h2 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h2><p>进入项目的根目录，执行下列命令启动spider:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy crawl dmoz</div></pre></td></tr></table></figure></p><h2 id="提取Item"><a href="#提取Item" class="headerlink" title="提取Item"></a>提取Item</h2><h3 id="Selectors选择器简介"><a href="#Selectors选择器简介" class="headerlink" title="Selectors选择器简介"></a>Selectors选择器简介</h3><p>从网页中提取数据有很多方法。Scrapy使用了一种基于 <a href="https://www.w3.org/TR/xpath/" target="_blank" rel="external">XPath</a>和<a href="https://www.w3.org/TR/selectors/" target="_blank" rel="external">CSS</a> 表达式机制: Scrapy Selectors 。 关于selector和其他提取机制的信息请参考 Selector文档 。<br>这里给出XPath表达式的例子及对应的含义:</p><p>/html/head/title: 选择HTML文档中 <head> 标签内的 <title> 元素<br>/html/head/title/text(): 选择上面提到的 <title> 元素的文字<br>//td: 选择所有的 <td> 元素<br>//div[@class=”mine”]: 选择所有具有 class=”mine” 属性的 div 元素<br>上边仅仅是几个简单的XPath例子，XPath实际上要比这远远强大的多。<br>为了配合XPath，Scrapy除了提供了 Selector 之外，还提供了方法来避免每次从response中提取数据时生成selector的麻烦。<br>Selector有四个基本的方法(点击相应的方法可以看到详细的API文档):<br>xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。<br>css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表.<br>extract(): 序列化该节点为unicode字符串并返回list。<br>re(): 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。</td></title></title></head></p><h3 id="在Shell中尝试Selector选择器"><a href="#在Shell中尝试Selector选择器" class="headerlink" title="在Shell中尝试Selector选择器"></a>在Shell中尝试Selector选择器</h3><p>为了介绍Selector的使用方法，接下来我们将要使用内置的 Scrapy shell 。Scrapy Shell需要您预装好IPython(一个扩展的Python终端)。</p><p>您需要进入项目的根目录，执行下列命令来启动shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy shell &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      初级的爬虫我们利用urllib和urllib2库以及正则表达式就可以完成了，不过还有更加强大的工具，爬虫框架Scrapy
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础教程之文件I/O</title>
    <link href="https://blog.devzou.com/2018/08/15/python/2017-03-15-Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6I:O/"/>
    <id>https://blog.devzou.com/2018/08/15/python/2017-03-15-Python基础教程之文件I:O/</id>
    <published>2018-08-15T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:20.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打印到屏幕"><a href="#打印到屏幕" class="headerlink" title="打印到屏幕"></a>打印到屏幕</h2><p>最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Python 是一个非常棒的语言，不是吗？"</span>;</div></pre></td></tr></table></figure></p><p>你的标准屏幕上会产生以下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Python 是一个非常棒的语言，不是吗？</div></pre></td></tr></table></figure></p><h2 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h2><p>Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：<br>raw_input<br>input<br><strong>raw_input函数</strong><br>raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"> </div><div class="line">str = raw_input(<span class="string">"请输入："</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"你输入的内容是: "</span>, str</div></pre></td></tr></table></figure></p><p>这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入”Hello Python！”，它的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入：Hello Python！</div><div class="line">你输入的内容是:  Hello Python！</div></pre></td></tr></table></figure></p><p><strong>input函数</strong><br>input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"> </div><div class="line">str = input(<span class="string">"请输入："</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"你输入的内容是: "</span>, str</div></pre></td></tr></table></figure></p><p>这会产生如下的对应着输入的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入：[x*5 for x in range(2,10,2)]</div><div class="line">你输入的内容是:  [10, 20, 30, 40]</div></pre></td></tr></table></figure></p><h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。<br>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。<br><strong>open 函数</strong><br>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file object = open(file_name [, access_mode][, buffering])</div></pre></td></tr></table></figure></p><p>各个参数的细节如下：<br><strong>file_name：</strong>file_name变量是一个包含了你要访问的文件名称的字符串值。<br>access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。<br><strong>buffering:</strong>如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。<br>不同模式打开文件的完全列表：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td></tr></tbody></table><div>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</div><p> |<br>| rb |  </p><div>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</div><p> |<br>| r+ |  </p><div>打开一个文件用于读写。文件指针将会放在文件的开头。</div><p> |<br>| rb+ |  </p><div>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</div><p> |<br>| w |  </p><div>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><p> |<br>| wb |  </p><div>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><p> |<br>| w+ |  </p><div>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><p> |<br>| wb+ |  </p><div>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><p> |<br>| a |  </p><div>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</div><p> |<br>| ab |  </p><div>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</div><p> |<br>| a+ |  </p><div>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</div><p> |<br>| ab+ |  </p><div>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</div><p> |</p><h2 id="File对象的属性"><a href="#File对象的属性" class="headerlink" title="File对象的属性"></a>File对象的属性</h2><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。<br>以下是和file对象相关的所有属性的列表：<br>| 属性 | 描述 |<br>| — | — |<br>| file.closed |  </p><div>返回true如果文件已被关闭，否则返回false。</div><p> |<br>| file.mode<span class="Apple-tab-span" style="white-space:pre"></span> |  </p><div>返回被打开文件的访问模式。</div><p> |<br>| file.name |  </p><div>返回文件的名称。</div><p> |<br>| file.softspace |  </p><div>如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</div><p> |<br>如下实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"文件名: "</span>, fo.name</div><div class="line"><span class="keyword">print</span> <span class="string">"是否已关闭 : "</span>, fo.closed</div><div class="line"><span class="keyword">print</span> <span class="string">"访问模式 : "</span>, fo.mode</div><div class="line"><span class="keyword">print</span> <span class="string">"末尾是否强制加空格 : "</span>, fo.softspace</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">文件名:  foo.txt</div><div class="line">是否已关闭 :  False</div><div class="line">访问模式 :  wb</div><div class="line">末尾是否强制加空格 :  0</div></pre></td></tr></table></figure></p><p><strong>close()方法</strong><br>File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。<br>当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fileObject.close();</div></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"文件名: "</span>, fo.name</div><div class="line"> </div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">文件名:  foo.txt</div></pre></td></tr></table></figure></p><p>读写文件：<br>file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。<br><strong>write()方法</strong><br>write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。<br>write()方法不会在字符串的结尾添加换行符(‘\n’)：<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fileObject.write(string);</div></pre></td></tr></table></figure></p><p>在这里，被传递的参数是要写入到已打开文件的内容。<br>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line">fo.write( <span class="string">"www.lianyucode.top!\nVery good site!\n"</span>);</div><div class="line"> </div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p><p>上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat foo.txt </div><div class="line">www.lianyucode.top!</div><div class="line">Very good site!</div></pre></td></tr></table></figure><p><strong>read()方法</strong><br>read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fileObject.read([count]);</div></pre></td></tr></table></figure></p><p>在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。<br>例子：<br>这里我们用到以上创建的 foo.txt 文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">读取的字符串是 :  www.lianyucode.top</div></pre></td></tr></table></figure></p><h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p>tell()方法告诉你文件内的当前位置；换句话说，下一次的读写会发生在文件开头这么多字节之后。<br>seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。<br>如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。<br>例子：<br>就用我们上面创建的文件foo.txt。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</div><div class="line"> </div><div class="line"><span class="comment"># 查找当前位置</span></div><div class="line">position = fo.tell();</div><div class="line"><span class="keyword">print</span> <span class="string">"当前文件位置 : "</span>, position</div><div class="line"> </div><div class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></div><div class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"重新读取字符串 : "</span>, str</div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">读取的字符串是 :  www.runoob</div><div class="line">当前文件位置 :  10</div><div class="line">重新读取字符串 :  www.runoob</div></pre></td></tr></table></figure></p><h2 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h2><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。<br>要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。<br>rename()方法：<br>rename()方法需要两个参数，当前的文件名和新文件名。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.rename(current_file_name, new_file_name)</div></pre></td></tr></table></figure></p><p>例子：<br>下例将重命名一个已经存在的文件test1.txt。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 重命名文件test1.txt到test2.txt。</span></div><div class="line">os.rename( <span class="string">"test1.txt"</span>, <span class="string">"test2.txt"</span> )</div></pre></td></tr></table></figure></p><p><strong>remove()方法</strong><br>你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.remove(file_name)</div></pre></td></tr></table></figure></p><p>例子：<br>下例将删除一个已经存在的文件test2.txt。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 删除一个已经存在的文件test2.txt</span></div><div class="line">os.remove(<span class="string">"test2.txt"</span>)</div></pre></td></tr></table></figure></p><h2 id="Python里的目录："><a href="#Python里的目录：" class="headerlink" title="Python里的目录："></a>Python里的目录：</h2><p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。<br>mkdir()方法<br>可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.mkdir(<span class="string">"newdir"</span>)</div></pre></td></tr></table></figure></p><p>例子：<br>下例将在当前目录下创建一个新目录test。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 创建目录test</span></div><div class="line">os.mkdir(<span class="string">"test"</span>)</div></pre></td></tr></table></figure></p><p><strong>chdir()方法</strong><br>可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.chdir(<span class="string">"newdir"</span>)</div></pre></td></tr></table></figure></p><p>例子：<br>下例将进入”/home/newdir”目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 将当前目录改为"/home/newdir"</span></div><div class="line">os.chdir(<span class="string">"/home/newdir"</span>)</div></pre></td></tr></table></figure></p><p><strong>getcwd()方法：</strong><br>getcwd()方法显示当前的工作目录。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.getcwd()</div></pre></td></tr></table></figure></p><p>例子：<br>下例给出当前目录：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 给出当前的目录</span></div><div class="line"><span class="keyword">print</span> os.getcwd()</div></pre></td></tr></table></figure></p><p><strong>rmdir()方法</strong><br>rmdir()方法删除目录，目录名称以参数传递。<br>在删除这个目录之前，它的所有内容应该先被清除。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.rmdir(<span class="string">'dirname'</span>)</div></pre></td></tr></table></figure></p><p>例子：<br>以下是删除” /tmp/test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 删除”/tmp/test”目录</span></div><div class="line">os.rmdir( <span class="string">"/tmp/test"</span>  )</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      本章只讲述所有基本的的I/O函数，更多函数请参考Python标准文档。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="https://blog.devzou.com/2018/08/05/ios/2018-08-12-iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://blog.devzou.com/2018/08/05/ios/2018-08-12-iOS面试题/</id>
    <published>2018-08-04T23:10:09.000Z</published>
    <updated>2019-03-02T12:41:08.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个NSObject对象占用多少内存"><a href="#一个NSObject对象占用多少内存" class="headerlink" title="一个NSObject对象占用多少内存"></a>一个NSObject对象占用多少内存</h2><p>系统分配了16个字节给NSObject对象<br>但NSObject对象内部只使用了8个字节的空间(64bit环境下)</p><h2 id="对象的isa指针指向哪里"><a href="#对象的isa指针指向哪里" class="headerlink" title="对象的isa指针指向哪里"></a>对象的isa指针指向哪里</h2><p>instance对象的isa指向class<br>当调用对象方法时，通过instance对象的isa找到class 对象，最后找到对象方法的实现进行调用<br>class 的isa指向meta-class<br>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用<br>meta-class的isa指向基类的meta-class对象</p><h2 id="OC的类信息存放在哪里"><a href="#OC的类信息存放在哪里" class="headerlink" title="OC的类信息存放在哪里"></a>OC的类信息存放在哪里</h2><p>对象方法、属性、成员变量、协议信息，存放在class对象中<br>类方法，存放在meta-class对象中<br>成员变量的具体值，存放在instance对象中</p><h2 id="iOS用什么方式实现对一个对象的KVO-KVO的本质是什么"><a href="#iOS用什么方式实现对一个对象的KVO-KVO的本质是什么" class="headerlink" title="iOS用什么方式实现对一个对象的KVO?(KVO的本质是什么)"></a>iOS用什么方式实现对一个对象的KVO?(KVO的本质是什么)</h2><p>利用runtimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类<br>当修改instance对象的属性时，会调用Foundation的_NSSetXXXXValueAndNotify函数<br>willChangeValueForKey:<br>父类原来的setter方法<br>didChangeValueForKey:<br>内部会触发监听器(Observer)的监听方法(oberserveValueForKeyPath:ofObject:change:context:)</p><h2 id="如何手动触发KVO"><a href="#如何手动触发KVO" class="headerlink" title="如何手动触发KVO"></a>如何手动触发KVO</h2><p>手动调用willChangeValueForKey和didChangeValueForKey</p><h2 id="直接修改成员变量会触发KVO吗"><a href="#直接修改成员变量会触发KVO吗" class="headerlink" title="直接修改成员变量会触发KVO吗"></a>直接修改成员变量会触发KVO吗</h2><p>不会</p><h2 id="通过KVC修改属性的值，会触发KVO吗"><a href="#通过KVC修改属性的值，会触发KVO吗" class="headerlink" title="通过KVC修改属性的值，会触发KVO吗"></a>通过KVC修改属性的值，会触发KVO吗</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一个NSObject对象占用多少内存&quot;&gt;&lt;a href=&quot;#一个NSObject对象占用多少内存&quot; class=&quot;headerlink&quot; title=&quot;一个NSObject对象占用多少内存&quot;&gt;&lt;/a&gt;一个NSObject对象占用多少内存&lt;/h2&gt;&lt;p&gt;系统分配了1
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之策略模式</title>
    <link href="https://blog.devzou.com/2018/08/05/ios/2018-07-21-iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.devzou.com/2018/08/05/ios/2018-07-21-iOS设计模式之策略模式/</id>
    <published>2018-08-04T23:10:09.000Z</published>
    <updated>2019-03-02T07:02:45.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><ol><li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。</li><li>在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。<a id="more"></a></li><li>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</li><li>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</li><li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2>策略模式包含如下角色：</li></ol><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类<br><img src="" alt=""><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2></li></ul><ol><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2></li></ol><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li><p>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>策略模式与状态模式</p></li><li><p>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</p></li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。<h2 id="优点-amp-amp-缺点"><a href="#优点-amp-amp-缺点" class="headerlink" title="优点&amp;&amp;缺点"></a>优点&amp;&amp;缺点</h2><h3 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h3></li></ul><ol><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。<h3 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h3></li></ol><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<br>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模式动机&quot;&gt;&lt;a href=&quot;#模式动机&quot; class=&quot;headerlink&quot; title=&quot;模式动机&quot;&gt;&lt;/a&gt;模式动机&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。&lt;/li&gt;
&lt;li&gt;在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之KVC底层原理</title>
    <link href="https://blog.devzou.com/2018/08/05/ios/2018-08-22-KVC/"/>
    <id>https://blog.devzou.com/2018/08/05/ios/2018-08-22-KVC/</id>
    <published>2018-08-04T23:10:09.000Z</published>
    <updated>2019-03-02T07:02:45.140Z</updated>
    
    <content type="html"><![CDATA[<p>KVC的全称是Key-Value Coding 俗称键值编码，可以通过一个key来访问某个属性<br>常见的API有</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)keyPath</div><div class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;KVC的全称是Key-Value Coding 俗称键值编码，可以通过一个key来访问某个属性&lt;br&gt;常见的API有&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div cla
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之Category</title>
    <link href="https://blog.devzou.com/2018/08/05/ios/2018-08-23-Category/"/>
    <id>https://blog.devzou.com/2018/08/05/ios/2018-08-23-Category/</id>
    <published>2018-08-04T23:10:09.000Z</published>
    <updated>2019-03-02T07:02:45.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Category实现原理"><a href="#Category实现原理" class="headerlink" title="Category实现原理"></a>Category实现原理</h2><h3 id="category的结构"><a href="#category的结构" class="headerlink" title="category的结构"></a>category的结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct category_t &#123;</div><div class="line">    const char *name;</div><div class="line">    classref_t cls;</div><div class="line">    struct method_list_t *instanceMethods;</div><div class="line">    struct method_list_t *classMethods;</div><div class="line">    struct protocol_list_t *protocols;</div><div class="line">    struct property_list_t *instanceProperties;</div><div class="line">    // Fields below this point are not always present on disk.</div><div class="line">    struct property_list_t *_classProperties;</div><div class="line"></div><div class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</div><div class="line">        if (isMeta) return classMethods;</div><div class="line">        else return instanceMethods;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Category实现原理&quot;&gt;&lt;a href=&quot;#Category实现原理&quot; class=&quot;headerlink&quot; title=&quot;Category实现原理&quot;&gt;&lt;/a&gt;Category实现原理&lt;/h2&gt;&lt;h3 id=&quot;category的结构&quot;&gt;&lt;a href=&quot;#ca
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>clang常用命令</title>
    <link href="https://blog.devzou.com/2018/08/04/ios/2018-08-12/"/>
    <id>https://blog.devzou.com/2018/08/04/ios/2018-08-12/</id>
    <published>2018-08-03T23:10:09.000Z</published>
    <updated>2019-03-02T12:41:12.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将OC代码转化为C-C-代码"><a href="#将OC代码转化为C-C-代码" class="headerlink" title="将OC代码转化为C/C++代码"></a>将OC代码转化为C/C++代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc xxxx.m -o xxxx.cpp</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的cpp文件</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;将OC代码转化为C-C-代码&quot;&gt;&lt;a href=&quot;#将OC代码转化为C-C-代码&quot; class=&quot;headerlink&quot; title=&quot;将OC代码转化为C/C++代码&quot;&gt;&lt;/a&gt;将OC代码转化为C/C++代码&lt;/h2&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理之OC对象本质</title>
    <link href="https://blog.devzou.com/2018/07/31/ios/2018-08-12-iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B9%8BOC%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/"/>
    <id>https://blog.devzou.com/2018/07/31/ios/2018-08-12-iOS底层原理之OC对象本质/</id>
    <published>2018-07-30T23:10:09.000Z</published>
    <updated>2019-03-02T12:41:25.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h2><p>我们平时编写的Object-C代码，底层都是C/C++代码，所以Objective-C的面向对象都是基于C/C++的数据结构实现的<br>【注】Objective-C的对象、类主要是基于C/C++的结构体实现的</p><h3 id="NSObject的底层实现"><a href="#NSObject的底层实现" class="headerlink" title="NSObject的底层实现"></a>NSObject的底层实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span>  <span class="title">NSObjec</span> </span>&#123;</div><div class="line">  Class isa;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C语言实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct NSObject_IMPL &#123;</div><div class="line">Class isa;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="OC对象的本质"><a href="#OC对象的本质" class="headerlink" title="OC对象的本质"></a>OC对象的本质</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Objective-C的本质&quot;&gt;&lt;a href=&quot;#Objective-C的本质&quot; class=&quot;headerlink&quot; title=&quot;Objective-C的本质&quot;&gt;&lt;/a&gt;Objective-C的本质&lt;/h2&gt;&lt;p&gt;我们平时编写的Object-C代码，底层都是
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之建造者模式</title>
    <link href="https://blog.devzou.com/2018/07/31/ios/2018-07-31-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.devzou.com/2018/07/31/ios/2018-07-31-设计模式之建造者模式/</id>
    <published>2018-07-30T23:10:09.000Z</published>
    <updated>2019-04-22T14:00:59.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>建造者模式包含如下角色：</p><ul><li>Builder：抽象建造者，为创建一个产品对象的各个部件指定抽象接口</li><li>ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并 提供一个检索产品的接口</li><li>Director：构造一个使用Builder接口的对象</li><li>Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口<h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2>抽象建造者类中定义了产品的创建方法和返回方法;</li></ul><p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><ul><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li><p>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。<br>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用建造者模式：</p></li><li><p>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</p></li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li><p>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>建造者模式的简化:</p></li><li><p>省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。</p></li><li>省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让</li><li>Builder角色扮演指挥者与建造者双重角色。</li></ul><p>建造者模式与抽象工厂模式的比较:</p><ul><li>与抽象工厂模式相比， 建造者模式返回一个组装好的完整产品 ，而 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成 汽车配件生产工厂 ，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式动机&quot;&gt;&lt;a href=&quot;#模式动机&quot; class=&quot;headerlink&quot; title=&quot;模式动机&quot;&gt;&lt;/a&gt;模式动机&lt;/h2&gt;&lt;p&gt;无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
</feed>
