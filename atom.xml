<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小玉的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.devzou.com/"/>
  <updated>2019-04-17T13:21:54.362Z</updated>
  <id>https://blog.devzou.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack4入门教程</title>
    <link href="https://blog.devzou.com/2019/03/06/web%E5%89%8D%E7%AB%AF/2018-04-01-webpack4%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.devzou.com/2019/03/06/web前端/2018-04-01-webpack4入门教程/</id>
    <published>2019-03-06T13:04:24.000Z</published>
    <updated>2019-04-17T13:21:54.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。<br><a id="more"></a></p><h2 id="为什要使用WebPack"><a href="#为什要使用WebPack" class="headerlink" title="为什要使用WebPack"></a>为什要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p><p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常反锁的，这就为WebPack类的工具的出现提供了需求。</p><h2 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h2><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。</p><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。<br>Grunt和Gulp的工作流程<br><img src="/img/webpack_1_03.png" alt=""><br>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。<br><img src="/img/webpack_1_01.png" alt=""><br>Webpack工作方式</p><p>Webpack工作方式<br>如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。</p><p>开始使用Webpack</p><p>初步了解了Webpack工作方式后，我们一步步的开始学习使用Webpack。</p><h2 id="全局安装webpack及webpack-cli"><a href="#全局安装webpack及webpack-cli" class="headerlink" title="全局安装webpack及webpack-cli"></a>全局安装webpack及webpack-cli</h2><p>安装webpack</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g webpack</div></pre></td></tr></table></figure><p>安装webpack-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g webpack-cli</div></pre></td></tr></table></figure><h2 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h2><p>在桌面新建一个文件夹用于存放工程文件,文件夹名称为mywebpack。</p><p>在mywebpack文件夹中创建一个package.json文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init -y</div></pre></td></tr></table></figure><p>在mywebpack文件夹下创建index.html文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>在mywebpack文件夹创建src文件夹,在src文件夹下创建index.js,代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.write(<span class="string">"hello webpack"</span>);</div></pre></td></tr></table></figure></p><p>使用webpack进行打包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --mode development</div></pre></td></tr></table></figure></p><p>执行后结果如下<br><img src="/img/webpack_1_04.png" alt=""><br>【重要】webpack4.x的打包已经不能用webpack 文件a 文件b的方式，而是直接运行webpack –mode development或者webpack –mode production，这样便会默认进行打包，入口文件是’./src/index.js’，输出路径是’./dist/main.js’，其中src目录即index.js文件需要手动创建，而dist目录及main.js会自动生成。</p><p>因此我们不再按webpack 文件a 文件b的方式运行webpack指令，而是直接运行</p><p>　　webpack –mode development<br>或<br>　　webpack –mode production</p><p>这样便能够实现将’./src/index.js’打包成’./dist/main.js’。</p><p>不过每次都要输入这个命令，非常麻烦，我们在package.json中scripts中加入两个成员：</p><p>　　“dev”:”webpack –mode development”,</p><p>　　“build”:”webpack –mode production”</p><p>执行webpack –mode development<br>执行npm run dev，相当于执行webpack –mode development</p><p>执行完毕后打开index.html效果如下<br><img src="/img/webpack_1_02.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。
    
    </summary>
    
      <category term="前端" scheme="https://blog.devzou.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://blog.devzou.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Clang常用命令介绍</title>
    <link href="https://blog.devzou.com/2019/02/20/ios/2019-04-26-clang%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.devzou.com/2019/02/20/ios/2019-04-26-clang常用命令介绍/</id>
    <published>2019-02-20T00:10:09.000Z</published>
    <updated>2019-04-27T09:10:11.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。学习Clang有助于我们对Objective-C编译过程的理解</p><h2 id="Clang常用命令介绍"><a href="#Clang常用命令介绍" class="headerlink" title="Clang常用命令介绍"></a>Clang常用命令介绍</h2><h3 id="clang-ccc-print-phases-main-m"><a href="#clang-ccc-print-phases-main-m" class="headerlink" title="clang -ccc-print-phases main.m"></a>clang -ccc-print-phases main.m</h3><p>功能：查看编译的步骤<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: input, &quot;main.m&quot;, objective-c</div><div class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</div><div class="line">2: compiler, &#123;1&#125;, ir</div><div class="line">3: backend, &#123;2&#125;, assembler</div><div class="line">4: assembler, &#123;3&#125;, object</div><div class="line">5: linker, &#123;4&#125;, image</div><div class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image</div></pre></td></tr></table></figure></p><h3 id="clang-rewrite-objc-main-m"><a href="#clang-rewrite-objc-main-m" class="headerlink" title="clang -rewrite-objc main.m"></a>clang -rewrite-objc main.m</h3><p>功能：查看编译结果<br>输出结果：main.cpp文件</p><h3 id="clang-main-m-o-main"><a href="#clang-main-m-o-main" class="headerlink" title="clang -### main.m -o main"></a>clang -### main.m -o main</h3><p>功能：查看操作内部命令<br>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Apple LLVM version 10.0.1 (clang-1001.0.46.3)</div><div class="line">Target: x86_64-apple-darwin18.2.0</div><div class="line">Thread model: posix</div><div class="line">InstalledDir: /Library/Developer/CommandLineTools/usr/bin</div><div class="line"> &quot;/Library/Developer/CommandLineTools/usr/bin/clang&quot; &quot;-cc1&quot; &quot;-triple&quot; &quot;x86_64-apple-macosx10.14.0&quot; &quot;-Wdeprecated-objc-isa-usage&quot; &quot;-Werror=deprecated-objc-isa-usage&quot; &quot;-emit-obj&quot; &quot;-mrelax-all&quot; &quot;-disable-free&quot; &quot;-disable-llvm-verifier&quot; &quot;-discard-value-names&quot; &quot;-main-file-name&quot; &quot;main.m&quot; &quot;-mrelocation-model&quot; &quot;pic&quot; &quot;-pic-level&quot; &quot;2&quot; &quot;-mthread-model&quot; &quot;posix&quot; &quot;-mdisable-fp-elim&quot; &quot;-fno-strict-return&quot; &quot;-masm-verbose&quot; &quot;-munwind-tables&quot; &quot;-target-sdk-version=10.14&quot; &quot;-target-cpu&quot; &quot;penryn&quot; &quot;-dwarf-column-info&quot; &quot;-debugger-tuning=lldb&quot; &quot;-target-linker-version&quot; &quot;450.3&quot; &quot;-resource-dir&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/clang/10.0.1&quot; &quot;-isysroot&quot; &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk&quot; &quot;-I/usr/local/include&quot; &quot;-Wno-atomic-implicit-seq-cst&quot; &quot;-Wno-framework-include-private-from-public&quot; &quot;-Wno-atimport-in-framework-header&quot; &quot;-Wno-quoted-include-in-framework-header&quot; &quot;-fdebug-compilation-dir&quot; &quot;/Users/ZLY/Desktop&quot; &quot;-ferror-limit&quot; &quot;19&quot; &quot;-fmessage-length&quot; &quot;238&quot; &quot;-stack-protector&quot; &quot;1&quot; &quot;-fblocks&quot; &quot;-fencode-extended-block-signature&quot; &quot;-fregister-global-dtors-with-atexit&quot; &quot;-fobjc-runtime=macosx-10.14.0&quot; &quot;-fobjc-exceptions&quot; &quot;-fexceptions&quot; &quot;-fmax-type-align=16&quot; &quot;-fdiagnostics-show-option&quot; &quot;-fcolor-diagnostics&quot; &quot;-o&quot; &quot;/var/folders/kj/svm6s3rn6kdcvmbhds_grhvm0000gp/T/main-1301a5.o&quot; &quot;-x&quot; &quot;objective-c&quot; &quot;main.m&quot;</div><div class="line"> &quot;/Library/Developer/CommandLineTools/usr/bin/ld&quot; &quot;-demangle&quot; &quot;-lto_library&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/libLTO.dylib&quot; &quot;-no_deduplicate&quot; &quot;-dynamic&quot; &quot;-arch&quot; &quot;x86_64&quot; &quot;-macosx_version_min&quot; &quot;10.14.0&quot; &quot;-syslibroot&quot; &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk&quot; &quot;-o&quot; &quot;main&quot; &quot;/var/folders/kj/svm6s3rn6kdcvmbhds_grhvm0000gp/T/main-1301a5.o&quot; &quot;-L/usr/local/lib&quot; &quot;-lSystem&quot; &quot;/Library/Developer/CommandLineTools/usr/lib/clang/10.0.1/lib/darwin/libclang_rt.osx.a&quot;</div></pre></td></tr></table></figure></p><h2 id="clang基本语法介绍"><a href="#clang基本语法介绍" class="headerlink" title="clang基本语法介绍"></a>clang基本语法介绍</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>-fmodules</td><td>允许modules的语言特性</td></tr><tr><td>-fsyntax-only</td><td>防止编译器生成代码,只是语法级别的说明和修改</td></tr><tr><td>-Xclang <arg></arg></td><td>向clang编译器传递参数</td></tr><tr><td>-dump-tokens</td><td>运行预处理器,拆分内部代码段为各种token</td></tr><tr><td>-ast-dump</td><td>构建抽象语法树AST,然后对其进行拆解和调试</td></tr><tr><td>-S</td><td>只运行预处理和编译步骤</td></tr><tr><td>-fobjc-arc</td><td>为OC对象生成retain和release的调用</td></tr><tr><td>-emit-llvm</td><td>使用LLVM描述汇编和对象文件</td></tr><tr><td>-o <file></file></td><td>输出到目标文件</td></tr><tr><td>-c</td><td>只运行预处理,编译和汇编步骤</td></tr></tbody></table><h2 id="代码编译的执行步骤拆解"><a href="#代码编译的执行步骤拆解" class="headerlink" title="代码编译的执行步骤拆解"></a>代码编译的执行步骤拆解</h2><p>下面我们对iOS代码编译的步骤进行一个简单的拆解,看看内部是如何实现的.<br>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p><p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p><p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p><p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="external">Writing an LLVM Pass — LLVM 5 documentation</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p><p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。<br>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure></p><p>生成汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure></p><p>生成目标文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure></p><p>生成可执行文件，这样就能够执行看到输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">clang main.o -o main</div><div class="line">执行</div><div class="line">./main</div><div class="line">输出</div><div class="line">starming rank 14</div></pre></td></tr></table></figure></p><p>下面是完整步骤：</p><ol><li>编译信息写入辅助文件，创建文件架构 .app 文件</li><li>处理文件打包信息</li><li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li><li>编译.m文件，使用 CompileC 和 clang 命令</li><li>链接需要的 Framework</li><li>编译 xib</li><li>拷贝 xib ，资源文件</li><li>编译 ImageAssets</li><li>处理 info.plist</li><li>执行 CocoaPod 脚本</li><li>拷贝标准库</li><li>创建 .app 文件和签名</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。学习Clang有助于我们对Objective-C编译过程的理
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Python高级编程之爬虫Scrapy框架安装配置</title>
    <link href="https://blog.devzou.com/2018/11/28/python/2017-03-18-python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABScrapy%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.devzou.com/2018/11/28/python/2017-03-18-python高级编程之爬虫Scrapy框架安装配置/</id>
    <published>2018-11-28T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:35.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac下安装Scrapy框架"><a href="#Mac下安装Scrapy框架" class="headerlink" title="Mac下安装Scrapy框架"></a>Mac下安装Scrapy框架</h2><p>刚刚试了下可以，可以简化为下面三个步骤<br>一、删除Mac自带的Python<br>sudo rm -rf /usr/bin/python<br>二、homebrew安装最新的Python<br>brew install python<br>创建一个软链接<br>sudo ln -s /usr/local/bin/python /usr/bin/python<br>三、使用pip安装scrapy<br>使用homebrew安装完python后会自动安装好包管理工具pip，所以执行下面安装命令<br>pip install scrapy<br>安装完成后如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">machaismile$ scrapy</div><div class="line">Scrapy 0.22.2 - no active project</div><div class="line"></div><div class="line">Usage:</div><div class="line">  scrapy &lt;command&gt; [options] [args]</div><div class="line"></div><div class="line">Available commands:</div><div class="line">  bench         Run quick benchmark test</div><div class="line">  fetch         Fetch a URL using the Scrapy downloader</div><div class="line">  runspider     Run a self-contained spider (without creating a project)</div><div class="line">  settings      Get settings values</div><div class="line">  shell         Interactive scraping console</div><div class="line">  startproject  Create new project</div><div class="line">  version       Print Scrapy version</div><div class="line">  view          Open URL in browser, as seen by Scrapy</div><div class="line"></div><div class="line">  [ more ]      More commands available when run from project directory</div><div class="line"></div><div class="line">Use &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command</div></pre></td></tr></table></figure></p><p>出现 zsh: command not found: scrapy 执行</p><p> ln -s  /Library/Frameworks/Python.framework/Versions/2.7/bin/scrapy /usr/local/bin/scrapy</p>]]></content>
    
    <summary type="html">
    
      初级的爬虫我们利用urllib和urllib2库以及正则表达式就可以完成了，不过还有更加强大的工具，爬虫框架Scrapy
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级教程之爬虫urllib基本使用</title>
    <link href="https://blog.devzou.com/2018/11/17/python/2017-03-17-python%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABurllib%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.devzou.com/2018/11/17/python/2017-03-17-python高级教程之爬虫urllib基本使用/</id>
    <published>2018-11-17T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:10.747Z</updated>
    
    <content type="html"><![CDATA[<p>如下程序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure></p><p>把它保存成 demo.py，进入该文件的目录，执行命令<code>python demo.py</code>查看运行结果，感受一下。</p><h2 id="分析扒网页的方法"><a href="#分析扒网页的方法" class="headerlink" title="分析扒网页的方法"></a>分析扒网页的方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</div></pre></td></tr></table></figure><p>首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，当然你也可以把HTTP换做FTP,FILE,HTTPS 等等，只是代表了一种访问控制协议，urlopen一般接受三个参数，它的参数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">urlopen(url, data, timeout)</div></pre></td></tr></table></figure></p><p>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。<br>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT<br>第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><p>response对象有一个read方法，可以返回获取到的网页内容。</p><h2 id="构造Request"><a href="#构造Request" class="headerlink" title="构造Request"></a>构造Request</h2><p>其实上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。比如上面的两行代码，我们可以这么改写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">request = urllib2.Request(<span class="string">"http://www.baidu.com"</span>)</div><div class="line">response = urllib2.urlopen(request)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure></p><p>运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</p><h2 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h2><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。最常见的情况是什么？对了，就是登录注册的时候呀。</p><p>把数据用户名和密码传送到一个URL，然后你得到服务器处理之后的响应，这个该怎么办？下面让我来为小伙伴们揭晓吧！</p><p>数据传送分为POST和GET两种方式，两种方式有什么区别呢？</p><p>最重要的区别是GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。</p><p>POST方式：</p><p>上面我们说了data参数是干嘛的？对了，它就是用在这里的，我们传送的数据就是这个参数data，下面演示一下POST方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">values = &#123;<span class="string">"username"</span>:<span class="string">"1315751082@qq.com"</span>,<span class="string">"password"</span>:<span class="string">"XXXX"</span>&#125;</div><div class="line">data = urllib.urlencode(values) </div><div class="line">url = <span class="string">"https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"</span></div><div class="line">request = urllib2.Request(url,data)</div><div class="line">response = urllib2.urlopen(request)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><p>【抓取糗事百科页面的数据例子】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">import</span> re</div><div class="line"> </div><div class="line">page = <span class="number">1</span></div><div class="line">url = <span class="string">'https://www.qiushibaike.com/text/'</span> + str(page)</div><div class="line">user_agent = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6)'</span></div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    request = urllib2.Request(url,headers = headers)</div><div class="line">    response = urllib2.urlopen(request)</div><div class="line"><span class="comment">#    print response.read()</span></div><div class="line">    content = response.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">    pattern = re.compile(<span class="string">'&lt;div.*?author.*?&lt;a.*?&lt;img.*?&gt;(.*?)&lt;/a&gt;.*?&lt;div.*?'</span>+</div><div class="line">                         <span class="string">'content"&gt;(.*?)&lt;/div&gt;(.*?)&lt;div class="stats.*?class="number"&gt;(.*?)&lt;/i&gt;'</span>,re.S)</div><div class="line">    items = re.findall(pattern,content)</div><div class="line"><span class="comment">#    print items</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">        <span class="keyword">print</span> item</div><div class="line"><span class="comment">#        haveImg = re.search("img",item[3])</span></div><div class="line"><span class="comment">#        if not haveImg:</span></div><div class="line"><span class="comment">#           print item[0],item[1],item[2],item[4]</span></div><div class="line"><span class="keyword">except</span> urllib2.URLError, e:</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"code"</span>):</div><div class="line">        <span class="keyword">print</span> e.code</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"reason"</span>):</div><div class="line">        <span class="keyword">print</span> e.reason</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      怎样扒网页呢？其实就是根据URL来获取它的网页信息，虽然我们在浏览器中看到的是一幅幅优美的画面，但是其实是由浏览器解释才呈现出来的，实质它是一段HTML代码，加 JS、CSS，如果把网页比作一个人，那么HTML便是他的骨架，JS便是他的肌肉，CSS便是它的衣服。所以最重要的部分是存在于HTML中的，下面我们就写个例子来扒一个网页下来。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级教程之爬虫urllib库高级使用</title>
    <link href="https://blog.devzou.com/2018/11/17/python/2017-03-17.-Python%20%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B9%8B%E7%88%AC%E8%99%ABurllib%E5%BA%93%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.devzou.com/2018/11/17/python/2017-03-17.-Python 高级教程之爬虫urllib库高级使用/</id>
    <published>2018-11-17T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:00.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设置Headers"><a href="#1-设置Headers" class="headerlink" title="1.设置Headers"></a>1.设置Headers</h2><p>有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，我们需要设置一些Headers 的属性。</p><p>首先，打开我们的浏览器，调试浏览器F12，我用的是Chrome，打开网络监听，示意如下，比如知乎，点登录之后，我们会发现登陆之后界面都变化了，出现一个新的界面，实质上这个页面包含了许许多多的内容，这些内容也不是一次性就加载完成的，实质上是执行了好多次请求，一般是首先请求HTML文件，然后加载JS，CSS 等等，经过多次请求之后，网页的骨架和肌肉全了，整个网页的效果也就出来了。<br><img src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/02/2015-02-13-013155-%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-e1423762350360.png" alt=""><br>拆分这些请求，我们只看一第一个请求，你可以看到，有个Request URL，还有headers，下面便是response，图片显示得不全，小伙伴们可以亲身实验一下。那么这个头中包含了许许多多是信息，有文件编码啦，压缩方式啦，请求的agent啦等等。<br>其中，agent就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在headers中设置agent,例如下面的例子，这个例子只是说明了怎样设置的headers，小伙伴们看一下设置格式就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib  </div><div class="line"><span class="keyword">import</span> urllib2  </div><div class="line"></div><div class="line">url = <span class="string">'http://www.server.com/login'</span></div><div class="line">user_agent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>  </div><div class="line">values = &#123;<span class="string">'username'</span> : <span class="string">'cqc'</span>,  <span class="string">'password'</span> : <span class="string">'XXXX'</span> &#125;  </div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;  </div><div class="line">data = urllib.urlencode(values)  </div><div class="line">request = urllib2.Request(url, data, headers)  </div><div class="line">response = urllib2.urlopen(request)  </div><div class="line">page = response.read()</div></pre></td></tr></table></figure><p>另外，我们还有对付”反盗链”的方式，对付防盗链，服务器会识别headers中的referer是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在headers中加入referer</p><p>例如我们可以构建下面的headers<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>  ,</div><div class="line">                        <span class="string">'Referer'</span>:<span class="string">'http://www.zhihu.com/articles'</span> &#125;</div></pre></td></tr></table></figure></p><p>同上面的方法，在传送请求时把headers传入Request参数里，这样就能应付防盗链了。</p><p>另外headers的一些属性，下面的需要特别注意一下：</p><blockquote><p>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求<br>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。<br>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用<br>application/json ： 在 JSON RPC 调用时使用<br>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用<br>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p><h2 id="Proxy（代理）的设置"><a href="#Proxy（代理）的设置" class="headerlink" title="Proxy（代理）的设置"></a>Proxy（代理）的设置</h2></blockquote><p>urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！</p><p>下面一段代码说明了代理的设置用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">enable_proxy = <span class="keyword">True</span></div><div class="line">proxy_handler = urllib2.ProxyHandler(&#123;<span class="string">"http"</span> : <span class="string">'http://some-proxy.com:8080'</span>&#125;)</div><div class="line">null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)</div><div class="line"><span class="keyword">if</span> enable_proxy:</div><div class="line">    opener = urllib2.build_opener(proxy_handler)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    opener = urllib2.build_opener(null_proxy_handler)</div><div class="line">urllib2.install_opener(opener)</div></pre></td></tr></table></figure></p><h2 id="Timeout-设置"><a href="#Timeout-设置" class="headerlink" title="Timeout 设置"></a>Timeout 设置</h2><p>上一节已经说过urlopen方法了，第三个参数就是timeout的设置，可以设置等待多久超时，为了解决一些网站实在响应过慢而造成的影响。</p><p>例如下面的代码,如果第二个参数data为空那么要特别指定是timeout是多少，写明形参，如果data已经传入，则不必声明。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com'</span>, timeout=<span class="number">10</span>)</div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com'</span>,data, <span class="number">10</span>)</div></pre></td></tr></table></figure><h2 id="使用-HTTP-的-PUT-和-DELETE-方法"><a href="#使用-HTTP-的-PUT-和-DELETE-方法" class="headerlink" title="使用 HTTP 的 PUT 和 DELETE 方法"></a>使用 HTTP 的 PUT 和 DELETE 方法</h2><p>http协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求</p><blockquote><p>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。<br>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。<br> 如果要使用 HTTP PUT 和 DELETE ，只能使用比较低层的 httplib 库。虽然如此，我们还是能通过下面的方式，使 urllib2 能够发出 PUT 或DELETE 的请求，不过用的次数的确是少，在这里提一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">request = urllib2.Request(uri, data=data)</div><div class="line">request.get_method = <span class="keyword">lambda</span>: <span class="string">'PUT'</span> <span class="comment"># or 'DELETE'</span></div><div class="line">response = urllib2.urlopen(request)</div></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      urllib库的高级使用
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫实战之爬取糗事百科段子</title>
    <link href="https://blog.devzou.com/2018/10/16/python/2017-03-16-Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%E6%AE%B5%E5%AD%90/"/>
    <id>https://blog.devzou.com/2018/10/16/python/2017-03-16-Python爬虫实战之爬取糗事百科段子/</id>
    <published>2018-10-16T00:10:09.000Z</published>
    <updated>2019-04-24T06:59:24.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="确定URL并抓取页面代码"><a href="#确定URL并抓取页面代码" class="headerlink" title="确定URL并抓取页面代码"></a>确定URL并抓取页面代码</h2><p>首先我们确定好页面的URL是 <a href="http://www.qiushibaike.com/hot/page/1，其中最后一个数字1代表页数，我们可以传入不同的值来获得某一页的段子内容。" target="_blank" rel="external">http://www.qiushibaike.com/hot/page/1，其中最后一个数字1代表页数，我们可以传入不同的值来获得某一页的段子内容。</a></p><p>我们初步构建如下的代码来打印页面代码内容试试看，先构造最基本的页面抓取方式，看看会不会成功<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">page = <span class="number">1</span></div><div class="line">url = <span class="string">'http://www.qiushibaike.com/hot/page/'</span> + str(page)</div><div class="line">user_agent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span></div><div class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    request = urllib2.Request(url,headers = headers)</div><div class="line">    response = urllib2.urlopen(request)</div><div class="line">    <span class="keyword">print</span> response.read()</div><div class="line"><span class="keyword">except</span> urllib2.URLError, e:</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"code"</span>):</div><div class="line">        <span class="keyword">print</span> e.code</div><div class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"reason"</span>):</div><div class="line">        <span class="keyword">print</span> e.reason</div></pre></td></tr></table></figure></p><h2 id="提取某一页的所有段子"><a href="#提取某一页的所有段子" class="headerlink" title="提取某一页的所有段子"></a>提取某一页的所有段子</h2><p>好，获取了HTML代码之后，我们开始分析怎样获取某一页的所有段子。</p><p>首先我们审查元素看一下，按浏览器的F12，截图如下</p><p>我们可以看到，每一个段子都是<div class="”article" block="" untagged="" mb15″="" id="”…”">…</div>包裹的内容。</p><p>现在我们想获取发布人，发布日期，段子内容，以及点赞的个数。不过另外注意的是，段子有些是带图片的，如果我们想在控制台显示图片是不现实的，所以我们直接把带有图片的段子给它剔除掉，只保存仅含文本的段子。</p><p>所以我们加入如下正则表达式来匹配一下，用到的方法是 re.findall 是找寻所有匹配的内容。方法的用法详情可以看前面说的正则表达式的介绍。</p><p>好，我们的正则表达式匹配语句书写如下，在原来的基础上追加如下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">content = response.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">pattern = re.compile(<span class="string">'&lt;div.*?author"&gt;.*?&lt;a.*?&lt;img.*?&gt;(.*?)&lt;/a&gt;.*?&lt;div.*?'</span>+</div><div class="line">                         <span class="string">'content"&gt;(.*?)&lt;!--(.*?)--&gt;.*?&lt;/div&gt;(.*?)&lt;div class="stats.*?class="number"&gt;(.*?)&lt;/i&gt;'</span>,re.S)</div><div class="line">items = re.findall(pattern,content)</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">    <span class="keyword">print</span> item[<span class="number">0</span>],item[<span class="number">1</span>],item[<span class="number">2</span>],item[<span class="number">3</span>],item[<span class="number">4</span>]</div></pre></td></tr></table></figure></p><p>现在正则表达式在这里稍作说明</p><p>1）.<em>? 是一个固定的搭配，.和</em>代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配，以后我们还会大量用到 .*? 的搭配。</p><p>2）(.<em>?)代表一个分组，在这个正则表达式中我们匹配了五个分组，在后面的遍历item中，item[0]就代表第一个(.</em>?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。</p><p>3）re.S 标志代表在匹配时为点任意匹配模式，点 . 也可以代表换行符。</p><p>这样我们就获取了发布人，发布时间，发布内容，附加图片以及点赞数。</p><p>在这里注意一下，我们要获取的内容如果是带有图片，直接输出出来比较繁琐，所以这里我们只获取不带图片的段子就好了。</p><p>所以，在这里我们就需要对带图片的段子进行过滤。</p><p>我们可以发现，带有图片的段子会带有类似下面的代码，而不带图片的则没有，所以，我们的正则表达式的item[3]就是获取了下面的内容，如果不带图片，item[3]获取的内容便是空。</p>]]></content>
    
    <summary type="html">
    
      抓取糗事百科上面的段子
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python高级编程之正则表达式</title>
    <link href="https://blog.devzou.com/2018/09/18/python/2017-03-18-python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blog.devzou.com/2018/09/18/python/2017-03-18-python高级编程之正则表达式/</id>
    <published>2018-09-18T00:10:09.000Z</published>
    <updated>2019-04-24T06:59:35.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-Re模块"><a href="#Python-Re模块" class="headerlink" title="Python Re模块"></a>Python Re模块</h2><p>Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#返回pattern对象</span></div><div class="line">re.compile(string[,flag])  </div><div class="line"><span class="comment">#以下为匹配所用函数</span></div><div class="line">re.match(pattern, string[, flags])</div><div class="line">re.search(pattern, string[, flags])</div><div class="line">re.split(pattern, string[, maxsplit])</div><div class="line">re.findall(pattern, string[, flags])</div><div class="line">re.finditer(pattern, string[, flags])</div><div class="line">re.sub(pattern, repl, string[, count])</div><div class="line">re.subn(pattern, repl, string[, count])</div></pre></td></tr></table></figure></p><p>在介绍这几个方法之前，我们先来介绍一下pattern的概念，pattern可以理解为一个匹配模式，那么我们怎么获得这个匹配模式呢？很简单，我们需要利用re.compile方法就可以。例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pattern = re.compile(<span class="string">r'hello'</span>)</div></pre></td></tr></table></figure></p><p>在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配。</p><p>另外大家可能注意到了另一个参数 flags，在这里解释一下这个参数的含义：</p><p>参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。</p><p>可选值有：<br> • re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）<br> • re.M(全拼：MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）<br> • re.S(全拼：DOTALL): 点任意匹配模式，改变’.’的行为<br> • re.L(全拼：LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定<br> • re.U(全拼：UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性<br> • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。<br><strong> re.match(pattern, string[, flags])</strong><br>这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败，否则匹配pattern成功，同时匹配终止，不再对string向后匹配。下面我们通过一个例子理解一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">__author__ = <span class="string">'CQC'</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment">#导入re模块</span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment"># 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串”</span></div><div class="line">pattern = re.compile(<span class="string">r'hello'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 使用re.match匹配文本，获得匹配结果，无法匹配时将返回None</span></div><div class="line">result1 = re.match(pattern,<span class="string">'hello'</span>)</div><div class="line">result2 = re.match(pattern,<span class="string">'helloo CQC!'</span>)</div><div class="line">result3 = re.match(pattern,<span class="string">'helo CQC!'</span>)</div><div class="line">result4 = re.match(pattern,<span class="string">'hello CQC!'</span>)</div><div class="line"></div><div class="line"><span class="comment">#如果1匹配成功</span></div><div class="line"><span class="keyword">if</span> result1:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> result1.group()</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'1匹配失败！'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如果2匹配成功</span></div><div class="line"><span class="keyword">if</span> result2:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> result2.group()</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'2匹配失败！'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如果3匹配成功</span></div><div class="line"><span class="keyword">if</span> result3:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> result3.group()</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'3匹配失败！'</span></div><div class="line"></div><div class="line"><span class="comment">#如果4匹配成功</span></div><div class="line"><span class="keyword">if</span> result4:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> result4.group()</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'4匹配失败！'</span></div></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hello</div><div class="line">hello</div><div class="line">3匹配失败！</div><div class="line">hello</div></pre></td></tr></table></figure></p><p>匹配分析<br>1.第一个匹配，pattern正则表达式为’hello’，我们匹配的目标字符串string也为hello，从头至尾完全匹配，匹配成功。<br>2.第二个匹配，string为helloo CQC，从string头开始匹配pattern完全可以匹配，pattern匹配结束，同时匹配终止，后面的o CQC不再匹配，返回匹配成功的信息。<br>3.第三个匹配，string为helo CQC，从string头开始匹配pattern，发现到 ‘o’ 时无法完成匹配，匹配终止，返回None<br>4.第四个匹配，同第二个匹配原理，即使遇到了空格符也不会受影响。<br>我们还看到最后打印出了result.group()，这个是什么意思呢？下面我们说一下关于match对象的的属性和方法<br>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。<br><strong>re.search(pattern, string[, flags])</strong><br>search方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。同样，search方法的返回对象同样match()返回对象的方法和属性。我们用一个例子感受一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#导入re模块</span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment"># 将正则表达式编译成Pattern对象</span></div><div class="line">pattern = re.compile(<span class="string">r'world'</span>)</div><div class="line"><span class="comment"># 使用search()查找匹配的子串，不存在能匹配的子串时将返回None</span></div><div class="line"><span class="comment"># 这个例子中使用match()无法成功匹配</span></div><div class="line">match = re.search(pattern,<span class="string">'hello world!'</span>)</div><div class="line"><span class="keyword">if</span> match:</div><div class="line">    <span class="comment"># 使用Match获得分组信息</span></div><div class="line">    <span class="keyword">print</span> match.group()</div><div class="line"><span class="comment">### 输出 ###</span></div><div class="line"><span class="comment"># world</span></div></pre></td></tr></table></figure></p><p><strong>re.split(pattern, string[, maxsplit])</strong><br>按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。我们通过下面的例子感受一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</div><div class="line"><span class="keyword">print</span> re.split(pattern,<span class="string">'one1two2three3four4'</span>)</div><div class="line"></div><div class="line"><span class="comment">### 输出 ###</span></div><div class="line"><span class="comment"># ['one', 'two', 'three', 'four', '']</span></div></pre></td></tr></table></figure></p><p><strong>re.findall(pattern, string[, flags])</strong></p><p>搜索string，以列表形式返回全部能匹配的子串。我们通过这个例子来感受一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</div><div class="line"><span class="keyword">print</span> re.findall(pattern,<span class="string">'one1two2three3four4'</span>)</div><div class="line"></div><div class="line"><span class="comment">### 输出 ###</span></div><div class="line"><span class="comment"># ['1', '2', '3', '4']</span></div></pre></td></tr></table></figure></p><p><strong>re.finditer(pattern, string[, flags])</strong></p><p>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。我们通过下面的例子来感受一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</div><div class="line"><span class="keyword">for</span> m <span class="keyword">in</span> re.finditer(pattern,<span class="string">'one1two2three3four4'</span>):</div><div class="line">    <span class="keyword">print</span> m.group(),</div><div class="line"></div><div class="line"><span class="comment">### 输出 ###</span></div><div class="line"><span class="comment"># 1 2 3 4</span></div></pre></td></tr></table></figure></p><p><strong>re.sub(pattern, repl, string[, count])</strong></p><p>使用repl替换string中每一个匹配的子串后返回替换后的字符串。<br>当repl是一个字符串时，可以使用\id或\g、\g引用分组，但不能使用编号0。<br>当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。<br>count用于指定最多替换次数，不指定时全部替换。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">pattern = re.compile(<span class="string">r'(\w+) (\w+)'</span>)</div><div class="line">s = <span class="string">'i say, hello world!'</span></div><div class="line"><span class="keyword">print</span> re.sub(pattern,<span class="string">r'\2 \1'</span>, s)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(m)</span>:</span></div><div class="line">    <span class="keyword">return</span> m.group(<span class="number">1</span>).title() + <span class="string">' '</span> + m.group(<span class="number">2</span>).title()</div><div class="line"><span class="keyword">print</span> re.sub(pattern,func, s)</div><div class="line"><span class="comment">### output ###</span></div><div class="line"><span class="comment"># say i, world hello!</span></div><div class="line"><span class="comment"># I Say, Hello World!</span></div></pre></td></tr></table></figure></p><p><strong>re.subn(pattern, repl, string[, count])</strong><br>返回 (sub(repl, string[, count]), 替换次数)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">pattern = re.compile(<span class="string">r'(\w+) (\w+)'</span>)</div><div class="line">s = <span class="string">'i say, hello world!'</span></div><div class="line"><span class="keyword">print</span> re.subn(pattern,<span class="string">r'\2 \1'</span>, s) </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(m)</span>:</span></div><div class="line">    <span class="keyword">return</span> m.group(<span class="number">1</span>).title() + <span class="string">' '</span> + m.group(<span class="number">2</span>).title() </div><div class="line"><span class="keyword">print</span> re.subn(pattern,func, s)</div><div class="line"> </div><div class="line"><span class="comment">### output ###</span></div><div class="line"><span class="comment"># ('say i, world hello!', 2)</span></div><div class="line"><span class="comment"># ('I Say, Hello World!', 2)</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy入门教程</title>
    <link href="https://blog.devzou.com/2018/08/19/python/2017-03-19-scrapy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.devzou.com/2018/08/19/python/2017-03-19-scrapy入门教程/</id>
    <published>2018-08-19T00:10:09.000Z</published>
    <updated>2019-04-24T06:58:17.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个scrapy项目"><a href="#创建一个scrapy项目" class="headerlink" title="创建一个scrapy项目"></a>创建一个scrapy项目</h2><p>在开始爬取之前，您必须创建一个新的Scrapy项目。 进入您打算存储代码的目录中，运行下列命令:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject  scrapyProject</div></pre></td></tr></table></figure></p><p>该命令将会创建包含下列内容的 scrapyProject 目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">scrapyProject/</div><div class="line">    scrapy.cfg</div><div class="line">    scrapyProject/</div><div class="line">        __init__.py</div><div class="line">        items.py</div><div class="line">        pipelines.py</div><div class="line">        settings.py</div><div class="line">        spiders/</div><div class="line">            __init__.py</div><div class="line">            ...</div></pre></td></tr></table></figure></p><p>这些文件分别是:</p><p>scrapy.cfg: 项目的配置文件<br>scrapyProject/: 该项目的python模块。之后您将在此加入代码。<br>scrapyProject/items.py: 项目中的item文件.<br>scrapyProject/pipelines.py: 项目中的pipelines文件.<br>scrapyProject/settings.py: 项目的设置文件.<br>scrapyProject/spiders/: 放置spider代码的目录.</p><h2 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h2><p>Item 是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。</p><p>类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field 的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单)</p><p>首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 scrapyProject 目录中的 items.py 文件:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozItem</span><span class="params">(scrapy.Item)</span>:</span></div><div class="line">    title = scrapy.Field()</div><div class="line">    link = scrapy.Field()</div><div class="line">    desc = scrapy.Field()</div></pre></td></tr></table></figure></p><p>一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义。</p><h2 id="编写第一个爬虫-Spider"><a href="#编写第一个爬虫-Spider" class="headerlink" title="编写第一个爬虫(Spider)"></a>编写第一个爬虫(Spider)</h2><p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。<br>其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。<br>为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:<br>name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。<br>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。<br>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。<br>以下为我们的第一个Spider代码，保存在 scrapyProject/spiders 目录下的 dmoz_spider.py 文件中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">"dmoz"</span></div><div class="line">    allowed_domains = [<span class="string">"dmoz.org"</span>]</div><div class="line">    start_urls = [</div><div class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Books/"</span>,</div><div class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        filename = response.url.split(<span class="string">"/"</span>)[<span class="number">-2</span>]</div><div class="line">        <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(response.body)</div></pre></td></tr></table></figure></p><h2 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h2><p>进入项目的根目录，执行下列命令启动spider:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy crawl dmoz</div></pre></td></tr></table></figure></p><h2 id="提取Item"><a href="#提取Item" class="headerlink" title="提取Item"></a>提取Item</h2><h3 id="Selectors选择器简介"><a href="#Selectors选择器简介" class="headerlink" title="Selectors选择器简介"></a>Selectors选择器简介</h3><p>从网页中提取数据有很多方法。Scrapy使用了一种基于 <a href="https://www.w3.org/TR/xpath/" target="_blank" rel="external">XPath</a>和<a href="https://www.w3.org/TR/selectors/" target="_blank" rel="external">CSS</a> 表达式机制: Scrapy Selectors 。 关于selector和其他提取机制的信息请参考 Selector文档 。<br>这里给出XPath表达式的例子及对应的含义:</p><p>/html/head/title: 选择HTML文档中 <head> 标签内的 <title> 元素<br>/html/head/title/text(): 选择上面提到的 <title> 元素的文字<br>//td: 选择所有的 <td> 元素<br>//div[@class=”mine”]: 选择所有具有 class=”mine” 属性的 div 元素<br>上边仅仅是几个简单的XPath例子，XPath实际上要比这远远强大的多。<br>为了配合XPath，Scrapy除了提供了 Selector 之外，还提供了方法来避免每次从response中提取数据时生成selector的麻烦。<br>Selector有四个基本的方法(点击相应的方法可以看到详细的API文档):<br>xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。<br>css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表.<br>extract(): 序列化该节点为unicode字符串并返回list。<br>re(): 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。</td></title></title></head></p><h3 id="在Shell中尝试Selector选择器"><a href="#在Shell中尝试Selector选择器" class="headerlink" title="在Shell中尝试Selector选择器"></a>在Shell中尝试Selector选择器</h3><p>为了介绍Selector的使用方法，接下来我们将要使用内置的 Scrapy shell 。Scrapy Shell需要您预装好IPython(一个扩展的Python终端)。</p><p>您需要进入项目的根目录，执行下列命令来启动shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy shell &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      初级的爬虫我们利用urllib和urllib2库以及正则表达式就可以完成了，不过还有更加强大的工具，爬虫框架Scrapy
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础教程之文件I/O</title>
    <link href="https://blog.devzou.com/2018/08/15/python/2017-03-15-Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6I:O/"/>
    <id>https://blog.devzou.com/2018/08/15/python/2017-03-15-Python基础教程之文件I:O/</id>
    <published>2018-08-15T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:20.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打印到屏幕"><a href="#打印到屏幕" class="headerlink" title="打印到屏幕"></a>打印到屏幕</h2><p>最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Python 是一个非常棒的语言，不是吗？"</span>;</div></pre></td></tr></table></figure></p><p>你的标准屏幕上会产生以下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Python 是一个非常棒的语言，不是吗？</div></pre></td></tr></table></figure></p><h2 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h2><p>Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：<br>raw_input<br>input<br><strong>raw_input函数</strong><br>raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"> </div><div class="line">str = raw_input(<span class="string">"请输入："</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"你输入的内容是: "</span>, str</div></pre></td></tr></table></figure></p><p>这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入”Hello Python！”，它的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入：Hello Python！</div><div class="line">你输入的内容是:  Hello Python！</div></pre></td></tr></table></figure></p><p><strong>input函数</strong><br>input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"> </div><div class="line">str = input(<span class="string">"请输入："</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"你输入的内容是: "</span>, str</div></pre></td></tr></table></figure></p><p>这会产生如下的对应着输入的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入：[x*5 for x in range(2,10,2)]</div><div class="line">你输入的内容是:  [10, 20, 30, 40]</div></pre></td></tr></table></figure></p><h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。<br>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。<br><strong>open 函数</strong><br>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file object = open(file_name [, access_mode][, buffering])</div></pre></td></tr></table></figure></p><p>各个参数的细节如下：<br><strong>file_name：</strong>file_name变量是一个包含了你要访问的文件名称的字符串值。<br>access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。<br><strong>buffering:</strong>如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。<br>不同模式打开文件的完全列表：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td></tr></tbody></table><div>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</div><p> |<br>| rb |  </p><div>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</div><p> |<br>| r+ |  </p><div>打开一个文件用于读写。文件指针将会放在文件的开头。</div><p> |<br>| rb+ |  </p><div>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</div><p> |<br>| w |  </p><div>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><p> |<br>| wb |  </p><div>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><p> |<br>| w+ |  </p><div>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><p> |<br>| wb+ |  </p><div>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><p> |<br>| a |  </p><div>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</div><p> |<br>| ab |  </p><div>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</div><p> |<br>| a+ |  </p><div>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</div><p> |<br>| ab+ |  </p><div>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</div><p> |</p><h2 id="File对象的属性"><a href="#File对象的属性" class="headerlink" title="File对象的属性"></a>File对象的属性</h2><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。<br>以下是和file对象相关的所有属性的列表：<br>| 属性 | 描述 |<br>| — | — |<br>| file.closed |  </p><div>返回true如果文件已被关闭，否则返回false。</div><p> |<br>| file.mode<span class="Apple-tab-span" style="white-space:pre"></span> |  </p><div>返回被打开文件的访问模式。</div><p> |<br>| file.name |  </p><div>返回文件的名称。</div><p> |<br>| file.softspace |  </p><div>如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</div><p> |<br>如下实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"文件名: "</span>, fo.name</div><div class="line"><span class="keyword">print</span> <span class="string">"是否已关闭 : "</span>, fo.closed</div><div class="line"><span class="keyword">print</span> <span class="string">"访问模式 : "</span>, fo.mode</div><div class="line"><span class="keyword">print</span> <span class="string">"末尾是否强制加空格 : "</span>, fo.softspace</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">文件名:  foo.txt</div><div class="line">是否已关闭 :  False</div><div class="line">访问模式 :  wb</div><div class="line">末尾是否强制加空格 :  0</div></pre></td></tr></table></figure></p><p><strong>close()方法</strong><br>File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。<br>当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fileObject.close();</div></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"文件名: "</span>, fo.name</div><div class="line"> </div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">文件名:  foo.txt</div></pre></td></tr></table></figure></p><p>读写文件：<br>file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。<br><strong>write()方法</strong><br>write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。<br>write()方法不会在字符串的结尾添加换行符(‘\n’)：<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fileObject.write(string);</div></pre></td></tr></table></figure></p><p>在这里，被传递的参数是要写入到已打开文件的内容。<br>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line">fo.write( <span class="string">"www.lianyucode.top!\nVery good site!\n"</span>);</div><div class="line"> </div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p><p>上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat foo.txt </div><div class="line">www.lianyucode.top!</div><div class="line">Very good site!</div></pre></td></tr></table></figure><p><strong>read()方法</strong><br>read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fileObject.read([count]);</div></pre></td></tr></table></figure></p><p>在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。<br>例子：<br>这里我们用到以上创建的 foo.txt 文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">读取的字符串是 :  www.lianyucode.top</div></pre></td></tr></table></figure></p><h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p>tell()方法告诉你文件内的当前位置；换句话说，下一次的读写会发生在文件开头这么多字节之后。<br>seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。<br>如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。<br>例子：<br>就用我们上面创建的文件foo.txt。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</div><div class="line"> </div><div class="line"><span class="comment"># 查找当前位置</span></div><div class="line">position = fo.tell();</div><div class="line"><span class="keyword">print</span> <span class="string">"当前文件位置 : "</span>, position</div><div class="line"> </div><div class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></div><div class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"重新读取字符串 : "</span>, str</div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">读取的字符串是 :  www.runoob</div><div class="line">当前文件位置 :  10</div><div class="line">重新读取字符串 :  www.runoob</div></pre></td></tr></table></figure></p><h2 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h2><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。<br>要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。<br>rename()方法：<br>rename()方法需要两个参数，当前的文件名和新文件名。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.rename(current_file_name, new_file_name)</div></pre></td></tr></table></figure></p><p>例子：<br>下例将重命名一个已经存在的文件test1.txt。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 重命名文件test1.txt到test2.txt。</span></div><div class="line">os.rename( <span class="string">"test1.txt"</span>, <span class="string">"test2.txt"</span> )</div></pre></td></tr></table></figure></p><p><strong>remove()方法</strong><br>你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.remove(file_name)</div></pre></td></tr></table></figure></p><p>例子：<br>下例将删除一个已经存在的文件test2.txt。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 删除一个已经存在的文件test2.txt</span></div><div class="line">os.remove(<span class="string">"test2.txt"</span>)</div></pre></td></tr></table></figure></p><h2 id="Python里的目录："><a href="#Python里的目录：" class="headerlink" title="Python里的目录："></a>Python里的目录：</h2><p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。<br>mkdir()方法<br>可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.mkdir(<span class="string">"newdir"</span>)</div></pre></td></tr></table></figure></p><p>例子：<br>下例将在当前目录下创建一个新目录test。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 创建目录test</span></div><div class="line">os.mkdir(<span class="string">"test"</span>)</div></pre></td></tr></table></figure></p><p><strong>chdir()方法</strong><br>可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.chdir(<span class="string">"newdir"</span>)</div></pre></td></tr></table></figure></p><p>例子：<br>下例将进入”/home/newdir”目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 将当前目录改为"/home/newdir"</span></div><div class="line">os.chdir(<span class="string">"/home/newdir"</span>)</div></pre></td></tr></table></figure></p><p><strong>getcwd()方法：</strong><br>getcwd()方法显示当前的工作目录。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.getcwd()</div></pre></td></tr></table></figure></p><p>例子：<br>下例给出当前目录：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 给出当前的目录</span></div><div class="line"><span class="keyword">print</span> os.getcwd()</div></pre></td></tr></table></figure></p><p><strong>rmdir()方法</strong><br>rmdir()方法删除目录，目录名称以参数传递。<br>在删除这个目录之前，它的所有内容应该先被清除。<br>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.rmdir(<span class="string">'dirname'</span>)</div></pre></td></tr></table></figure></p><p>例子：<br>以下是删除” /tmp/test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="comment"># 删除”/tmp/test”目录</span></div><div class="line">os.rmdir( <span class="string">"/tmp/test"</span>  )</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      本章只讲述所有基本的的I/O函数，更多函数请参考Python标准文档。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之策略模式</title>
    <link href="https://blog.devzou.com/2018/08/05/ios/2018-07-21-iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.devzou.com/2018/08/05/ios/2018-07-21-iOS设计模式之策略模式/</id>
    <published>2018-08-04T23:10:09.000Z</published>
    <updated>2019-03-02T07:02:45.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><ol><li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。</li><li>在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。<a id="more"></a></li><li>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</li><li>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</li><li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2>策略模式包含如下角色：</li></ol><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类<br><img src="" alt=""><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2></li></ul><ol><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2></li></ol><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li><p>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>策略模式与状态模式</p></li><li><p>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</p></li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。<h2 id="优点-amp-amp-缺点"><a href="#优点-amp-amp-缺点" class="headerlink" title="优点&amp;&amp;缺点"></a>优点&amp;&amp;缺点</h2><h3 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h3></li></ul><ol><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。<h3 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h3></li></ol><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<br>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模式动机&quot;&gt;&lt;a href=&quot;#模式动机&quot; class=&quot;headerlink&quot; title=&quot;模式动机&quot;&gt;&lt;/a&gt;模式动机&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。&lt;/li&gt;
&lt;li&gt;在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="https://blog.devzou.com/2018/08/05/ios/2018-08-12-iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://blog.devzou.com/2018/08/05/ios/2018-08-12-iOS面试题/</id>
    <published>2018-08-04T23:10:09.000Z</published>
    <updated>2019-03-02T12:41:08.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个NSObject对象占用多少内存"><a href="#一个NSObject对象占用多少内存" class="headerlink" title="一个NSObject对象占用多少内存"></a>一个NSObject对象占用多少内存</h2><p>系统分配了16个字节给NSObject对象<br>但NSObject对象内部只使用了8个字节的空间(64bit环境下)</p><h2 id="对象的isa指针指向哪里"><a href="#对象的isa指针指向哪里" class="headerlink" title="对象的isa指针指向哪里"></a>对象的isa指针指向哪里</h2><p>instance对象的isa指向class<br>当调用对象方法时，通过instance对象的isa找到class 对象，最后找到对象方法的实现进行调用<br>class 的isa指向meta-class<br>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用<br>meta-class的isa指向基类的meta-class对象</p><h2 id="OC的类信息存放在哪里"><a href="#OC的类信息存放在哪里" class="headerlink" title="OC的类信息存放在哪里"></a>OC的类信息存放在哪里</h2><p>对象方法、属性、成员变量、协议信息，存放在class对象中<br>类方法，存放在meta-class对象中<br>成员变量的具体值，存放在instance对象中</p><h2 id="iOS用什么方式实现对一个对象的KVO-KVO的本质是什么"><a href="#iOS用什么方式实现对一个对象的KVO-KVO的本质是什么" class="headerlink" title="iOS用什么方式实现对一个对象的KVO?(KVO的本质是什么)"></a>iOS用什么方式实现对一个对象的KVO?(KVO的本质是什么)</h2><p>利用runtimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类<br>当修改instance对象的属性时，会调用Foundation的_NSSetXXXXValueAndNotify函数<br>willChangeValueForKey:<br>父类原来的setter方法<br>didChangeValueForKey:<br>内部会触发监听器(Observer)的监听方法(oberserveValueForKeyPath:ofObject:change:context:)</p><h2 id="如何手动触发KVO"><a href="#如何手动触发KVO" class="headerlink" title="如何手动触发KVO"></a>如何手动触发KVO</h2><p>手动调用willChangeValueForKey和didChangeValueForKey</p><h2 id="直接修改成员变量会触发KVO吗"><a href="#直接修改成员变量会触发KVO吗" class="headerlink" title="直接修改成员变量会触发KVO吗"></a>直接修改成员变量会触发KVO吗</h2><p>不会</p><h2 id="通过KVC修改属性的值，会触发KVO吗"><a href="#通过KVC修改属性的值，会触发KVO吗" class="headerlink" title="通过KVC修改属性的值，会触发KVO吗"></a>通过KVC修改属性的值，会触发KVO吗</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一个NSObject对象占用多少内存&quot;&gt;&lt;a href=&quot;#一个NSObject对象占用多少内存&quot; class=&quot;headerlink&quot; title=&quot;一个NSObject对象占用多少内存&quot;&gt;&lt;/a&gt;一个NSObject对象占用多少内存&lt;/h2&gt;&lt;p&gt;系统分配了1
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之KVC底层原理</title>
    <link href="https://blog.devzou.com/2018/08/05/ios/2018-08-22-KVC/"/>
    <id>https://blog.devzou.com/2018/08/05/ios/2018-08-22-KVC/</id>
    <published>2018-08-04T23:10:09.000Z</published>
    <updated>2019-03-02T07:02:45.140Z</updated>
    
    <content type="html"><![CDATA[<p>KVC的全称是Key-Value Coding 俗称键值编码，可以通过一个key来访问某个属性<br>常见的API有</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)keyPath</div><div class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;KVC的全称是Key-Value Coding 俗称键值编码，可以通过一个key来访问某个属性&lt;br&gt;常见的API有&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div cla
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之Category</title>
    <link href="https://blog.devzou.com/2018/08/05/ios/2018-08-23-Category/"/>
    <id>https://blog.devzou.com/2018/08/05/ios/2018-08-23-Category/</id>
    <published>2018-08-04T23:10:09.000Z</published>
    <updated>2019-03-02T07:02:45.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Category实现原理"><a href="#Category实现原理" class="headerlink" title="Category实现原理"></a>Category实现原理</h2><h3 id="category的结构"><a href="#category的结构" class="headerlink" title="category的结构"></a>category的结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct category_t &#123;</div><div class="line">    const char *name;</div><div class="line">    classref_t cls;</div><div class="line">    struct method_list_t *instanceMethods;</div><div class="line">    struct method_list_t *classMethods;</div><div class="line">    struct protocol_list_t *protocols;</div><div class="line">    struct property_list_t *instanceProperties;</div><div class="line">    // Fields below this point are not always present on disk.</div><div class="line">    struct property_list_t *_classProperties;</div><div class="line"></div><div class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</div><div class="line">        if (isMeta) return classMethods;</div><div class="line">        else return instanceMethods;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Category实现原理&quot;&gt;&lt;a href=&quot;#Category实现原理&quot; class=&quot;headerlink&quot; title=&quot;Category实现原理&quot;&gt;&lt;/a&gt;Category实现原理&lt;/h2&gt;&lt;h3 id=&quot;category的结构&quot;&gt;&lt;a href=&quot;#ca
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>clang常用命令</title>
    <link href="https://blog.devzou.com/2018/08/04/ios/2018-08-12/"/>
    <id>https://blog.devzou.com/2018/08/04/ios/2018-08-12/</id>
    <published>2018-08-03T23:10:09.000Z</published>
    <updated>2019-03-02T12:41:12.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将OC代码转化为C-C-代码"><a href="#将OC代码转化为C-C-代码" class="headerlink" title="将OC代码转化为C/C++代码"></a>将OC代码转化为C/C++代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc xxxx.m -o xxxx.cpp</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的cpp文件</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;将OC代码转化为C-C-代码&quot;&gt;&lt;a href=&quot;#将OC代码转化为C-C-代码&quot; class=&quot;headerlink&quot; title=&quot;将OC代码转化为C/C++代码&quot;&gt;&lt;/a&gt;将OC代码转化为C/C++代码&lt;/h2&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理之OC对象本质</title>
    <link href="https://blog.devzou.com/2018/07/31/ios/2018-08-12-iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B9%8BOC%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/"/>
    <id>https://blog.devzou.com/2018/07/31/ios/2018-08-12-iOS底层原理之OC对象本质/</id>
    <published>2018-07-30T23:10:09.000Z</published>
    <updated>2019-03-02T12:41:25.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h2><p>我们平时编写的Object-C代码，底层都是C/C++代码，所以Objective-C的面向对象都是基于C/C++的数据结构实现的<br>【注】Objective-C的对象、类主要是基于C/C++的结构体实现的</p><h3 id="NSObject的底层实现"><a href="#NSObject的底层实现" class="headerlink" title="NSObject的底层实现"></a>NSObject的底层实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span>  <span class="title">NSObjec</span> </span>&#123;</div><div class="line">  Class isa;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C语言实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct NSObject_IMPL &#123;</div><div class="line">Class isa;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="OC对象的本质"><a href="#OC对象的本质" class="headerlink" title="OC对象的本质"></a>OC对象的本质</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Objective-C的本质&quot;&gt;&lt;a href=&quot;#Objective-C的本质&quot; class=&quot;headerlink&quot; title=&quot;Objective-C的本质&quot;&gt;&lt;/a&gt;Objective-C的本质&lt;/h2&gt;&lt;p&gt;我们平时编写的Object-C代码，底层都是
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之建造者模式</title>
    <link href="https://blog.devzou.com/2018/07/31/ios/2018-07-31-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.devzou.com/2018/07/31/ios/2018-07-31-设计模式之建造者模式/</id>
    <published>2018-07-30T23:10:09.000Z</published>
    <updated>2019-04-22T14:00:59.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>建造者模式包含如下角色：</p><ul><li>Builder：抽象建造者，为创建一个产品对象的各个部件指定抽象接口</li><li>ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并 提供一个检索产品的接口</li><li>Director：构造一个使用Builder接口的对象</li><li>Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口<h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2>抽象建造者类中定义了产品的创建方法和返回方法;</li></ul><p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><ul><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li><p>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。<br>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用建造者模式：</p></li><li><p>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</p></li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li><p>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>建造者模式的简化:</p></li><li><p>省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。</p></li><li>省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让</li><li>Builder角色扮演指挥者与建造者双重角色。</li></ul><p>建造者模式与抽象工厂模式的比较:</p><ul><li>与抽象工厂模式相比， 建造者模式返回一个组装好的完整产品 ，而 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成 汽车配件生产工厂 ，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式动机&quot;&gt;&lt;a href=&quot;#模式动机&quot; class=&quot;headerlink&quot; title=&quot;模式动机&quot;&gt;&lt;/a&gt;模式动机&lt;/h2&gt;&lt;p&gt;无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之简单工厂模式</title>
    <link href="https://blog.devzou.com/2018/07/30/ios/2018-07-22-iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.devzou.com/2018/07/30/ios/2018-07-22-iOS设计模式之工厂模式/</id>
    <published>2018-07-29T23:10:09.000Z</published>
    <updated>2019-03-02T07:02:45.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>简单工厂模式包含如下角色：<br><strong>Factory：工厂角色</strong><br>    工厂角色负责实现创建所有实例的内部逻辑<br><strong>Product：抽象产品角色</strong><br>    抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口<br><strong>ConcreteProduct：具体产品角色</strong><br>    具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。<br><img src="" alt=""></p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li><li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li><li>简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式动机&quot;&gt;&lt;a href=&quot;#模式动机&quot; class=&quot;headerlink&quot; title=&quot;模式动机&quot;&gt;&lt;/a&gt;模式动机&lt;/h2&gt;&lt;p&gt;考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.devzou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.devzou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础教程之模块</title>
    <link href="https://blog.devzou.com/2018/07/12/python/2017-03-12-python%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E5%9D%97(module)/"/>
    <id>https://blog.devzou.com/2018/07/12/python/2017-03-12-python基本教程之模块(module)/</id>
    <published>2018-07-12T00:10:09.000Z</published>
    <updated>2019-04-24T06:59:51.475Z</updated>
    
    <content type="html"><![CDATA[<p>下例是个简单的模块 support.py：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">( par )</span>:</span></div><div class="line">   <span class="keyword">print</span> <span class="string">"Hello : "</span>, par</div><div class="line">   <span class="keyword">return</span></div></pre></td></tr></table></figure></p><h2 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h2><p>模块的引入<br>模块定义好后，我们可以使用 import 语句来引入模块，语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]</div></pre></td></tr></table></figure></p><p>比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">模块名.函数名</div></pre></td></tr></table></figure></p><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。<br>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 导入模块</span></div><div class="line"><span class="keyword">import</span> support</div><div class="line"> </div><div class="line"><span class="comment"># 现在可以调用模块里包含的函数了</span></div><div class="line">support.print_func(<span class="string">"Python"</span>)</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello : Python</div></pre></td></tr></table></figure></p><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p><h2 id="From…import-语句"><a href="#From…import-语句" class="headerlink" title="From…import 语句"></a>From…import 语句</h2><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</div></pre></td></tr></table></figure></p><p>例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> fib <span class="keyword">import</span> fibonacci</div></pre></td></tr></table></figure></p><p>这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。</p><h2 id="From…import-语句-1"><a href="#From…import-语句-1" class="headerlink" title="From…import* 语句"></a>From…import* 语句</h2><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</div></pre></td></tr></table></figure></p><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。<br>例如我们想一次性引入 math 模块中所有的东西，语句如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</div></pre></td></tr></table></figure></p><h2 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h2><p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：<br>1、当前目录<br>2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。<br>3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。<br>模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</p><h2 id="PYTHONPATH-变量"><a href="#PYTHONPATH-变量" class="headerlink" title="PYTHONPATH 变量"></a>PYTHONPATH 变量</h2><p>作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。<br>在 Windows 系统，典型的 PYTHONPATH 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set PYTHONPATH=c:\python27\lib;</div></pre></td></tr></table></figure></p><p>在 UNIX 系统，典型的 PYTHONPATH 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set PYTHONPATH=/usr/local/lib/python</div></pre></td></tr></table></figure></p><h2 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h2><p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。<br>一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。<br>每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。<br>Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。<br>因此，如果要给全局变量在一个函数里赋值，必须使用 global 语句。<br>global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。<br>例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句的注释就能解决这个问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line">Money = <span class="number">2000</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddMoney</span><span class="params">()</span>:</span></div><div class="line">   <span class="comment"># 想改正代码就取消以下注释:</span></div><div class="line">   <span class="comment"># global Money</span></div><div class="line">   Money = Money + <span class="number">1</span></div><div class="line"> </div><div class="line"><span class="keyword">print</span> Money</div><div class="line">AddMoney()</div><div class="line"><span class="keyword">print</span> Money</div></pre></td></tr></table></figure></p><h2 id="Python中的包"><a href="#Python中的包" class="headerlink" title="Python中的包"></a>Python中的包</h2><p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。<br>简单来说，包就是文件夹，但该文件夹下必须存在 <strong>init</strong>.py 文件, 该文件的内容可以为空。<strong>int</strong>.py用于标识当前文件夹是一个包。<br>考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、<strong>init</strong>.py 文件，test.py 为测试调用包的代码，目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test.py</div><div class="line">package_runoob</div><div class="line">|-- __init__.py</div><div class="line">|-- runoob1.py</div><div class="line">|-- runoob2.py</div></pre></td></tr></table></figure></p><p>源代码如下：<br>package_runoob/runoob1.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runoob1</span><span class="params">()</span>:</span></div><div class="line">   <span class="keyword">print</span> <span class="string">"I'm in runoob1"</span></div></pre></td></tr></table></figure></p><p>package_runoob/runoob2.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runoob2</span><span class="params">()</span>:</span></div><div class="line">   <span class="keyword">print</span> <span class="string">"I'm in runoob2"</span></div></pre></td></tr></table></figure></p><p>现在，在 package_runoob 目录下创建 <strong>init</strong>.py：<br>package_runoob/<strong>init</strong>.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'作为主程序运行'</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'package_runoob 初始化'</span></div></pre></td></tr></table></figure></p><p>然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包<br>test.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="comment"># 导入 Phone 包</span></div><div class="line"><span class="keyword">from</span> package_runoob.runoob1 <span class="keyword">import</span> runoob1</div><div class="line"><span class="keyword">from</span> package_runoob.runoob2 <span class="keyword">import</span> runoob2</div><div class="line"> </div><div class="line">runoob1()</div><div class="line">runoob2()</div></pre></td></tr></table></figure></p><p>以上实例输出结果：<br>package_runoob 初始化<br>I’m in runoob1<br>I’m in runoob2<br>如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。</p>]]></content>
    
    <summary type="html">
    
      Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。模块能定义函数，类和变量，模块里也能包含可执行的代码。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础教程之基础语法</title>
    <link href="https://blog.devzou.com/2018/07/12/python/2017-03-12-Python%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://blog.devzou.com/2018/07/12/python/2017-03-12-Python 基础教程之基础语法/</id>
    <published>2018-07-12T00:10:09.000Z</published>
    <updated>2019-04-24T07:00:52.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python交互式编程"><a href="#python交互式编程" class="headerlink" title="python交互式编程"></a>python交互式编程</h2><p>交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码<br>mac上你只需要在命令行中输入 Python 命令即可启动交互式编程,提示窗口如下：<br><a href="http://okjl482qy.bkt.clouddn.com/python_01.png" target="_blank" rel="external">http://okjl482qy.bkt.clouddn.com/python_01.png</a><br>在 python 提示符中输入以下文本信息，然后按 Enter 键查看运行效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"Hello, Python!"</span>;</div></pre></td></tr></table></figure></p><p>在 Python 2.7.6 版本中,以上实例输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, Python!</div></pre></td></tr></table></figure></p><h2 id="脚本式编程"><a href="#脚本式编程" class="headerlink" title="脚本式编程"></a>脚本式编程</h2><p>通过脚本参数调用解释器开始执行脚本，直到脚本执行完毕。当脚本执行完成后，解释器不再有效。<br>让我们写一个简单的Python脚本程序。所有Python文件将以.py为扩展名。将以下的源代码拷贝至lesson1.py文件中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">"Hello, Python!"</span>;</div></pre></td></tr></table></figure></p><p>这里，假设你已经设置了Python解释器PATH变量。使用以下命令运行程序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python test.py</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, Python!</div></pre></td></tr></table></figure></p><p>让我们尝试另一种方式来执行Python脚本。修改lesson1.py文件，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello, Python!"</span>;</div></pre></td></tr></table></figure></p><p>这里，假定您的Python解释器在/usr/bin目录中，使用以下命令执行脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x lesson1.py     <span class="comment"># 脚本文件添加可执行权限</span></div><div class="line">./lesson1.py</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, Python!</div></pre></td></tr></table></figure></p><h2 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h2><p>在python里，标识符有字母、数字、下划线组成。<br>在python中，所有标识符可以包括英文、数字以及下划线（_），但不能以数字开头。<br>python中的标识符是区分大小写的。<br>以下划线开头的标识符是有特殊意义的。以单下划线开头（_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用”from xxx import *”而导入；<br>以双下划线开头的（<strong>foo）代表类的私有成员；以双下划线开头和结尾的（</strong>foo<strong>）代表python里特殊方法专用的标识，如</strong>init__（）代表类的构造函数。<br>| and | exec | not |<br>| — | — | — |<br>| assert | finally | or |<br>| break | for | pass |<br>| class | from | print |<br>| continue | global | raise |<br>| def | if | return |<br>| del | import | try |<br>| elif | in | while |<br>| else | is | with |<br>| except | lambda | yield |</p><h2 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h2><p>学习Python与其他语言最大的区别就是，Python的代码块不使用大括号（{}）来控制类，函数以及其他逻辑判断。python最具特色的就是用缩进来写模块。<br>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"True"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">"False"</span></div></pre></td></tr></table></figure></p><p>以下代码将会执行错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 文件名：lesson1.py</span></div><div class="line"></div><div class="line"> <span class="keyword">if</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Answer"</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"True"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Answer"</span></div><div class="line">    <span class="comment"># 没有严格缩进，在执行时会报错</span></div><div class="line">  <span class="keyword">print</span> <span class="string">"False"</span></div></pre></td></tr></table></figure></p><p>执行以上代码，会出现如下错误提醒：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">python lesson1.py  </div><div class="line">  File &quot;lesson1.py&quot;, line 5</div><div class="line">    if True:</div><div class="line">    ^</div><div class="line">IndentationError: unexpected indent</div></pre></td></tr></table></figure></p><p>IndentationError: unexpected indent 错误是python编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有python对格式要求非常严格。<br>如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。<br>因此，在Python的代码块中必须使用相同数目的行首缩进空格数。<br>建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用</p><h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python语句中一般以新行作为为语句的结束符。<br>但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">total = item_one + \</div><div class="line">        item_two + \</div><div class="line">        item_three</div></pre></td></tr></table></figure></p><p>语句中包含[], {} 或 () 括号就不需要使用多行连接符。如下实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">days = [<span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>,</div><div class="line">        <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>]</div></pre></td></tr></table></figure></p><h2 id="Python-引号"><a href="#Python-引号" class="headerlink" title="Python 引号"></a>Python 引号</h2><p>Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。<br>其中三引号可以由多行组成，编写多行文本的快捷语法，常用语文档字符串，在文件的特定地点，被当做注释。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">word = <span class="string">'word'</span></div><div class="line">sentence = <span class="string">"这是一个句子。"</span></div><div class="line">paragraph = <span class="string">"""这是一个段落。</span></div><div class="line"><span class="string">包含了多个语句"""</span></div></pre></td></tr></table></figure></p><h2 id="Python注释"><a href="#Python注释" class="headerlink" title="Python注释"></a>Python注释</h2><p>python中单行注释采用 # 开头。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 文件名：lesson1.py</span></div><div class="line"></div><div class="line"><span class="comment"># 第一个注释</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello, Python!"</span>;  <span class="comment"># 第二个注释</span></div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, Python!</div></pre></td></tr></table></figure></p><p>python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 文件名：lesson1.py</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">这是多行注释，使用单引号。</span></div><div class="line"><span class="string">这是多行注释，使用单引号。</span></div><div class="line"><span class="string">这是多行注释，使用单引号。</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">这是多行注释，使用双引号。</span></div><div class="line"><span class="string">这是多行注释，使用双引号。</span></div><div class="line"><span class="string">这是多行注释，使用双引号。</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure></p><h2 id="Python空行"><a href="#Python空行" class="headerlink" title="Python空行"></a>Python空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。<br>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。<br>记住：空行也是程序代码的一部分。</p><h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><p>下面的程序在按回车键后就会等待用户输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">raw_input(<span class="string">"\n\nPress the enter key to exit."</span>)</div></pre></td></tr></table></figure></p><p>以上代码中 ，”\n\n”在结果输出前会输出两个新的空行。一旦用户按下 enter(回车) 键退出，其它键显示。</p><h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys; x = <span class="string">'hello'</span>; sys.stdout.write(x + <span class="string">'\n'</span>)</div></pre></td></tr></table></figure></p><p>执行以上代码，输入结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python lesson1.py</div><div class="line">hello</div></pre></td></tr></table></figure></p><h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。<br>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。<br>我们将首行及后面的代码组称为一个子句(clause)。<br>如下实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> expression : </div><div class="line">   suite </div><div class="line"><span class="keyword">elif</span> expression :  </div><div class="line">   suite  </div><div class="line"><span class="keyword">else</span> :  </div><div class="line">   suite</div></pre></td></tr></table></figure></p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>很多程序可以执行一些操作来查看一些基本信，Python可以使用-h参数查看各参数帮助信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> python -h </div><div class="line">usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ... </div><div class="line">Options and arguments (and corresponding environment variables): </div><div class="line">-c cmd : program passed in as string (terminates option list) </div><div class="line">-d     : debug output from parser (also PYTHONDEBUG=x) </div><div class="line">-E     : ignore environment variables (such as PYTHONPATH) </div><div class="line">-h     : print this help message and exit </div><div class="line"> </div><div class="line">[ etc. ]</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      Python语言与Perl，C和Java等语言有许多相似之处。但是，也存在一些差异。在本章中我们将来学习Python的基础语法，让你快速学会Python编程。
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python中range()函数的用法及数组的操作</title>
    <link href="https://blog.devzou.com/2018/06/20/python/2017-07-05-python%E4%B8%ADrange()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.devzou.com/2018/06/20/python/2017-07-05-python中range()函数的用法/</id>
    <published>2018-06-20T00:10:09.000Z</published>
    <updated>2019-04-24T07:01:01.125Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">range(<span class="number">1</span>,<span class="number">6</span>) <span class="comment">#代表从1到6(不包含6)</span></div></pre></td></tr></table></figure><p>[1, 2, 3, 4, 5]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">range(<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>) <span class="comment">#代表从1到6，间隔2(不包含6)</span></div></pre></td></tr></table></figure></p><p>[1, 3, 5]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">range(<span class="number">6</span>) <span class="comment">#代表从0到6(不包含6)</span></div></pre></td></tr></table></figure></p><h2 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>]</div><div class="line">array[<span class="number">0</span>:] <span class="comment">#列出0以后的</span></div></pre></td></tr></table></figure><p>[1, 3, 5, 7, 9, 2, 4, 6, 8, 0]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array[<span class="number">1</span>:] <span class="comment">#列出1以后的</span></div></pre></td></tr></table></figure></p><p>[3, 5, 7, 9, 2, 4, 6, 8, 0]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array[:<span class="number">-1</span>] <span class="comment">#列出-1之前的</span></div></pre></td></tr></table></figure></p><p>[1, 3, 5, 7, 9, 2, 4, 6, 8]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array[<span class="number">3</span>:<span class="number">-3</span>] <span class="comment">#列出3到-3之间的</span></div></pre></td></tr></table></figure></p><p>[7, 9, 2, 4]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array[::<span class="number">2</span>] <span class="comment">#[1, 5, 9, 4, 8]</span></div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array[::<span class="number">3</span>]<span class="comment">#[1, 7, 4, 0]</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array[::<span class="number">-1</span>]<span class="comment">#数组逆序,[0, 8, 6, 4, 2, 9, 7, 5, 3, 1]</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;li
      
    
    </summary>
    
      <category term="python" scheme="https://blog.devzou.com/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.devzou.com/tags/python/"/>
    
  </entry>
  
</feed>
