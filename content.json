[{"title":"OC常用方法总结","date":"2017-11-04T12:48:27.851Z","path":"2017/11/04/ios/2013-11-04-OC常用方法总结/","text":"以下方法是本人在实际学习及开发中总结出来备忘，分享给大家 JSON格式的字符串转换成字典123456789101112131415/** * 把格式化的JSON格式的字符串转换成字典 * @param jsonString JSON格式的字符串 * @return 返回字典 */+ (NSDictionary *)dictionaryWithJsonString:(NSString *)jsonString &#123; if (jsonString == nil) &#123; return nil; &#125; NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding]; NSError *err; NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:&amp;err]; if(err) return nil; return dic;&#125; 字典转json格式字符串123456789/** * 字典转json格式字符串 * @return Json字符串 */- (NSString*)dictionaryToJson &#123; NSError *parseError = nil; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:self options:NSJSONWritingPrettyPrinted error:&amp;parseError]; return [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];&#125; 加载本地json文件123456//获取文件路径 NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"JsonFileName\" ofType:@\"json\"]; //根据文件路径读取数据 NSData *jdata = [[NSData alloc]initWithContentsOfFile:filePath]; //格式化成json数据 NSDictionary *jsonObject = [NSJSONSerialization JSONObjectWithData:jdata options:kNilOptions error:&amp;error]; 判断字符串是否是纯数字12345678910/** 判断字符串是否是纯数字 @param string 带判断字符串 @return 是/否 */- (BOOL)isNumber:(NSString *)string &#123; NSScanner* scan = [NSScanner scannerWithString:string]; int val; return [scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd]; &#125; 根据正则，过滤特殊字符123456789101112/** * 根据正则，过滤特殊字符 * @param regexString 正则表达式 * @return 过滤后的字符串 */- (NSString *)filterCharactorWithRegex:(NSString *)regexString &#123; NSString *searchText = self; NSError *error = NULL; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regexString options:NSRegularExpressionCaseInsensitive error:&amp;error]; NSString *result = [regex stringByReplacingMatchesInString:searchText options:NSMatchingReportCompletion range:NSMakeRange(0, searchText.length) withTemplate:@\"\"]; return result;&#125; 邮箱验证1234567891011/** * 邮箱验证 * @param email 邮箱地址 * @return 是否 */+ (BOOL)isValidateEmail:(NSString *)email &#123; NSString *emailRegex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]&#123;2,4&#125;\"; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", emailRegex]; return [emailTest evaluateWithObject:email];&#125; 手机号码验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 手机号码验证 * * @param mobileNum 手机号 * * @return 是否 */+ (BOOL)isMobileNumber:(NSString *)mobileNum &#123; if (mobileNum.length != 11)&#123; return NO; &#125; /** * 手机号码: * 13[0-9], 14[5,7], 15[0, 1, 2, 3, 5, 6, 7, 8, 9], 17[0, 1, 6, 7, 8], 18[0-9] * 移动号段: 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188 * 联通号段: 130,131,132,145,152,155,156,170,171,176,185,186 * 电信号段: 133,134,153,170,173,177,180,181,189 */ NSString *MOBILE = @\"^1(3[0-9]|4[57]|5[0-35-9]|7[013678]|8[0-9])\\\\d&#123;8&#125;$\"; /** * 中国移动：China Mobile * 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188 */ NSString *CM = @\"^1(3[4-9]|4[7]|5[0-27-9]|7[08]|8[2-478])\\\\d&#123;8&#125;$\"; /** * 中国联通：China Unicom * 130,131,132,145,152,155,156,170,171,176,185,186 */ NSString *CU = @\"^1(3[0-2]|4[5]|5[256]|7[016]|8[56])\\\\d&#123;8&#125;$\"; /** * 中国电信：China Telecom * 133,134,153,170,173,177,180,181,189 */ NSString *CT = @\"^1(3[34]|53|7[037]|8[019])\\\\d&#123;8&#125;$\"; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", MOBILE]; NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CM]; NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CU]; NSPredicate *regextestct = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CT]; if (([regextestmobile evaluateWithObject:mobileNum] == YES) || ([regextestcm evaluateWithObject:mobileNum] == YES) || ([regextestct evaluateWithObject:mobileNum] == YES) || ([regextestcu evaluateWithObject:mobileNum] == YES))&#123; return YES; &#125; else&#123; return NO; &#125;&#125; 压缩图片成二进制数据123456789101112131415161718192021222324/** * 将图片压缩成二进制数据 * @param 图片 **/+ (NSData *)compressImage:(UIImage *)image &#123; NSData *imageData = UIImageJPEGRepresentation(image, 1.0f); if (imageData.length &lt;= 1000*1000) &#123; return imageData; &#125; else if (imageData.length &gt; 1000*1000 &amp;&amp; imageData.length &lt; 3000 * 1000) &#123; imageData = UIImageJPEGRepresentation(image, 0.8f); return imageData; &#125; else if (imageData.length &gt; 3000*1000 &amp;&amp; imageData.length &lt; 5000 * 1000) &#123; imageData = UIImageJPEGRepresentation(image, 0.6f); return imageData; &#125; else &#123; imageData = UIImageJPEGRepresentation(image, 0.4f); return imageData; &#125;&#125; 文字生成二维码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 生成二维码 @param codeString 二维码客串 @return 二维码图片 */+ (UIImage *)createQRCodeWithString:(NSString *)codeString&#123; // 1.创建过滤器 CIFilter *filter = [CIFilter filterWithName:@\"CIQRCodeGenerator\"]; // 2.恢复默认 [filter setDefaults]; // 3.给过滤器添加数据(正则表达式/账号和密码) NSString *dataString = codeString; NSData *data = [dataString dataUsingEncoding:NSUTF8StringEncoding]; [filter setValue:data forKeyPath:@\"inputMessage\"]; // 4.获取输出的二维码 CIImage *outputImage = [filter outputImage]; // 5.将CIImage转换成UIImage，并放大显示 return [self createNonInterpolatedUIImageFormCIImage:outputImage withSize:400];&#125;/** 根据CIImage生成指定大小的UIImage @param image CIImage @param size 图片宽度 */+ (UIImage *)createNonInterpolatedUIImageFormCIImage:(CIImage *)image withSize:(CGFloat)size &#123; CGRect extent = CGRectIntegral(image.extent); CGFloat scale = MIN(size/CGRectGetWidth(extent), size/CGRectGetHeight(extent)); // 1.创建bitmap; size_t width = CGRectGetWidth(extent) * scale; size_t height = CGRectGetHeight(extent) * scale; CGColorSpaceRef cs = CGColorSpaceCreateDeviceGray(); CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, cs, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; CGImageRef bitmapImage = [context createCGImage:image fromRect:extent]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, extent, bitmapImage); // 2.保存bitmap到图片 CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); return [UIImage imageWithCGImage:scaledImage];&#125; 图片增加水印123456789101112131415161718/** * 图片增加水印 * * @param superImage 需要增加水印的图片 * @param subImage 水印图片 * @param posRect 水印的位置 和 水印的大小 * * @return 加水印后的新图片 */- (UIImage *)addImageToSuperImage:(UIImage *)superImage withSubImage:(UIImage *)subImage andSubImagePosition:(CGRect)posRect&#123; UIGraphicsBeginImageContext(superImage.size); [superImage drawInRect:CGRectMake(0, 0, superImage.size.width, superImage.size.height)]; //四个参数为水印图片的位置 [subImage drawInRect:posRect]; UIImage *resultingImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return resultingImage;&#125; image添加倒影效果12345678910111213141516171819202122- (void)setImageShadow &#123; CGRect frame = self.frame; frame.origin.y += (frame.size.height + 1); UIImageView *reflectionImageView = [[UIImageView alloc] initWithFrame:frame]; self.clipsToBounds = TRUE; reflectionImageView.contentMode = self.contentMode; [reflectionImageView setImage:self.image]; reflectionImageView.transform = CGAffineTransformMakeScale(1.0, -1.0); CALayer *reflectionLayer = [reflectionImageView layer]; CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.bounds = reflectionLayer.bounds; gradientLayer.position = CGPointMake(reflectionLayer.bounds.size.width / 2, reflectionLayer.bounds.size.height * 0.5); gradientLayer.colors = [NSArray arrayWithObjects: (id)[[UIColor clearColor] CGColor], (id)[[UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.3] CGColor], nil]; gradientLayer.startPoint = CGPointMake(0.5,0.5); gradientLayer.endPoint = CGPointMake(0.5,1.0); reflectionLayer.mask = gradientLayer; [self.superview addSubview:reflectionImageView];&#125; UIView背景颜色渐变123456UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 100)];[self.view addSubview:view];CAGradientLayer *gradient = [CAGradientLayer layer];gradient.frame = view.bounds;gradient.colors = [NSArray arrayWithObjects:(id)[[UIColor blackColor] CGColor], (id)[[UIColor whiteColor] CGColor], nil];[view.layer insertSublayer:gradient atIndex:0]; 获取app缓存大小12345678910111213141516171819202122/** * 获取app缓存大小 **/- (CGFloat)getCachSize &#123; NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize]; // 获取自定义缓存大小 // 用枚举器遍历 一个文件夹的内容 // 1.获取 文件夹枚举器 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@\"Library/Caches\"]; NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath]; __block NSUInteger count = 0; // 2.遍历 for (NSString *fileName in enumerator) &#123; NSString *path = [myCachePath stringByAppendingPathComponent:fileName]; NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]; //自定义所有缓存大小 count += fileDict.fileSize; &#125; // 得到是字节 转化为M CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024; return totalSize;&#125; 跳进app权限设置1234if (UIApplicationOpenSettingsURLString != NULL) &#123; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; [[UIApplication sharedApplication] openURL:url];&#125; 删除NSUserDefaults所有记录1234567891011121314//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain]; //方法二 - (void)resetDefaults &#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize]; &#125;// 方法三[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]]; 统一收起键盘1[[[UIApplication sharedApplication] keyWindow] endEditing:YES]; 修改textField的placeholder的字体颜色、大小12[textField setValue:[UIColor redColor] forKeyPath:@\"_placeholderLabel.textColor\"];[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@\"_placeholderLabel.font\"]; 数组去重123NSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self\"];@distinctUnionOfObjects.self 表示比较对象@distinctUnionOfObjects.[key] 表示比较对象的任意keyboarded","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"","date":"2017-11-02T00:27:02.454Z","path":"2017/11/02/c语言/2017-11-03-指针/","text":"title: 指针category: C语言tags: C语言 keywords: C语言指针是Ｃ语言中广泛使用的一种数据类型。指针是C语言的精华，利用指针变量可以表示各种数据结构； 能很方便地使用数组和字符串； 并能象汇编语言一样处理内存地址，从而编出精练而高效的程序。同时， 指针也是Ｃ语言中最为困难的一部分，在学习中除了要正确理解基本概念，还必须要多编程，上机调试。只要作到这些，指针也是不难掌握的。 概念 指针变量的值是一个地址， 那么这个地址不仅可以是变量的地址， 也可以是其它数据结构的地址。在一个指针变量中存放一个数组或一个函数的首地址有何意义呢？ 因为数组或函数都是连续存放的。通过访问指针变量取得了数组或函数的首地址， 也就找到了该数组或函数。这样一来， 凡是出现数组，函数的地方都可以用一个指针变量来表示， 只要该指针变量中赋予数组或函数的首地址即可。这样做， 将会使程序的概念十分清楚，程序本身也精练，高效。在Ｃ语言中， 一种数据类型或数据结构往往都占有一组连续的内存单元。 用“地址”这个概念并不能很好地描述一种数据类型或数据结构， 而“指针”虽然实际上也是一个地址，但它却是一个数据结构的首地址， 它是“指向”一个数据结构的，因而概念更为清楚，表示更为明确。 这也是引入“指针”概念的一个重要原因。 从实际出发123456789int p; //p是一个普通的整型变量 int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针 int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组 int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组 int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针 int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针. int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针 int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.","tags":[]},{"title":"","date":"2017-11-02T00:04:46.150Z","path":"2017/11/02/c语言/2017-11-02-define与typedef 用法总结/","text":"title: define与typedef用法总结category: C语言tags: C语言 keywords: C语言define的用法 #define为一宏定义语句，通常用它来定义常量(包括无参量与带参量)，以及用来实现那些“表面似和善、背后一长串”的宏，它本身并不在编 译过程中进行，而是在这之前(预处理过程)就已经完成了，但也因此难以发现潜在的错误及其它代码维护问题，它的实例像：123#define INT int#define TRUE 1 #define Add(a,b) ((a)+(b)); #define Loop_10 for (int i=0; i&lt;10; i++) typedef的用法 在C/C++语言中，typedef常用来定义一个标识符及关键字的别名，它是语言编译过程的一部分，但它并不实际分配内存空间，实例像： typedef unsigned char UCHAR; typedef可以增强程序的可读性，以及标识符的灵活性，但它也有“非直观性”等缺点。 define 与typedef的区别 typedef给出的符号名称仅限于对类型，而不是对值 typedef的解释由编译器，而不是预处理器执行 虽然typedef的范围有限，但在其受限范围内,typedef比#define更灵活","tags":[]},{"title":"Objective-C运行时编程指南之属性声明","date":"2017-11-01T01:28:32.254Z","path":"2017/11/01/ios/2017-11-01-Objective-C运行时编程指南之属性声明/","text":"当编译器遇到一个属性（Property）声明时（参考Objective-C 2.0 程序设计语言中的属性小节），编译器将产生一些描述性的元数据与属性所在的类或者协议类关联。您可以通过函数访问元数据，这些函数支持在类或者协议类中通过名字来查找，通过@encode获得属性的类型编码，将属性的特征（Attribute）作为C字符串的数组返回等。每个类或者协议类都维护了一个声明了的属性列表。 属性类型和相关函数属性（Property）类型定义了对描述属性的结构体objc_property的不透明的句柄。1typedef struct objc_property *Property; 您可以使用函数class_copyPropertyList和protocol_copyPropertyList来获得类（包括范畴类）或者协议类中的属性列表：1objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount) objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount) 例如，有如下的类声明：123456@interface Lender : NSObject &#123; float alone; &#125;@property float alone;@end 您可以象这样获得它的属性：12id LenderClass = objc_getClass(\"Lender\");unsigned int outCount; objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount); 您还可以通过property_getName函数获得属性的名字：1const char *property_getName(objc_property_t property) 函数class_getProperty和protocol_getProperty则在类或者协议类中返回具有给定名字的属性的引用：1objc_property_t class_getProperty(Class cls, const char *name) objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty) 通过property_getAttributes函数可以获得属性的名字和@encode编码。关于类型编码的更多细节，参考“类型编码“一节；关于属性的类型编码，见“属性类型编码”及“属性特征的描述范例”。1const char *property_getAttributes(objc_property_t property) 综合起来，您可以通过下面的代码得到一个类中所有的属性。123456 id LenderClass = objc_getClass(\"Lender\");unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount); for (i = 0; i &lt; outCount; i++) &#123; objc_property_t property = properties[i]; fprintf(stdout, \"%s %s\\n\", property_getName(property), property_getAttributes(property)); &#125; 属性类型编码以及其它特征（Attribute）。 property_getAttributes返回的字符串以字母T开始，接着是@encode编码和逗号。 如果属性有readonly修饰，则字符串中含有R和逗号。 如果属性有copy或者retain修饰，则字符串分别含有C或者&amp;，然后是逗号。 如果属性定义有定制的getter和setter方法，则字符串中有G或者S跟着相应的方法名以及逗号（例如，GcustomGetter，ScustomSetter:,，）。 如果属性是只读的，且有定制的get访问方法，则描述到此为止。 字符串以V然后是属性的名字结束。 范例请参考 “属性特征的描述范例”一节。 属性特征的描述范例给定如下定义： 1234enum FooManChu &#123; FOO, MAN, CHU &#125;;struct YorkshireTeaStruct &#123; int pot; char lady; &#125;;typedef struct YorkshireTeaStruct YorkshireTeaStructType;union MoneyUnion &#123; float alone; double down; &#125;; 下表给出了属性（Property）声明以及property_getAttributes返回的相应的字符串：","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"Objective-C运行时编程指南之类型编码","date":"2017-10-31T14:22:28.873Z","path":"2017/10/31/ios/2017-10-31-Objective-C运行时编程指南之类型编码/","text":"为了和运行时系统协作，编译器将方法的返回类型和参数类型都编码成一个字符串，并且和方法选标关联在一起。这些编码在别的上下文环境中同样有用，所以您可以直接使用@encode()编译指令来得到具体的编码。给定一个类型， @encode()将返回该类型的编码字符串。类型可以是基本类型例如整形，指针，结构体或者联合体，也可以是一个类，就和C语言中的sizeof()操作符的参数一样，可以是任何类型。123char *buf1 = @encode(int **);char *buf2 = @encode(struct key);char *buf3 = @encode(Rectangle); 下表列出了这些类型编码。注意，它们可能很多和您使用的对象编码有一些重合。然而，这儿列出来的有些编码是您写编码器时候不会使用的，也有一些不是@encode()产生的，但是在您写编码器的时候是会使用的。（关于对象编码的更多信息，请参考Foundation框架参考库中的NSCoder类文档。）重要： Objective-C不支持long double类型。 @encode(long double)和double一样，返回的字符串都是d数组的类型编码以方括号来表示，紧接着左方括号的是数组元素的数量，然后是数据元素的类型。例如，一个12个浮点数（floats）指针的数组可以表示如下：1[12^f] 结构体和联合体分别用大括号和小括号表示。括号中首先是结构体标签，然后是一个=符号，接着是结构体中各个成员的编码。例如，结构体12345typedef struct example &#123; id anObject; char *aString; int anInt;&#125; Example; 的编码如下：1&#123;example=@*i&#125; 定义的类型名（Example）和结构体标签（example）有同样的编码结果。指向结构体类型的指针的编码同样也包含了结构体内部数据成员的编码信息，如下所示：1^&#123;example=@*i&#125; 然而，更高层次的间接关联就没有了内部数据成员的编码信息：1^^&#123;example&#125; 对象的编码类似结构体。 例如， @encode()对NSObject编码如下：1&#123;NSObject=#&#125; NSObject类仅声明了一个Class类型的实例变量，isa。 注意，尽管有一些编码无法从 @encode() 的结果中直接得到，但是运行时系统会使用它们来表示协议类中方法的修饰符，这些编码如表6-2所示。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"Objective-C运行时编程指南之消息转发","date":"2017-10-31T01:14:52.277Z","path":"2017/10/31/ios/2017-10-31-Objective-C运行时编程指南之消息转发/","text":"通常，给一个对象发送它不能处理的消息会得到出错提示，然而，Objective-C运行时系统在抛出错误之前，会给消息接收对象发送一条特别的消息来通知该对象。 消息转发如果一个对象收到一条无法处理的消息，运行时系统会在抛出错误前，给该对象发送一条forwardInvocation:消息，该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。 您可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以以其它的某种方式来避免错误被抛出。如forwardInvocation:的名字所示，它通常用来将消息转发给其它的对象。 关于消息转发的作用，您可以考虑如下情景：假设，您需要设计一个能够响应negotiate消息的对象，并且能够包括其它类型的对象对消息的响应。 通过在negotiate方法的实现中将negotiate消息转发给其它的对象来很容易的达到这一目的。 更进一步，假设您希望您的对象和另外一个类的对象对negotiate的消息的响应完全一致。一种可能的方式就是让您的类继承其它类的方法实现。 然后，有时候这种方式不可行，因为您的类和其它类可能需要在不同的继承体系中响应negotiate消息。 虽然您的类无法继承其它类的negotiate方法，您仍然可以提供一个方法实现，这个方法实现只是简单的将negotiate消息转发给其他类的对象，就好像从其它类那儿“借”来的现一样。如下所示：12345- negotiate &#123; if ( [someOtherObject respondsTo:@selector(negotiate)] ) return [someOtherObject negotiate]; return self;&#125; 这种方式显得有欠灵活，特别是有很多消息您都希望传递给其它对象时，您必须为每一种消息提供方法实现。此外，这种方式不能处理未知的消息。当您写下代码时，所有您需要转发的消息的集合也必须确定。然而，实际上，这个集合会随着运行时事件的发生，新方法或者新类的定义而变化。forwardInvocation:消息给这个问题提供了一个更特别的，动态的解决方案：当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过forwardInvocation:消息通知该对象。每个对象都从NSObject类中继承了forwardInvocation:方法。然而，NSObject中的方法实现只是简单地调用了doesNotRecognizeSelector:。通过实现您自己的forwardInvocation:方法，您可以在该方法实现中将消息转发给其它对象。 要转发消息给其它对象，forwardInvocation:方法所必须做的有： 决定将消息转发给谁 并且将消息和原来的参数一块转发出去消息可以通过invokeWithTarget:方法来转发:123456- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([someOtherObject respondsToSelector:[anInvocation selector]]) [anInvocation invokeWithTarget:someOtherObject]; else [super forwardInvocation:anInvocation];&#125; 转发消息后的返回值将返回给原来的消息发送者。您可以将返回任何类型的返回值，包括: id，结构体，浮点数等。forwardInvocation:方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。forwardInvocation:方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。 注意： forwardInvocation:方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果您希望您的对象将negotiate消息转发给其它对象，您的对象不能有negotiate方法。否则，forwardInvocation:将不可能会被调用。 更多消息转发的信息，参考Foundation框架参考库中NSInvocation类的文档。 消息转发和多重继承消息转发很象继承，并且可以用来在Objective-C程序中模拟多重继承。如图 5-1所示， 一个对象通过转发来响应消息，看起来就象该对象从别的类那借来了或者”继承“了方法实现一样。 在上图中，Warrior类的一个对象实例将negotiate消息转发给Diplomat类的一个实例。看起来，Warrior类似乎和Diplomat类一样， 响应negotiate消息，并且行为和Diplomat一样（尽管实际上是Diplomat类响应了该消息）。 转发消息的对象看起来有两个继承体系分支——自己的和响应消息的对象的。在上面的例子中，Warrior看起来同时继承自Diplomat和自己的父类。 消息转发提供了多重继承的很多特性。然而，两者有很大的不同：多重继承是将不同的行为封装到单个的对象中，有可能导致庞大的，复杂的对象。而消息转发是将问题分解到更小的对象中，但是又以一种对消息发送对象来说完全透明的方式将这些对象联系起来。 消息代理对象消息转发不仅和继承很象，它也使得以一个轻量级的对象（消息代理对象）代表更多的对象进行消息处理成为可能。 Objective-C 2.0程序设计语言中“远程消息”一节中的代理类就是这样一个代理对象。代理类负责将消息转发给远程消息接收对象的管理细节，保证消息参数的传输等等。但是消息类没有进一步的复制远程对象的功能，它只是将远程对象映射到一个本地地址上，从而能够接收其它应用程序的消息。 同时也存在着其它类型的消息代理对象。例如，假设您有个对象需要操作大量的数据——它可能需要创建一个复杂的图片或者需要从磁盘上读一个文件的内容。创建一个这样的对象是很费时的，您可能希望能推迟它的创建时间——直到它真正需要时，或者系统资源空闲时。同时，您又希望至少有一个预留的对象和程序中其它对象交互。 在这种情况下，你可以为该对象创建一个轻量的代理对象。该代理对象可以有一些自己的功能，例如响应数据查询消息，但是它主要的功能是代表某个对象，当时间到来时，将消息转发给被代表的对象。当代理对象的forwardInvocation:方法收到需要转发给被代表的对象的消息时，代理对象会保证所代表的对象已经存在，否则就创建它。所有发到被代表的对象的消息都要经过代理对象，对程序来说，代理对象和被代表的对象是一样的。 消息转发和类继承尽管消息转发很“象”继承，但它不是继承。例如在NSObject类中，方法respondsToSelector:和isKindOfClass:只会出现在继承链中，而不是消息转发链中。例如，如果向一个Warrior类的对象询问它能否响应negotiate消息，123456789101112 if ( [aWarrior respondsToSelector:@selector(negotiate)] ) ...``` 返回值是NO，尽管该对象能够接收和响应negotiate。（见图 5-1。） 大部分情况下，NO是正确的响应。但不是所有时候都是的。例如，如果您使用消息转发来创建一个代理对象以扩展某个类的能力，这儿的消息转发必须和继承一样，尽可能的对用户透明。如果您希望您的代理对象看起来就象是继承自它代表的对象一样，您需要重新实现respondsToSelector:和isKindOfClass:方法： ```objc - (BOOL)respondsToSelector:(SEL)aSelector &#123; if ( [super respondsToSelector:aSelector] ) return YES; else &#123; /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ &#125; return NO; &#125; 除了respondsToSelector:和isKindOfClass:外，instancesRespondToSelector:方法也必须重新实现。如果您使用的是协议类，需要重新实现的还有conformsToProtocol:方法。类似地，如果对象需要转发远程消息，则methodSignatureForSelector:方法必须能够返回实际响应消息的方法的描述。例如，如果对象需要将消息转发给它所代表的对象，您可能需要如下的methodSignatureForSelector:实现：1234567- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector &#123; NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) &#123; signature = [surrogate methodSignatureForSelector:selector]; &#125; return signature;&#125; 您也可以将消息转发的部分放在一段私有的代码里，然后从forwardInvocation:调用它。 注意： 消息转发是一个比较高级的技术，仅适用于没有其它更好的解决办法的情况。它并不是用来代替继承的。如果您必须使用该技术，请确定您已经完全理解了转发消息的类和接收转发消息的类的行为。 本节中涉及的方法在Foundation框架参考库中的NSObject类的文档中都有描述。关于invokeWithTarget:的具体信息，请参考Foundation框架参考库中NSInvocation类的文档。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"Objective-C运行时编程指南之动态方法解析","date":"2017-10-30T23:50:47.622Z","path":"2017/10/31/ios/2017-10-31-Objective-C运行时编程指南之动态方法解析/","text":"本章将描述怎样动态地提供一个方法的实现。 动态方法解析 有时候，您需要动态地提供一个方法的实现。例如，Objective-C中属性（Property）（参考Objective-C 2.0 程序设计语言中属性小节）前的修饰符@dynamic1@dynamic propertyName; 表示编译器须动态地生成该属性对应地方法。您可以通过实现resolveInstanceMethod:和resolveClassMethod:来动态地实现给定选标的对象方法或者类方法。Objective-C方法可以认为是至少有两个参数——self和_cmd—— 的C函数。您可以通过class_addMethod方法将一个函数加入到类的方法中。例如，有如下的函数：123456789101112131415void dynamicMethodIMP(id self, SEL _cmd) &#123; // implementation .... &#125; ``` 您可以通过resolveInstanceMethod:将它作为类方法resolveThisMethodDynamically的实现： ```objc @implementation MyClass + (BOOL)resolveInstanceMethod:(SEL)aSEL &#123; if (aSEL == @selector(resolveThisMethodDynamically)) &#123; class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:aSEL]; &#125; @end 通常消息转发（见 “消息转发”）和动态方法解析是互不相干的。在进入消息转发机制之前，respondsToSelector:和instancesRespondToSelector: 会被首先调用。您可以在这两个方法中为传进来的选标提供一个IMP。如果您实现了resolveInstanceMethod:方法但是仍然希望正常的消息转发机制进行，您只需要返回NO就可以了。 动态加载Objective-C程序可以在运行时链接和载入新的类和范畴类。新载入的类和在程序启动时载入的类并没有区别。 动态加载可以用在很多地方。例如，系统配置中的模块就是被动态加载的。 在Cocoa环境中，动态加载一般被用来对应用程序进行定制。您的程序可以在运行时加载其他程序员编写的模块——和Interface Build载入定制的调色板以及系统配置程序载入定制的模块的类似。 这些模块通过您许可的方式扩展了您的程序，而您无需自己来定义或者实现。您提供了框架，而其它的程序员提供了实现。 尽管已经有一个运行时系统的函数来动态加载Mach-O文件中的Objective-C模块（objc_loadModules，在objc/objc-load.h中定义），Cocoa的NSBundle类为动态加载提供了一个更方便的接口——一个面向对象的，已和相关服务集成的接口。关于NSBundle类的更多相关信息请参考Foundation框架中关于NSBundle类的文档。关于Mach-O文件的有关信息请参考Mac OS X ABI Mach-O 文件格式参考库","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"Objective-C运行时编程指南之消息","date":"2017-10-30T13:55:26.982Z","path":"2017/10/30/ios/2017-10-30-Objective-C运行时编程指南之消息/","text":"本章描述了代码的消息表达式如何转换为对objc_msgSend函数的调用，如何通过名字来指定一个方法，以及如何使用objc_msgSend函数。 objc_msgSend 函数在Objective-C中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，[receiver message]转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字——也就是方法选标：objc_msgSend(receiver, selector)同时接收消息中的任意数目的参数：objc_msgSend(receiver, selector, arg1, arg2, ...)该消息函数做了动态绑定所需要的一切： 它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。 然后将消息接收者对象（指向消息接收者对象的指针）以及方法中指定的参数传给找到的方法实现。 最后，将方法实现的返回值作为该函数的返回值返回。【注】编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。消息机制的关键在于编译器为类和对象生成的结构。每个类的结构中至少包括两个基本元素： 指向父类的指针。 类的方法表。方法表将方法选标和该类的方法实现的地址关联起来。例如，setOrigin::的方法选标和setOrigin::的方法实现的地址关联，display 的方法选标和display的方法实现的地址关联，等等。当新的对象被创建时，其内存同时被分配，实例变量也同时被初始化。对象的第一个实例变量是一个指向该对象的类结构的指针，叫做isa。通过该指针，对象可以访问它对应的类以及相应的父类。注意：尽管严格来说这并不是Obective-C语言的一部分，但是在Objective-C运行时系统中对象需要有isa指针。对象和结构体struct objc_object（在objc/objc.h中定义）必须“一致”。然而，您很少需要创建您自己的根对象，因为从NSObject或者NSProxy继承的对象都自动包括isa变量。 类和对象的结构如图 3-1所示。当对象收到消息时，消息函数首先根据该对象的isa指针找到该对象所对应的类的方法表，并从表中寻找该消息对应的方法选标。如果找不到，objc_msgSend将继续从父类中寻找，直到NSObject类。一旦找到了方法选标， objc_msgSend则以消息接收者对象为参数调用，调用该选标对应的方法实现。 这就是在运行时系统中选择方法实现的方式。在面向对象编程中，一般称作方法和消息动态绑定的过程。 为了加快消息的处理过程，运行时系统通常会将使用过的方法选标和方法实现的地址放入缓存中。每个类都有一个独立的缓存，同时包括继承的方法和在该类中定义的方法。消息函数会首先检查消息接收者对象对应的类的缓存（理论上，如果一个方法被使用过一次，那么它很可能被再次使用）。如果在缓存中已经有了需要的方法选标，则消息仅仅比函数调用慢一点点。如果程序运行了足够长的时间，几乎每个消息都能在缓存中找到方法实现。程序运行时，缓存也将随着新的消息的增加而增加。 使用隐藏的参数当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数： 接收消息的对象 方法选标 这些参数帮助方法实现获得了消息表达式的信息。它们被认为是”隐藏“的是因为它们并没有在定义方法的源代码中声明，而是在代码编译时是插入方法的实现中的。尽管这些参数没有被显示声明，但在源代码中仍然可以引用它们（就象可以引用消息接收者对象的实例变量一样）。在方法中可以通过self来引用消息接收者对象，通过选标_cmd来引用方法本身。在下面的例子中，_cmd指的是strange方法，self指的收到strange消息的对象。 123456789- strange&#123; id target = getTheReceiver(); SEL method = getTheMethod(); if ( target == self || method == _cmd ) return nil; return [target performSelector:method];&#125; 在这两个参数中，self更有用一些。实际上，它是在方法实现中访问消息接收者对象的实例变量的途径。 获得方法地址避免动态绑定的唯一办法就是取得方法的地址，并且直接像函数调用一样调用它。当一个方法会被连续调用很多次，而且您希望节省每次调用方法都要发送消息的开销时，使用方法地址来调用方法就显得很有效。 利用NSObject类中的methodForSelector:方法，您可以获得一个指向方法实现的指针，并可以使用该指针直接调用方法实现。methodForSelector:返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型都在类型识别的考虑范围中。下面的例子展示了怎么使用指针来调用setFilled:的方法实现：12345void (*setter)(id, SEL, BOOL); int i;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)]; for ( i = 0; i &lt; 1000, i++ ) setter(targetList[i], @selector(setFilled:), YES); 方法指针的第一个参数是接收消息的对象（self），第二个参数是方法选标（_cmd）。这两个参数在方法中是隐藏参数，但使用函数的形式来调用方法时必须显示的给出。 使用methodForSelector:来避免动态绑定将减少大部分消息的开销，但是这只有在指定的消息被重复发送很多次时才有意义，例如上面的for循环。 注意，methodForSelector:是Cocoa运行时系统的提供的功能，而不是Objective-C语言本身的功能。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"Objective-C运行时编程指南之和运行时系统交互","date":"2017-10-30T13:34:20.322Z","path":"2017/10/30/ios/2017-10-30-Objective-C运行时编程指南之和运行时系统交互/","text":"Objective-C程序有三种途径和运行时系统交互：通过Objective-C源代码；通过Foundation框架中类NSObject的方法；通过直接调用运行时系统的函数。 通过Objective-C源代码大部分情况下，运行时系统在后台自动运行，您只需编写和编译Objective-C源代码。当您编译Objective-C类和方法时，编译器为实现语言动态特性将自动创建一些数据结构和函数。这些数据结构包含类定义和协议类定义中的信息，如在Objective-C 2.0 程序设计语言中定义类和协议类一节所讨论的类的对象和协议类的对象，方法选标，实例变量模板，以及其它来自于源代码的信息。运行时系统的主要功能就是根据源代码中的表达式发送消息，如”消息”一节所述。 通过类NSObject的方法 程序中绝大部分类都是NSObject类的子类，所以大部分都继承了NSObject类的方法，因而继承了NSObject的行为。（NSProxy类是个例外；更多细节参考““消息转发”一节)然而，某些情况下，NSObject类仅仅定义了完成某件事情的模板，而没有提供所有需要的代码。 例如，NSObject类定义了description方法，返回该类内容的字符串表示。这主要是用来调试程序——GDB中的print-object方法就是直接打印出该方法返回的字符串。NSObject类中该方法的实现并不知道子类中的内容，所以它只是返回类的名字和对象的地址。NSObject的子类可以重新实现该方法以提供更多的信息。例如，NSArray类改写了该方法来返回NSArray类包含的每个对象的内容。 某些NSObject的方法只是简单地从运行时系统中获得信息，从而允许对象进行一定程度的自我检查。例如，class返回对象的类；isKindOfClass:和isMemberOfClass:则检查对象是否在指定的类继承体系中；respondsToSelector:检查对象能否响应指定的消息；conformsToProtocol:检查对象是否实现了指定协议类的方法；methodForSelector:则返回指定方法实现的地址。 通过运行时系统的函数运行时系统是一个有公开接口的动态库，由一些数据结构和函数的集合组成，这些数据结构和函数的声明头文件在/usr/include/objc中。这些函数支持用纯C的函数来实现和Objective-C同样的功能。还有一些函数构成了NSObject类方法的基础。这些函数使得访问运行时系统接口和提供开发工具成为可能。尽管大部分情况下它们在Objective-C程序不是必须的，但是有时候对于Objecitve-C程序来说某些函数是非常有用的。 这些函数的文档参见Objective-C 2.0 运行时系统参考库。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"iPhone X 适配","date":"2017-10-29T23:45:38.282Z","path":"2017/10/30/ios/2017-10-29-iphone X适配/","text":"iPhone X 问世以后，每个有app的公司都要开始适配iPhone X了，以下是iPhone X适配的点 你不得不知道的iPhone X屏幕参数","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"React Native布局","date":"2017-10-16T00:37:26.409Z","path":"2017/10/16/React-Native/2017-10-16-React-Native布局详解/","text":"在React Native中布局采用的是FleBox(弹性框)进行布局。本文章将向大家介绍React Native中的布局方式FlexBox。请参考FlexBox弹性布局官方文档FlexBox提供了在不同尺寸设备上都能保持一致的布局方式。FlexBox是CSS3弹性框布局规范，目前还处于最终征求意见稿 (Last Call Working Draft)阶段，并不是所有的浏览器都支持Flexbox。但大家在做React Native开发时大可不必担心FlexBox的兼容性问题，因为既然React Native选择用FlexBox布局，那么React Native对FlexBox的支持自然会做的很好。 Flexbox的工作方式与在网络上的CSS中的异同点 flexDirection: React Native中默认为flexDirection:’column’，在Web CSS中默认为flex-direction:’row’ alignItems: React Native中默认为alignItems:’stretch’，在Web CSS中默认align-items:’flex-start’ flex: 相比Web CSS的flex接受多参数，如:flex: 2 2 10%;，但在 React Native中flex只接受一个参数 不支持属性：align-content，flex-basis，order，flex-basis，flex-flow，flex-grow，flex-shrink父视图属性(容器属性)： flexDirection enum(‘row’, ‘column’,’row-reverse’,’column-reverse’) flexWrap enum(‘wrap’, ‘nowrap’) justifyContent enum(‘flex-start’, ‘flex-end’, ‘center’, ‘space-between’, ‘space-around’) alignItems enum(‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’)flexDirectionflexDirection属性定义了父视图中的子元素沿横轴或侧轴方片的排列方式。flexDirection enum(&#39;row&#39;, &#39;column&#39;,&#39;row-reverse&#39;,&#39;column-reverse&#39;) row: 从左向右依次排列row-reverse: 从右向左依次排列column(default): 默认的排列方式，从上向下排列column-reverse: 从下向上排列 1234567891011121314&lt;View style=&#123; &#123;flexDirection:'row',backgroundColor:\"red\",marginTop:20,flexWrap:'wrap'&#125;&#125;&gt; &lt;View style=&#123; &#123;width:100,height:20,backgroundColor:\"darkcyan\",margin:5&#125;&#125;&gt; &lt;Text style=&#123; &#123;fontSize:16,textAlign:'center'&#125;&#125;&gt;1&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123; &#123;width:100,height:20,backgroundColor:\"darkcyan\",margin:5&#125;&#125;&gt; &lt;Text style=&#123; &#123;fontSize:16,textAlign:'center'&#125;&#125;&gt;2&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123; &#123;width:100,height:20,backgroundColor:\"darkcyan\",margin:5&#125;&#125;&gt; &lt;Text style=&#123; &#123;fontSize:16,textAlign:'center'&#125;&#125;&gt;3&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123; &#123;width:100,height:20,backgroundColor:\"darkcyan\",margin:5&#125;&#125;&gt; &lt;Text style=&#123; &#123;fontSize:16,textAlign:'center'&#125;&#125;&gt;4&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; flexWrapflexWrap属性定义了子元素在父视图内是否允许多行排列，默认为nowrap。flexWrap enum(&#39;wrap&#39;, &#39;nowrap&#39;) nowrap flex的元素只排列在一行上，可能导致溢出。wrap flex的元素在一行排列不下时，就进行多行排列。 justifyContentjustifyContent属性定义了浏览器如何分配顺着父容器主轴的弹性（flex）元素之间及其周围的空间，默认为flex-start。flex-start(default) 从行首开始排列。每行第一个弹性元素与行首对齐，同时所有后续的弹性元素与前 一个对齐。flex-end 从行尾开始排列。每行最后一个弹性元素与行尾对齐，其他元素将与后一个对齐。center 伸缩元素向每行中点排列。每行第一个元素到行首的距离将与每行最后一个元素到行尾的距离相同。space-between 在每行上均匀分配弹性元素。相邻元素间距离相同。每行第一个元素与行首对齐，每行最后一个元素与行尾对齐。space-around 在每行上均匀分配弹性元素。相邻元素间距离相同。每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。 alignItemsalignItems属性以与justify-content相同的方式在侧轴方向上将当前行上的弹性元素对齐，默认为stretch。alignItems enum(&#39;flex-start&#39;, &#39;flex-end&#39;, &#39;center&#39;, &#39;stretch&#39;)flex-start 元素向侧轴起点对齐。flex-end 元素向侧轴终点对齐。center 元素在侧轴居中。如果元素在侧轴上的高度高于其容器，那么在两个方向上溢出距离相同。stretch 弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度。 子视图属性alignSelfalignSelf属性以属性定义了flex容器内被选中项目的对齐方式。注意：alignSelf 属性可重写灵活容器的 alignItems 属性。alignSelf enum(&#39;auto&#39;, &#39;flex-start&#39;, &#39;flex-end&#39;, &#39;center&#39;, &#39;stretch&#39;)auto(default) 元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。stretch 元素被拉伸以适应容器。center 元素位于容器的中心。flex-start 元素位于容器的开头。flex-end 元素位于容器的结尾。 flexflex 属性定义了一个可伸缩元素的能力，默认为0。","tags":[{"name":"React-Naticve","slug":"React-Naticve","permalink":"https://www.devzou.com/tags/React-Naticve/"}]},{"title":"贝塞尔曲线的基本知识","date":"2017-10-13T13:39:23.967Z","path":"2017/10/13/ios/2017-10-13-贝塞尔曲线的基本知识/","text":"UIBezierPath是对Core Graphics框架的一个封装，使用UIBezierPath类我们可以画出我们想要的图形 基本使用方法UIBezierPath对象是CGPathRef数据类型的封装。path如果是基于矢量形状的，都用直线或曲线去创建。我们一般使用UIBezierPath都是在重写view的drawRect方法这种情形。我们用直线去创建矩形或多边形，使用曲线创建弧或者圆。创建和使用path对象步骤：1、 重写View的drawRect方法2、 创建UIBezierPath的对象3、 使用方法moveToPoint: 设置初始点4、 根据具体要求使用UIBezierPath类方法绘图（比如要画线、矩形、圆、弧？等）5、 设置UIBezierPath对象相关属性 （比如lineWidth、lineJoinStyle、aPath.lineCapStyle、color）6、 使用stroke 或者 fill方法结束绘图 常用方法以下代码是我从UIBezierPath.h中复制出来的，下面依次讲解每一个方法及属性，毕竟我们一手资料是先查看系统库的头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//// UIBezierPath.h// UIKit//// Copyright (c) 2009-2017 Apple Inc. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &lt;CoreGraphics/CoreGraphics.h&gt;#import &lt;UIKit/UIKitDefines.h&gt;NS_ASSUME_NONNULL_BEGIN/**/typedef NS_OPTIONS(NSUInteger, UIRectCorner) &#123; UIRectCornerTopLeft = 1 &lt;&lt; 0, UIRectCornerTopRight = 1 &lt;&lt; 1, UIRectCornerBottomLeft = 1 &lt;&lt; 2, UIRectCornerBottomRight = 1 &lt;&lt; 3, UIRectCornerAllCorners = ~0UL&#125;;NS_CLASS_AVAILABLE_IOS(3_2) @interface UIBezierPath : NSObject&lt;NSCopying, NSSecureCoding&gt;/* * 标准初始化方法 */+ (instancetype)bezierPath;/* * 根据矩形创建贝塞尔曲线 */+ (instancetype)bezierPathWithRect:(CGRect)rect;/* * 根据矩形框的内切圆画曲线 */+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;/* * 根据矩形画带圆角的曲线 */+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; // rounds all corners with the same horizontal and vertical radius/** * 在矩形中，可以针对四角中的某个角加圆角 @param rect 矩形 @param corners 用来指定需要加圆角的位置，该参数为枚举值，具体枚举在UIRectCorner @param cornerRadii 参数用来设置圆角的大小 @return 贝塞尔曲线 */+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;/** * 以某个中心点画弧线 @param center 弧线中心点的坐标 @param radius 弧线所在圆的半径 @param startAngle 弧线开始的角度值 @param endAngle 弧线结束的角度值 @param clockwise 是否顺时针画弧线 @return 贝塞尔曲线 */+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;/* * 通过path创建贝塞尔曲线 */+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;- (instancetype)init NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// Returns an immutable CGPathRef which is only valid until the UIBezierPath is further mutated.// Setting the path will create an immutable copy of the provided CGPathRef, so any further mutations on a provided CGMutablePathRef will be ignored.@property(nonatomic) CGPathRef CGPath;- (CGPathRef)CGPath NS_RETURNS_INNER_POINTER CF_RETURNS_NOT_RETAINED;// Path construction/* * 设置起始点（调用这个方法的时候，会结束上一条线的绘制） */- (void)moveToPoint:(CGPoint)point;- (void)addLineToPoint:(CGPoint)point;- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);- (void)closePath;- (void)removeAllPoints;// Appending paths- (void)appendPath:(UIBezierPath *)bezierPath;// Modified paths- (UIBezierPath *)bezierPathByReversingPath NS_AVAILABLE_IOS(6_0);// Transforming paths- (void)applyTransform:(CGAffineTransform)transform;// Path info@property(readonly,getter=isEmpty) BOOL empty;@property(nonatomic,readonly) CGRect bounds;@property(nonatomic,readonly) CGPoint currentPoint;- (BOOL)containsPoint:(CGPoint)point;// Drawing properties@property(nonatomic) CGFloat lineWidth;@property(nonatomic) CGLineCap lineCapStyle;@property(nonatomic) CGLineJoin lineJoinStyle;@property(nonatomic) CGFloat miterLimit; // Used when lineJoinStyle is kCGLineJoinMiter@property(nonatomic) CGFloat flatness;@property(nonatomic) BOOL usesEvenOddFillRule; // Default is NO. When YES, the even-odd fill rule is used for drawing, clipping, and hit testing.- (void)setLineDash:(nullable const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase;- (void)getLineDash:(nullable CGFloat *)pattern count:(nullable NSInteger *)count phase:(nullable CGFloat *)phase;// Path operations on the current graphics context- (void)fill;- (void)stroke;// These methods do not affect the blend mode or alpha of the current graphics context- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;- (void)strokeWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;- (void)addClip;@endNS_ASSUME_NONNULL_END","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"iOS常用的系统通知","date":"2017-10-13T13:31:30.361Z","path":"2017/10/13/ios/2017-10-13-iOS常用的系统通知/","text":"常用的系统通知如下，欢迎大家补充123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//硬件设备 UIKIT_EXTERN NSString *const UIDeviceOrientationDidChangeNotification; //设备方向改变 UIKIT_EXTERN NSString *const UIDeviceBatteryStateDidChangeNotification //电池状态改变 UIKIT_EXTERN NSString *const UIDeviceBatteryLevelDidChangeNotification //电池电量改变 UIKIT_EXTERN NSString *const UIDeviceProximityStateDidChangeNotification //距离感应器状态发生改变 //音频 AVF_EXPORT NSString *const AVAudioSessionInterruptionNotification //音频中断出现 AVF_EXPORT NSString *const AVAudioSessionRouteChangeNotification //系统的音频线路发生改变 AVF_EXPORT NSString *const AVAudioSessionMediaServicesWereLostNotification //媒体服务终止 AVF_EXPORT NSString *const AVAudioSessionMediaServicesWereResetNotification //媒体服务重新启动 //视频 AVF_EXPORT NSString *const AVPlayerItemTimeJumpedNotification // 播放时间跳跃 AVF_EXPORT NSString *const AVPlayerItemDidPlayToEndTimeNotification // 播放结束 AVF_EXPORT NSString *const AVPlayerItemFailedToPlayToEndTimeNotification // 没能播放到最后 AVF_EXPORT NSString *const AVPlayerItemPlaybackStalledNotification // 播放抛锚 AVF_EXPORT NSString *const AVPlayerItemNewAccessLogEntryNotification // 添加新的访问日志条目 AVF_EXPORT NSString *const AVPlayerItemNewErrorLogEntryNotification // 添加新的错误日志条目 MP_EXTERN NSString *const MPMediaLibraryDidChangeNotification; //媒体库发生改变 MP_EXTERN NSString *const MPMediaPlaybackIsPreparedToPlayDidChangeNotification //后台准备播放发生改变 MP_EXTERN NSString *const MPMoviePlayerScalingModeDidChangeNotification; //视频缩放填充模式发生改变 MP_EXTERN NSString *const MPMoviePlayerPlaybackDidFinishNotification; //媒体播放完成或用户手动退出 MP_EXTERN NSString *const MPMoviePlayerPlaybackStateDidChangeNotification //播放状态改变 MP_EXTERN NSString *const MPMoviePlayerLoadStateDidChangeNotification //媒体网络加载状态改变 MP_EXTERN NSString *const MPMoviePlayerNowPlayingMovieDidChangeNotification //当前播放的媒体内容发生改变 MP_EXTERN NSString *const MPMoviePlayerWillEnterFullscreenNotification //将进入全屏 MP_EXTERN NSString *const MPMoviePlayerDidEnterFullscreenNotification //进入全屏后 MP_EXTERN NSString *const MPMoviePlayerWillExitFullscreenNotification //将要退出全屏 MP_EXTERN NSString *const MPMoviePlayerDidExitFullscreenNotification //退出全屏后 MP_EXTERN NSString *const MPMoviePlayerIsAirPlayVideoActiveDidChangeNotification //当媒体开始通过AirPlay播放或者结束AirPlay MP_EXTERN NSString *const MPMoviePlayerReadyForDisplayDidChangeNotification //视频显示状态改变 MP_EXTERN NSString *const MPMovieMediaTypesAvailableNotification //确定了媒体可用类型后 MP_EXTERN NSString *const MPMovieSourceTypeAvailableNotification // 确定了媒体来源后 MP_EXTERN NSString *const MPMovieDurationAvailableNotification //确定了媒体播放时长后 MP_EXTERN NSString *const MPMovieNaturalSizeAvailableNotification //确定了媒体的实际尺寸后 MP_EXTERN NSString *const MPMoviePlayerThumbnailImageRequestDidFinishNotification //缩略图请求完成之后 MP_EXTERN NSString *const MPMoviePlayerTimedMetadataUpdatedNotification //同步元数据发生更新 MP_EXTERN NSString *const MPMoviePlayerContentPreloadDidFinishNotification //媒体内容预加载完成 MP_EXTERN NSString *const MPMusicPlayerControllerPlaybackStateDidChangeNotification; //播放状态改变 MP_EXTERN NSString *const MPMusicPlayerControllerNowPlayingItemDidChangeNotification; //播放内容改变 MP_EXTERN NSString *const MPMusicPlayerControllerVolumeDidChangeNotification; //音量发生改变 //拍照/录像 AVF_EXPORT NSString *const AVCaptureDeviceWasConnectedNotification //输入设备已连接 AVF_EXPORT NSString *const AVCaptureDeviceWasDisconnectedNotification //输入设备失去连接 AVF_EXPORT NSString *const AVCaptureDeviceSubjectAreaDidChangeNotification //捕获区域发生改变 AVF_EXPORT NSString *const AVCaptureInputPortFormatDescriptionDidChangeNotification //输入设备端口描述改变 AVF_EXPORT NSString *const AVCaptureSessionRuntimeErrorNotification //媒体会话运行错误 AVF_EXPORT NSString *const AVCaptureSessionDidStartRunningNotification //媒体会话开始运行 AVF_EXPORT NSString *const AVCaptureSessionDidStopRunningNotification //媒体会话停止运行 AVF_EXPORT NSString *const AVCaptureSessionWasInterruptedNotification //媒体会话中断 AVF_EXPORT NSString *const AVCaptureSessionInterruptionEndedNotification //媒体会话中断停止 //常用视图 UIKIT_EXTERN NSString *const UITableViewSelectionDidChangeNotification; //TableView选中发生改变 UIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification; //TextField开始编辑 UIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification; //TextField发生改变 UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification; //TextField结束编辑 UIKIT_EXTERN NSString * const UITextViewTextDidBeginEditingNotification; //TextView开始编辑 UIKIT_EXTERN NSString * const UITextViewTextDidChangeNotification; //TextView发生改变 UIKIT_EXTERN NSString * const UITextViewTextDidEndEditingNotification; //TextView结束编辑 UIKIT_EXTERN NSString *const UIWindowDidBecomeVisibleNotification; //window激活并展示在界面的时候触发 UIKIT_EXTERN NSString *const UIWindowDidBecomeHiddenNotification; //当window隐藏的时候触发 UIKIT_EXTERN NSString *const UIWindowDidBecomeKeyNotification; //当window被设置为keyWindow时触发 UIKIT_EXTERN NSString *const UIWindowDidResignKeyNotification; //当window的key位置被取代时触发 UIKIT_EXTERN NSString *const UIKeyboardWillShowNotification; //键盘将弹出 UIKIT_EXTERN NSString *const UIKeyboardDidShowNotification; //键盘弹出 UIKIT_EXTERN NSString *const UIKeyboardWillHideNotification; //键盘将要隐藏 UIKIT_EXTERN NSString *const UIKeyboardDidHideNotification; //键盘隐藏 UIKIT_EXTERN NSString *const UIKeyboardWillChangeFrameNotification //键盘frame将发生改变 UIKIT_EXTERN NSString *const UIKeyboardDidChangeFrameNotification //键盘frame发生改变后 //日期，时间 FOUNDATION_EXPORT NSString * const NSCalendarDayChangedNotification //日期发生改变 FOUNDATION_EXPORT NSString * const NSSystemClockDidChangeNotification //系统时钟发生改变 FOUNDATION_EXPORT NSString * const NSSystemTimeZoneDidChangeNotification //系统时区发生改变 //线程 FOUNDATION_EXPORT NSString * const NSWillBecomeMultiThreadedNotification; //将变成多线程 FOUNDATION_EXPORT NSString * const NSDidBecomeSingleThreadedNotification; //变成了单线程 FOUNDATION_EXPORT NSString * const NSThreadWillExitNotification; //线程退出 //程序 UIKIT_EXTERN NSString *const UIApplicationDidEnterBackgroundNotification //程序进入后台 UIKIT_EXTERN NSString *const UIApplicationWillEnterForegroundNotification //程序将进入前台 UIKIT_EXTERN NSString *const UIApplicationDidFinishLaunchingNotification; //程序加载完成 UIKIT_EXTERN NSString *const UIApplicationDidBecomeActiveNotification; //程序变成激活状态 UIKIT_EXTERN NSString *const UIApplicationWillResignActiveNotification; //程序将失去激活状态 UIKIT_EXTERN NSString *const UIApplicationDidReceiveMemoryWarningNotification; //接收到内存警告 UIKIT_EXTERN NSString *const UIApplicationWillTerminateNotification; //程序将终止 UIKIT_EXTERN NSString *const UIApplicationSignificantTimeChangeNotification; //新的一天开始或时区发生变化 UIKIT_EXTERN NSString *const UIApplicationWillChangeStatusBarOrientationNotification; //将改变状态栏方向 UIKIT_EXTERN NSString *const UIApplicationDidChangeStatusBarOrientationNotification; //状态栏方向以改变 UIKIT_EXTERN NSString *const UIApplicationWillChangeStatusBarFrameNotification; //将改变状态栏frame UIKIT_EXTERN NSString *const UIApplicationDidChangeStatusBarFrameNotification; //状态栏frame发生改变 UIKIT_EXTERN NSString *const UIApplicationBackgroundRefreshStatusDidChangeNotification //后台刷新状态改变 UIKIT_EXTERN NSString *const UIApplicationUserDidTakeScreenshotNotification //截屏时触发通知 //其它 UIKIT_EXTERN NSString *const UILocalNotificationDefaultSoundName //本地通知声音 UIKIT_EXTERN NSString *const UIPasteboardChangedNotification; //粘贴板发生改变 UIKIT_EXTERN NSString *const UIPasteboardRemovedNotification; //粘贴板内容移除 FOUNDATION_EXPORT NSString * const NSUserDefaultsDidChangeNotification; //NSUserDefaults发生改变 FOUNDATION_EXPORT NSString * const NSBundleDidLoadNotification; //bundle加载完成","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"Java入门教程之面向对象","date":"2017-08-05T16:00:25.000Z","path":"2017/08/06/Java/2017-08-06-面向对象/","text":"什么是对象万物皆对象,客观存在的事物皆为对象 什么是面向对象什么是对象的属性对象具有的各种特征每个对象的每个属性都拥有特定值 什么事对象的方法对象执行的操作 类和对象的关系类是抽象的概念,仅仅是模板 成员变量在类中定义,用来描述对象将要有什么 局部变量在类的方法中定义,在方法中临时保存数据 构造方法使用new+构造方法 创建一个新的对象构造方法是定义在Java类中的一个用来初始化对象的方法构造方法与类同名且没有返回值 构造方法的重载方法名相同,但参数不同的多个方法,调用时会自动根据不同的参数选择相应的方法 ## 类类是模子,确定对象将会拥有的特征(属性)和行为(方法)类的特点: 类是对象的类型 具有相同属性和方法的一组对象的集合","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"安卓初级开发之使用Fragment建立动态UI","date":"2017-07-23T07:55:54.000Z","path":"2017/07/23/android/2017-07-23/","text":"创建 Fragment 可以把 Fragment 想象成 Activity 的模块，它拥有自己的生命周期、接收输入事件，可以在 Acvitity 运行过程中添加或者移除（有点像“子 Activity”，可以在不同的 Activity 里重复使用）。这一课教我们将学习继承 Support Library中的 Fragment，使 APP 在 Android 1.6 这样的低版本上仍能保持兼容。 在开始之前，必须在项目中先引用 Support Library。如果你从未使用过 Support Library，可根据文档 设置 Support Library 在项目中使用 v4 库。当然，也可以使用包含 APP Bar 的 v7 appcompat 库。该库兼容 Android 2.1 (API level 7)，同时也包含了 Fragment API。 创建 Fragment 类 首先从 Fragment 继承并创建 Fragment，然后在关键的生命周期方法中插入代码（就和在处理 Activity 时一样）。 其中一个区别是：创建 Fragment 时，必须重写 onCreateView() 回调方法来定义布局。事实上，这是唯一一个为使 Fragment 运行起来需要重写的回调方法。比如，下面是一个自定义布局的示例 Fragment：","tags":[{"name":"Android","slug":"Android","permalink":"https://www.devzou.com/tags/Android/"}]},{"title":"python的import机制","date":"2017-07-04T00:10:09.000Z","path":"2017/07/04/python/2017-07-10- python 的import机制/","text":"python中，每个py文件被称之为模块，每个具有init.py文件的目录被称为包。只要模块或者包所在的目录在sys.path中，就可以使用import 模块或import 包来使用。 如果想使用非当前模块中的代码，需要使用Import，这个大家都知道。如果你要使用的模块（py文件）和当前模块在同一目录，只要import相应的文件名就好，比如在a.py中使用b.py：import b但是如果要import一个不同目录的文件(例如b.py)该怎么做呢？首先需要使用sys.path.append方法将b.py所在目录加入到搜素目录中。然后进行import即可，例如import syssys.path.append(‘c:\\xxxx\\b.py’) # 这个例子针对 windows 用户来说的大多数情况，上面的代码工作的很好。但是如果你没有发现上面代码有什么问题的话，可要注意了，上面的代码有时会找不到模块或者包（ImportError: No module named xxxxxx），这是因为：sys模块是使用c语言编写的，因此字符串支持 ‘\\n’, ‘\\r’, ‘\\t’等来表示特殊字符。所以上面代码最好写成：sys.path.append(‘c:\\xxx\\b.py’)或者sys.path.append(‘c:/xxxx/b.py’)这样可以避免因为错误的组成转义字符，而造成无效的搜索目录（sys.path）设置。","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"学习numpy","date":"2017-07-04T00:10:09.000Z","path":"2017/07/04/machinelearning/2017-07-05-numpy/","text":"Numpy简介Numpy是一个用python实现的科学计算包。包括：1、一个强大的N维数组对象Array；2、比较成熟的（广播）函数库；3、用于整合C/C++和Fortran代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数。numpy和稀疏矩阵运算包scipy配合使用更加方便。NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库。专为进行严格的数字处理而产生。多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore，NASA用其处理一些本来使用C++，Fortran或Matlab等所做的任务。 基础篇NumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。 方法简介ndarray.ndim 数组轴的个数，在python的世界中，轴的个数被称作秩ndarray.shape 数组的维度。这是一个指示数组在每个维度上大小的整数元组。例如一个n排m列的矩阵，它 的shape属性将是(2,3),这个元组的长度显然是秩，即维度或者ndim属性ndarray.size 数组元素的总个数，等于shape属性中元组元素的乘积。ndarray.dtype 一个用来描述数组中元素类型的对象，可以通过创造或指定dtype使用标准Python类型。 另外NumPy提供它自己的数据类型。ndarray.itemsize 数组中每个元素的字节大小。例如，一个元素类型为float64的数组itemsiz属性值为 8(=64/8),又如，一个元素类型为complex32的数组item属性为4(=32/8)ndarray.data 包含实际数组元素的缓冲区，通常我们不需要使用这个属性，因为我们总是通过索引来使 用数组中的元素。 创建数组创建一维数组1234&gt;&gt;&gt;import numpy as np&gt;&gt;&gt;a=np.array([1,2,3])&gt;&gt;&gt;a[1, 2, 3] 创建二维数组12&gt;&gt;&gt; b = array( [ (1.5,2,3), (4,5,6) ] )&gt;&gt;&gt; b [[ 1.5 2. 3. ] [ 4. 5. 6. ]]数组类型可以在创建时显示指定123import numpy as npa=np.array([ (1.5,2,3),(4,5,6)],dtype=complex)print a [[ 1.5+0.j 2.0+0.j 3.0+0.j] [ 4.0+0.j 5.0+0.j 6.0+0.j]]通常，数组的元素开始都是未知的，但是它的大小已知。因此，NumPy提供了一些使用占位符创建数组的函数。这最小化了扩展数组的需要和高昂的运算代价。为了创建一个数列，NumPy提供一个类似arange的函数返回数组而不是列表:123import numpy as npa=np.arange(10,30,5)print a [10 15 20 25]当 arange 使用浮点数参数时，由于有限的浮点数精度，通常无法预测获得的元素个数。因此，最好使用函数 linspace 去接收我们想要的元素个数来代替用range来指定步长。 基本运算数组的算术运算是按元素的。新的数组被创建并且被结果填充。12345import numpy as npa=np.array([2,4,6])b=np.array([1,3,5])print a-bprint b**2 [1 1 1][ 1 9 25]有些操作符像 += 和 *= 被用来更改已存在数组而不创建一个新的数组。1234import numpy as npa=np.array([2,4,6])b=np.array([1,3,5])a*=3 [ 6 12 18]当运算的是不同类型的数组时，结果数组和更普遍和精确的已知(这种行为叫做upcast)。123456import numpy as npa=np.linspace(0,np.pi,3)b=np.ones(3,dtype=np.int32)print aprint bprint a+b [ 0. 1.57079633 3.14159265][1 1 1][ 1. 2.57079633 4.14159265] 通用函数(ufunc)NumPy提供常见的数学函数如 sin , cos 和 exp 。在NumPy中，这些叫作“通用函数”(ufunc)。在NumPy里这些函数作用按数组的元素运算，产生一个数组作为输出。12345import numpy as npa=np.array([1,2,3])print np.exp(a)print np.sqrt(a)print np.square(a) [ 2.71828183 7.3890561 20.08553692][ 1. 1.41421356 1.73205081][1 4 9]更多函数all, alltrue, any, apply along axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, conjugate, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sometrue, sort, std, sum, trace, transpose, var, vdot, vectorize, where 参见NumPy示例 索引，切片和迭代一维 数组可以被索引、切片和迭代，就像 列表 和其它Python序列。1234567import numpy as npa=np.arange(10)print aprint a**3print a[2]print a[2:8]print a[::-1] [0 1 2 3 4 5 6 7 8 9][ 0 1 8 27 64 125 216 343 512 729]2[2 3 4 5 6 7][9 8 7 6 5 4 3 2 1 0]多维 数组可以每个轴有一个索引。这些索引由一个逗号分割的元组给出。 tile函数1234567891011121314151617&gt;&gt;&gt; import numpy &gt;&gt;&gt; numpy.tile([0,0],5)#在列方向上重复[0,0]5次，默认行1次 array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) &gt;&gt;&gt; numpy.tile([0,0],(1,1))#在列方向上重复[0,0]1次，行1次 array([[0, 0]]) &gt;&gt;&gt; numpy.tile([0,0],(2,1))#在列方向上重复[0,0]1次，行2次 array([[0, 0], [0, 0]]) &gt;&gt;&gt; numpy.tile([0,0],(3,1)) array([[0, 0], [0, 0], [0, 0]]) &gt;&gt;&gt; numpy.tile([0,0],(1,3))#在列方向上重复[0,0]3次，行1次 array([[0, 0, 0, 0, 0, 0]]) &gt;&gt;&gt; numpy.tile([0,0],(2,3))#在列方向上重复[0,0]3次，行2次&lt;/span&gt; array([[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]])","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"python中range()函数的用法及数组的操作","date":"2017-07-04T00:10:09.000Z","path":"2017/07/04/python/2017-07-05-python中range()函数的用法/","text":"1range(1,6) #代表从1到6(不包含6) [1, 2, 3, 4, 5]1range(1,6,2) #代表从1到6，间隔2(不包含6) [1, 3, 5]1range(6) #代表从0到6(不包含6) 数组的操作12array = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]array[0:] #列出0以后的 [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]1array[1:] #列出1以后的 [3, 5, 7, 9, 2, 4, 6, 8, 0]1array[:-1] #列出-1之前的 [1, 3, 5, 7, 9, 2, 4, 6, 8]1array[3:-3] #列出3到-3之间的 [7, 9, 2, 4]1array[::2] #[1, 5, 9, 4, 8] 1array[::3]#[1, 7, 4, 0] 1array[::-1]#数组逆序,[0, 8, 6, 4, 2, 9, 7, 5, 3, 1]","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"iTerm2终端配色","date":"2017-07-04T00:10:09.000Z","path":"2017/07/04/tool/2017-07-04-iTerm2终端配色 /","text":"修改 .bash_profile 配置文件, 具体作用看每行注释 (保留英文原文)1vi ~/.bash_profile 添加如下内容12345678# enables colorin the terminal bash shell exportexport CLICOLOR=1# sets up thecolor scheme for list exportexport LSCOLORS=gxfxcxdxbxegedabagacad# sets up theprompt color (currently a green similar to linux terminal)export PS1='\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;36m\\]\\w\\[\\033[00m\\]\\$ '# enables colorfor iTermexport TERM=xterm-color 保存退出, 使其生效1source ~/.bash_profile 设置iTerm2使其生效121. preference-&gt;profiles-&gt;Default-&gt;Terminal-&gt;xterm-new 设置终端类型2. preference-&gt;profiles-&gt;Default-&gt;Colors 选择一个自己喜欢的配色 下载配色文件, 里面包含多种配色方案Github地址: https://github.com/mbadolato/iTerm2-Color-Schemes","tags":[{"name":"Tool","slug":"Tool","permalink":"https://www.devzou.com/tags/Tool/"}]},{"title":"xcodebuild指令详解","date":"2017-06-28T14:47:52.000Z","path":"2017/06/28/ios/2017-06-28-xcodebuild指令详解/","text":"xcodebuild 简介xcodebuild 是苹果提供的打包项目或者工程的命令，了解该命令最好的方式就是使用 man xcodebuild 查看其 man page. 尽管是英文，一定要老老实实的读一遍就好了。官方文档 使用说明1.需要在包含 name.xcodeproj 的目录下执行 xcodebuild 命令，且如果该目录下有多个 projects，那么需要使用 -project 指定需要 build 的项目。2.在不指定 build 的 target 的时候，默认情况下会 build project 下的第一个 target3.当 build workspace 时，需要同时指定 -workspace 和 -scheme 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。4.有一些诸如 -list, -showBuildSettings, -showsdks 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用 解析官方文档123456789101112131415161718192021222324NAMExcodebuild – build Xcode projects and workspacesSYNOPSIS1. xcodebuild [-project name.xcodeproj] [[-target targetname] … | -alltargets] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]2. xcodebuild [-project name.xcodeproj] -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]3. xcodebuild -workspace name.xcworkspace -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]4. xcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]5. xcodebuild -showsdks6. xcodebuild -showBuildSettings [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]]7. xcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace]8. xcodebuild -exportArchive -archivePath xcarchivepath -exportPath destinationpath -exportOptionsPlist path9. xcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] …]1. xcodebuild -importLocalizations -project name.xcodeproj -localizationPath path 挑几个我常用的形式介绍一下，较长的使用方式以序列号代替: xcodebuild [-project name.xcodeproj] [[-target targetname] … | -alltargets] build: 上述序号1的使用方式，会 build 指定 project，其中 -target 和 -configuration 参数可以使用 xcodebuild -list 获得，-sdk 参数可由 xcodebuild -showsdks 获得，[buildsetting=value …] 用来覆盖工程中已有的配置。 action… 的可用选项如下, 打包的话当然用 build，这也是默认选项。 xcodebuild -showsdks: 列出 Xcode 所有可用的 SDKs xcodebuild -showBuildSettings: 上述序号6的使用方式，查看当前工程 build setting 的配置参数，Xcode 详细的 build setting 参数参考官方文档 Xcode Build Setting Reference， 已有的配置参数可以在终端中以 buildsetting=value 的形式进行覆盖重新设置. xcodebuild -list: 上述序号7的使用方式，查看 project 中的 targets 和 configurations，或者 workspace 中 schemes, 输出如下: 1234567891011121314Information about project &quot;lezu&quot;: Targets: lezu lezuTests lezuUITests Build Configurations: Debug Release If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used. Schemes: lezu xcodebuild -workspace name.xcworkspace -scheme schemename build: 上述序号3的使用方式，build 指定 workspace，当我们使用 CocoaPods 来管理第三方库时，会生成 xcworkspace 文件，这样就会用到这种打包方式. 实例以一个实际工程举例，该工程的名字叫 lezu。Scheme 名字也是 lezu。 那么 archive 的命令如下xcodebuild -scheme lezu -archivePath build/lezu.xcarchive archive导出 ipa 包的命令如下xcodebuild -exportArchive -exportFormat IPA -archivePath build/lezu.xcarchive -exportPath build/lezu.ipaxcodebuild -exportArchive -archivePath lezu -exportPath lezu -exportOptionsPlist path依次执行完这两个命令后，工程根路径下的 build 文件夹内容如下图。 导出 ipa 包后，就可以利用 iTools 之类的软件直接安装到对应的 iPhone ，或者利用 items-service 协议来远程安装。使用xcodebuild和xcrun打包签名","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"手把手教你封装一个二维码扫描工具","date":"2017-06-28T14:01:40.000Z","path":"2017/06/28/ios/2017-06-28-手把手教你封装一个二维码扫描工具/","text":"前言没有美工给切图，只能自食其力去挖别人家的墙角去了😜,https://pan.baidu.com/s/1mi5Jiac密码: rtic 这里提取的是支付宝里的素材。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"安卓初级开发之适配不同的屏幕","date":"2017-06-18T00:21:07.000Z","path":"2017/06/18/android/2017-06-18/","text":"使用“wrap_content”和“match_parent”为了确保你的布局能灵活的适应不同的屏幕尺寸，针对一些view组件，你应该使用wrap_content和match_parent来设置他们的宽和高。如果你使用了wrap_content，view的宽和高会被设置为该view所包含的内容的大小值。如果是match_parent（在API 8之前是fill_parent）则会匹配该组件的父控件的大小。通过使用wrap_content和match_parent尺寸值代替硬编码的尺寸，你的视图将分别只使用控件所需要的空间或者被拓展以填充所有有效的空间。 使用相对布局（RelativeLayout）你可以使用LinearLayout以及wrap_content和match_parent组合来构建复杂的布局，但是LinearLayout却不允许你精准的控制它子view的关系，子view在LinearLayout中只能简单一个接一个的排成行。如果你需要你的子view不只是简简单单的排成行的排列，更好的方法是使用RelativeLayout，它允许你指定你布局中控件与控件之间的关系，比如，你可以指定一个子view在左边，另一个则在屏幕的右边。 使用尺寸限定词（译者注：这里的限定词主要是指在编写布局文件时，将布局文件放在加上类似large，sw600dp等这样限定词的文件夹中，以此来告诉系统根据屏幕选择对应的布局文件，比如下面例子的layout-large文件夹）从上一节的学习里程中，我们知道如何编写灵活的布局或者相对布局，它们都能通过拉伸或者填充控件来适应不同的屏幕，但是它们却不能为每个不同屏幕尺寸提供最好的用户体验。因此，你的应用不应该只是实现灵活的布局，同时也应该为不同的屏幕配置提供几种不同的布局方式。你可以通过配置限定（configuration qualifiers）来做这件事情，它能在运行时根据你当前设备的配置（比如不同的屏幕尺寸设计了不同的布局）来选择合适的布局资源。 ConstraintLayoutConstraintlayout是功能强大的新类，可以想象一个在类固醇上的Relativelayout——对，这就是Constraintlayout。它允许我们使用‘约束’放置子视图来定义基于布局中不同视图之间的相对关系的位置。ConstraintLayout的目标是帮助减少嵌套视图的数量，这样可以改善布局文件的性能。布局类还使得我们更加轻松的定义布局，相比使用RelativeLayout时，因为我们现在可以固定一个视图的任意一边与另一的视图的任何边，而不必将整个视图防止到另一个的任何边。例如，相对布局的属性允许我们放置视图：layout_toRightOfayout_toLeftOflayout_toTopOflayout_toBottomOf然而，ConstraintLayout用于更多的特性：layout_constraintTop_toTopOf — 期望视图的上边对齐另一个视图的上边。layout_constraintTop_toBottomOf — 期望视图的上边对齐另一个视图的底边。layout_constraintTop_toLeftOf — 期望视图的上边对齐另一个视图的左边。layout_constraintTop_toRightOf — 期望视图的上边对齐另一个视图的右边。layout_constraintBottom_toTopOf — 期望视图的下边对齐另一个视图的上边。layout_constraintBottom_toBottomOf — 期望视图的底边对齐另一个视图的底边。layout_constraintBottom_toLeftOf — 期望视图的底边对齐另一个视图的左边。layout_constraintBottom_toRightOf — 期望视图的底边对齐另一个视图的右边。layout_constraintLeft_toTopOf — 期望视图的左边对齐另一个视图的上边。layout_constraintLeft_toBottomOf — 期望视图的左边对齐另一个视图的底边。layout_constraintLeft_toLeftOf — 期望视图的左边对齐另一个视图的左边。layout_constraintLeft_toRightOf — 期望视图的左边对齐另一个视图的右边。layout_constraintRight_toTopOf — 期望视图的右边对齐另一个视图的上边。layout_constraintRight_toBottomOf — 期望视图的右边对齐另一个视图的底边。layout_constraintRight_toLeftOf — 期望视图的右边对齐另一个视图的左边。layout_constraintRight_toRightOf — 期望视图的右边对齐另一个视图的右边。如果需要，属性支持开始和结尾也可用在左和右对齐。唷，很多属性，对吧？这些属性对于ConstraintLayout内视图的位置，提供了巨大的控制力。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.devzou.com/tags/Android/"}]},{"title":"安卓初级开发之适配不同的设备","date":"2017-06-17T11:51:57.000Z","path":"2017/06/17/android/2017-06-17-初级开发之适配不同的设备/","text":"适配不同的屏幕Android用尺寸和分辨率这两种常规属性对不同的设备屏幕加以分类。我们应该想到自己的app会被安装在各种屏幕尺寸和分辨率的设备中。这样，app中就应该包含一些可选资源，针对不同的屏幕尺寸和分辨率，来优化其外观。有4种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)4种普遍分辨率：低精度(ldpi), 中精度(mdpi), 高精度(hdpi), 超高精度(xhdpi)声明针对不同屏幕所用的layout和bitmap，必须把这些可选资源放置在独立的目录中，这与适配不同语言时的做法类似。同样要注意屏幕的方向(横向或纵向)也是一种需要考虑的屏幕尺寸变化，因此许多app会修改layout，来针对不同的屏幕方向优化用户体验。 创建不同的layout为了针对不同的屏幕去优化用户体验，我们需要为每一种将要支持的屏幕尺寸创建唯一的XML文件。每一种layout需要保存在相应的资源目录中，目录以-为后缀命名。例如，对大尺寸屏幕(large screens)，一个唯一的layout文件应该保存在res/layout-large/中。 【注】为了匹配合适的屏幕尺寸Android会自动地测量我们的layout文件。所以不需要因不同的屏幕尺寸去担心UI元素的大小，而应该专注于layout结构对用户体验的影响。(比如关键视图相对于同级视图的尺寸或位置)例如，这个工程包含一个默认layout和一个适配大屏幕的layout：123456MyProject/ res/ layout/ main.xml layout-large/ main.xml layout文件的名字必须完全一样，为了对相应的屏幕尺寸提供最优的UI，文件的内容不同。如平常一样在app中简单引用：12345@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main);&#125; 系统会根据app所运行的设备屏幕尺寸，在与之对应的layout目录中加载layout。更多关于Android如何选择恰当资源的信息，详见Providing Resources。另一个例子，这一个工程中有为适配横向屏幕的layout:123456MyProject/ res/ layout/ main.xml layout-land/ main.xml 默认的，layout/main.xml文件用作竖屏的layout。如果想给横屏提供一个特殊的layout，也适配于大屏幕，那么则需要使用large和land修饰符。 12345678910MyProject/ res/ layout/ # default (portrait) main.xml layout-land/ # landscape main.xml layout-large/ # large (portrait) main.xml layout-large-land/ # large landscape main.xml 创建不同的bitmap我们应该为4种普遍分辨率:低，中，高，超高精度，都提供相适配的bitmap资源。这能使我们的app在所有屏幕分辨率中都能有良好的画质和效果。要生成这些图像，应该从原始的矢量图像资源着手，然后根据下列尺寸比例，生成各种密度下的图像。xhdpi: 2.0hdpi: 1.5mdpi: 1.0 (基准)ldpi: 0.75 这意味着，如果针对xhdpi的设备生成了一张200x200的图像，那么应该为hdpi生成150x150,为mdpi生成100x100, 和为ldpi生成75x75的图片资源。然后，将这些文件放入相应的drawable资源目录中:12345678910MyProject/ res/ drawable-xhdpi/ awesomeimage.png drawable-hdpi/ awesomeimage.png drawable-mdpi/ awesomeimage.png drawable-ldpi/ awesomeimage.png 任何时候，当引用@drawable/awesomeimage时系统会根据屏幕的分辨率选择恰当的bitmap。【注】低密度(ldpi)资源是非必要的，当提供了hdpi的图像，系统会把hdpi的图像按比例缩小一半，去适配ldpi的屏幕 适配不同的系统版本新的Android版本会为我们的app提供更棒的APIs，但我们的app仍应支持旧版本的Android，直到更多的设备升级到新版本为止。这节课程将展示如何在利用新的APIs的同时仍支持旧版本Android。Platform Versions的控制面板会定时更新，通过统计访问Google Play Store的设备数量，来显示运行每个版本的安卓设备的分布。一般情况下，在更新app至最新Android版本时，最好先保证新版的app可以支持90%的设备使用。【建议】为了能在几个Android版本中都能提供最好的特性和功能，应该在我们的app中使用Android Support Library，它能使我们的app能在旧平台上使用最近的几个平台的APIs。 指定最小和目标API级别AndroidManifest.xml文件中描述了我们的app的细节及app支持哪些Android版本。具体来说，元素中的minSdkVersion和targetSdkVersion 属性，标明在设计和测试app时，最低兼容API的级别和最高适用的API级别(这个最高的级别是需要通过我们的测试的)。例如1234&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ... &gt; &lt;uses-sdk android:minSdkVersion=\"4\" android:targetSdkVersion=\"15\" /&gt; ...&lt;/manifest&gt; 随着新版本Android的发布，一些风格和行为可能会改变，为了能使app能利用这些变化，而且能适配不同风格的用户的设备，我们应该将targetSdkVersion的值尽量的设置与最新可用的Android版本匹配。 运行时检查系统版本Android在Build常量类中提供了对每一个版本的唯一代号，在我们的app中使用这些代号可以建立条件，保证依赖于高级别的API的代码，只会在这些API在当前系统中可用时，才会执行。1234567private void setUpActionBar() &#123; // Make sure we're running on Honeycomb or higher to use ActionBar APIs if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; ActionBar actionBar = getActionBar(); actionBar.setDisplayHomeAsUpEnabled(true); &#125;&#125; 【注】当解析XML资源时，Android会忽略当前设备不支持的XML属性。所以我们可以安全地使用较新版本的XML属性，而不需要担心旧版本Android遇到这些代码时会崩溃。例如如果我们设置targetSdkVersion=”11”，app会在Android 3.0或更高时默认包含ActionBar。然后添加menu items到action bar时，我们需要在自己的menu XML资源中设置android:showAsAction=”ifRoom”。在跨版本的XML文件中这么做是安全的，因为旧版本的Android会简单地忽略showAsAction属性(就是这样，你并不需要用到res/menu-v11/中单独版本的文件) 使用平台风格和主题Android提供了用户体验主题，为app提供基础操作系统的外观和体验。这些主题可以在manifest文件中被应用于app中。通过使用内置的风格和主题，我们的app自然地随着Android新版本的发布，自动适配最新的外观和体验. 使activity看起来像对话框:1&lt;activity android:theme=\"@android:style/Theme.Dialog\"&gt; 使activity有一个透明背景:1&lt;activity android:theme=\"@android:style/Theme.Translucent\"&gt; 应用在/res/values/styles.xml中定义的自定义主题:1&lt;activity android:theme=\"@style/CustomTheme\"&gt; 更多关于创建和使用主题，详见Styles and Themes","tags":[{"name":"Android","slug":"Android","permalink":"https://www.devzou.com/tags/Android/"}]},{"title":"安卓初级开发之创建简单页面","date":"2017-06-17T00:24:04.000Z","path":"2017/06/17/android/2017-06-17-Android初级开发之创建简单页面/","text":"前言Android 的图形用户界面由多个视图(View)和视图组（ViewGroup)构建而成。View是通用的UI窗体小组件，如：按钮（Button）、文本框（Text field）；而ViewGroup则是用来定义子视图布局的不可见的容器，如：网格部件（grid）、垂直列表部件（vertical list）。Android提供了一系列对应于View和ViewGroup子类的XML标签，以便我们用XML创建自己的UI。Layouts是ViewGroup的子类。 做一个简单的登录页面1.在 Android Studio 中，从 res/layout 目录打开content_my.xml 文件。2.删除 [] 标签。3.添加一个文本输入框 EditText,并设置 id 属性为 @+id/edit_message4.设置 layout_width 和 layout_height 属性为 wrap_content。5.设置 hint 属性为一个名为 edit_message 的字符串。 ##属性说明android:id这是视图的唯一标识符。可以在程序代码中通过该标识符引用对象。例如对这个对象进行读和修改的操作（在下一课里将会用到）。当需要从 XML 里引用资源对象时，必须使用 @ 符号。紧随 @ 之后的是资源的类型（这里是 id），然后是资源的名字（这里使用的是 edit_username）。android:layout_width和android:layout_height不建议指定宽度和高度的具体尺寸，应使用 “wrap_content”。因为这样可以保证视图只占据内容大小的空间。如果你使用了 “match_parent”，这时 EditText 将会布满整个屏幕，因为它将适应父布局的大小。参见布局向导。android:hint当文本框为空的时候，会默认显示这个字符串。对于字符串 “@string/edit_message” 的值所引用的资源应该定义在单独的文件里，而不是直接使用字符串。因为使用的值是存在的资源，所以不需要使用 + 号。当然，由于你现在还没有定义字符串，所以在添加 @string/edit_message 的时候会出现编译错误。在下一节的教程中你将学会如何定义字符串资源，到时候就不会报错了。资源对象资源对象是与 APP 资源（如：位图、布局文件、字符串）关联的唯一整数。在项目文件 gen/R.java 中，每个资源都有一个与之对应的资源对象。你可以使用 R 类中的对象名称代指资源（如：在指定 android:hint 属性时需要的字符串）。同时，也可以通过 android:id 属性随时为 View 创建资源 ID，以便在代码中引用这个 View。每次编译 APP 时，SDK 工具都会生成 R.java 文件。所以，请永远不要修改这个文件。参阅资源配备。 增加字符串资源默认情况下，你的 Android 项目包含一个字符串资源文件，即 res/values/string.xml。打开这个文件，为 “edit_username” 增加一个定义，其值为“请输入用户名”。在 Android Studio 里，编辑 res/values 下的 strings.xml 文件。1.添加一个名为 “edit_username” 的字符串，值为“请输入用户名”。2.再添加一个名为 “button_login” 的字符串，值为“登录”。3.下一节中将使用这个字符串创建按钮。下边就是修改好的 res/values/strings.xml：1234567&lt;resources&gt; &lt;string name=\"app_name\"&gt;My Application&lt;/string&gt; &lt;string name=\"action_settings\"&gt;Settings&lt;/string&gt; &lt;string name=\"edit_login\" /&gt; &lt;string name=\"edit_username\"&gt;请输入用户名&lt;/string&gt; &lt;string name=\"button_login\"&gt;登录&lt;/string&gt;&gt;&lt;/resources&gt; 当你在用户界面定义一个文本时，应该把每一个文本字符串列入资源文件。这样做的好处是：对于所有字符串值，字符串资源能够单独的修改，在资源文件里你可以很容易的找到并且做出相应的修改。通过选择定义每个字符串，还允许你用不同语言本地化 APP。 更多关于不同语言本字符串资源本地化的问题，请参考兼容不同的设备。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.devzou.com/tags/Android/"}]},{"title":"NSInvocation的基本使用","date":"2017-06-17T00:10:09.000Z","path":"2017/06/17/ios/2017-07-27-NSInvocation的基本使用/","text":"前言NSInvocation是一个消息调用类，它包含了所有OC消息的成分：target、selector、参数以及返回值。NSInvocation可以将消息转换成一个对象，消息的每一个参数能够直接设定，而且当一个NSInvocation对象调度时返回值是可以自己设定的。一个NSInvocation对象能够重复的调度不同的目标(target)，而且它的selector也能够设置为另外一个方法签名。NSInvocation遵守NSCoding协议，但是仅支持NSPortCoder编码，不支持归档型操作。 NSInvocation的接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@interface NSInvocation : NSObject &#123;@private __strong void *_frame; __strong void *_retdata; id _signature; id _container; uint8_t _retainedArgs; uint8_t _reserved[15];&#125;// 通过NSMethodSignature对象创建NSInvocation对象，NSMethodSignature为方法签名类+ (NSInvocation *)invocationWithMethodSignature:(NSMethodSignature *)sig;// 获取NSMethodSignature对象@property (readonly, retain) NSMethodSignature *methodSignature;// 保留参数，它会将传入的所有参数以及target都retain一遍- (void)retainArguments;// 判断参数是否还存在// 调用retainArguments之前，值为NO，调用之后值为YES@property (readonly) BOOL argumentsRetained;// 设置消息调用者，注意：target最好不要是局部变量@property (nullable, assign) id target;// 设置要调用的消息@property SEL selector;// 获取消息返回值- (void)getReturnValue:(void *)retLoc;// 设置消息返回值- (void)setReturnValue:(void *)retLoc;// 获取消息参数- (void)getArgument:(void *)argumentLocation atIndex:(NSInteger)idx;// 设置消息参数- (void)setArgument:(void *)argumentLocation atIndex:(NSInteger)idx;// 发送消息，即执行方法- (void)invoke;// target发送消息，即target执行方法- (void)invokeWithTarget:(id)target;@end NSMethodSignature的接口12345678910111213141516171819202122232425262728@interface NSMethodSignature : NSObject &#123;@private void *_private; void *_reserved[6];&#125;// 通过Objective-C类型编码(Objective-C Type Encodings)创建一个NSMethodSignature对象+ (nullable NSMethodSignature *)signatureWithObjCTypes:(const char *)types;// 方法参数个数@property (readonly) NSUInteger numberOfArguments;// 获取参数类型- (const char *)getArgumentTypeAtIndex:(NSUInteger)idx NS_RETURNS_INNER_POINTER;// 获取方法的长度@property (readonly) NSUInteger frameLength;// 是否是单向- (BOOL)isOneway;// 获取方法返回值类型@property (readonly) const char *methodReturnType NS_RETURNS_INNER_POINTER;// 获取方法返回值的长度@property (readonly) NSUInteger methodReturnLength;@end NSInvocation的使用方法 使用步骤 根据方法创建签名对象(NSMethodSignature对象) 根据签名对象创建调用对象(NSInvocation对象) 设置调用对象(NSInvocation对象)的相关信息 调用方法 获取方法返回值 调用无参无返回值的方法 12345678910111213141516- (void)invocation1 &#123; // 1. 根据方法创建签名对象sig NSMethodSignature *sig = [[self class] instanceMethodSignatureForSelector:@selector(method)]; // 2. 根据签名对象创建调用对象invocation NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig]; // 3. 设置调用对象的相关信息 // 注意：target不要设置成局部变量 invocation.target = self; invocation.selector = @selector(method); //4. 调用方法 [invocation invoke];&#125;- (void)method &#123; NSLog(@\"无参无返回值\");&#125; 调用有参无返回值的方法1234567891011121314151617181920- (void)invocation2 &#123; // 1. 根据方法创建签名对象sig NSMethodSignature *sig = [[self class] instanceMethodSignatureForSelector:@selector(methodWithArg1:arg2:)]; // 2. 根据签名对象创建调用对象invocation NSInvocation *invocation =[NSInvocation invocationWithMethodSignature:sig]; // 3. 设置调用对象的相关信息 invocation.target = self; invocation.selector = @selector(methodWithArg1:arg2:); NSString *name = @\"SJM\"; int age = 18; // 参数必须从第2个索引开始，因为前两个已经被target和selector使用 [invocation setArgument:&amp;name atIndex:2]; [invocation setArgument:&amp;age atIndex:3]; // 4. 调用方法 [invocation invoke];&#125;- (void)methodWithArg1:(NSString *)arg1 arg2:(int)arg2 &#123; NSLog(@\"我叫%@，今年%d岁。\", arg1, arg2);&#125; 调用有参有返回值的方法12345678910111213141516171819202122232425262728- (void)invocation3 &#123; // 1. 根据方法创建签名对象sig NSMethodSignature *sig = [[self class] instanceMethodSignatureForSelector:@selector(methodWithArg1:arg2:arg3:)]; // 2. 根据签名对象创建调用对象invocation NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig]; // 3. 设置调用对象的相关信息 invocation.target = self; invocation.selector = @selector(methodWithArg1:arg2:arg3:); int value1 = 111; int value2 = 999; int value3 = 666; [invocation setArgument:&amp;value1 atIndex:2]; [invocation setArgument:&amp;value2 atIndex:3]; [invocation setArgument:&amp;value3 atIndex:4]; // 4. 调用方法 [invocation invoke]; // 5. 获取方法返回值 NSNumber *num = nil; [invocation getReturnValue:&amp;num]; NSLog(@\"最大数为：%@\",num);&#125;- (NSNumber *)methodWithArg1:(int)arg1 arg2:(int)arg2 arg3:(int)arg3 &#123; int max1 = MAX(arg1, arg2); int max2 = MAX(arg2, arg3); // 返回最大数 return @(MAX(max1, max2));&#125; NSInvocation的其他属性与方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899- (void)invocation4 &#123; // 1. 根据方法创建一个签名对象sig NSMethodSignature *sig = [[self class] instanceMethodSignatureForSelector:@selector(methodWithArg1:arg2:arg3:)]; // 2. 根据签名对象创建调用对象invocation NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig]; // 3. 设置调用对象的相关信息 invocation.target = self; invocation.selector = @selector(methodWithArg1:arg2:arg3:); int value1 = 111; int value2 = 999; int value3 = 666; [invocation setArgument:&amp;value1 atIndex:2]; [invocation setArgument:&amp;value2 atIndex:3]; [invocation setArgument:&amp;value3 atIndex:4]; // 4. 调用方法，也可以使用invokeWithTarget:方法指定调用者 [invocation invoke]; // 5. 获取方法返回值 NSNumber *num = nil; [invocation getReturnValue:&amp;num]; NSLog(@\"最大数为：%@\",num);/* -------------------------------分隔线---------------------------------- */ // NSInvocation的其他属性 // argumentsRetained属性是判断参数是否还存在 // 调用retainArguments之前，值为NO，调用之后值为YES NSLog(@\"%@参数保留\", (invocation.argumentsRetained ? @\"有\" : @\"没有\")); [invocation retainArguments]; NSLog(@\"%@参数保留\", (invocation.argumentsRetained ? @\"有\" : @\"没有\")); // 获取参数值 if (invocation.argumentsRetained) &#123; int arg; [invocation getArgument:&amp;arg atIndex:4]; NSLog(@\"Argument ---- %d\",arg); &#125; // 设置方法返回值 NSNumber *value = @987; [invocation setReturnValue:&amp;value]; [invocation getReturnValue:&amp;value]; NSLog(@\"ReturnValue ---- %@\",value); // 关于NSMethodSignature对象 NSLog(@\"-------------关于NSMethodSignature对象---------------\"); [self methodSignature:invocation];&#125;- (NSNumber *)methodWithArg1:(int)arg1 arg2:(int)arg2 arg3:(int)arg3 &#123; int max1 = MAX(arg1, arg2); int max2 = MAX(arg2, arg3); // 返回最大数 return @(MAX(max1, max2));&#125;// NSMethodSignature的使用- (void)methodSignature:(NSInvocation *)invocation &#123; // 获取方法签名对象 NSMethodSignature *signature = invocation.methodSignature; // 获取方法所占字节数 NSUInteger frameLength = signature.frameLength; NSLog(@\"frameLength ---- %ld\",frameLength); // 获取方法返回值所占字节数 // 这里只对数值型的类型有效，OC类型打印都是8字节 NSUInteger returnLength = signature.methodReturnLength; NSLog(@\"returnLength ---- %ld\",returnLength); // 判断方法是否是单向 NSString *oneWay = [signature isOneway] ? @\"是\" : @\"不是\"; NSLog(@\"方法%@单向\", oneWay); // 获取参数个数 NSInteger count = signature.numberOfArguments; // 打印所有参数类型， // 这里打印的结果是 @ : i i i 它们是Objective-C类型编码 // @ 表示 NSObject* 或 id 类型 // : 表示 SEL 类型 // i 表示 int 类型 for (int i = 0; i &lt; (int)count; i++) &#123; const char *argTybe = [signature getArgumentTypeAtIndex:i]; NSLog(@\"参数类型 %s\",argTybe); &#125; // 获取返回值的类型 const char *returnType = [signature methodReturnType]; NSLog(@\"返回值的类型 %s\",returnType);&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"安卓初级开发之创建Android项目","date":"2017-06-16T14:33:27.000Z","path":"2017/06/16/android/2017-06-16-创建Android项目/","text":"使用Android Studio创建项目1.打开Android Studio 如下图所示选择第一项 Start a new Android Studio project2.点击next后进入如下界面Application Name此处填写想呈现给用户的应用名称，此处我们使用“MyApplication”。Company domain 包名限定符，Android Studio会将这个限定符应用于每个新建的Android项目。Package Name是应用的包命名空间（同Java的包的概念），该包名在同一Android系统上所有已安装的应用中具有唯一性，我们可以独立地编辑该包名。Project location操作系统存放项目的目录。点击右侧可修改目录如图所示3.点击next进入如下页面勾选phone and Tablet,不要勾选其他选项 (TV, Wear, and Glass)4.点击next进入下一个页面 选择Basic Activity5.点击next进入下一个页面将Activity Name 修改为MyActivity,点击finish即创建完成 查看源代码创建完成和生成的工程目录如下所示 app/manifests/AndroidManifest.xmlmanifest文件描述了项目的基本特征并列出了组成应用的各个组件，接下来的学习会更深入了解这个文件并添加更多组件到该文件中。 drawable/存放各种densities图像的文件夹，mdpi，hdpi等，这里能够找到应用运行时的图标文件ic_launcher.png activity_my.xml文件路径为app/src/main/res/layout/activity_my.xml这是刚才用Android Studio创建项目时新建的Activity对应的xml布局文件，按照创建新项目的流程，Android Studio会同时展示这个文件的文本视图和图形化预览视图，该文件包含一些默认设置和一个显示内容为“Hello world!”的TextView元素。 MyActivity.java路径为app/src/main/java/com.example.myApplication/MyActivity.java用Android Studio创建新项目完成后，可在Android Studio看到该文件对应的选项卡，选中该选项卡，可以看到刚创建的Activity类的定义。编译并运行该项目后，Activity启动并加载布局文件activity_my.xml，显示一条文本：”Hello world!” app/build.gradleAndroid Studio使用Gradle 编译运行Android工程. 工程的每个模块以及整个工程都有一个build.gradle文件。通常你只需要关注模块的build.gradle文件，该文件存放编译依赖设置，包括defaultConfig设置：compiledSdkVersion 是我们的应用将要编译的目标Android版本，此处默认为你的SDK已安装的最新Android版本(目前应该是4.1或更高版本，如果你没有安装一个可用Android版本，就要先用SDK Manager来完成安装)，我们仍然可以使用较老的版本编译项目，但把该值设为最新版本，可以使用Android的最新特性，同时可以在最新的设备上优化应用来提高用户体验。applicationId 创建新项目时指定的包名。minSdkVersion 创建项目时指定的最低SDK版本，是新建应用支持的最低SDK版本。targetSdkVersion 表示你测试过你的应用支持的最高Android版本(同样用API level表示).当Android发布最新版本后，我们应该在最新版本的Android测试自己的应用同时更新target sdk到Android最新版本，以便充分利用Android新版本的特性。 layout/存放用户界面文件，如前边提到的activity_my.xml，描述了MyActivity对应的用户界面。 menu/存放应用里定义菜单项的文件。 values/存放其他xml资源文件，如string，color定义。string.xml定义了运行应用时显示的文本”Hello world!”","tags":[{"name":"Android","slug":"Android","permalink":"https://www.devzou.com/tags/Android/"}]},{"title":"IDEA部署你的web项目","date":"2017-06-16T00:10:09.000Z","path":"2017/06/16/Java/2017-07-21-IDEA部署你的web项目/","text":"准备工作 下载tomcat http://tomcat.apache.org/","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"iOS读取文件方法","date":"2017-06-16T00:10:09.000Z","path":"2017/06/16/ios/2017-07-17-ios读取文件方法/","text":"读取json文件12NSData *JSONData = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"queryRecordResult\" ofType:@\"json\"]]; NSDictionary * paraseData = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingAllowFragments error:nil]; 读取plist文件12NSString * plistPath = [[NSBundle mainBundle] pathForResource:@\"moduleMap\" ofType:@\"plist\"];NSDictionary * moduleDict = [[NSDictionary alloc] initWithContentsOfFile:plistPath];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"排序算法","date":"2017-06-15T22:07:04.000Z","path":"2017/06/16/算法/2017-06-16-排序算法/","text":"选择排序一种最简单的排序算法是这样的: 首先,找到数组中最小的那个元素,其次,将它和数组的第一个元素交换位置 (如果第一个元素就是最小元素那么它就和自己交换)。再次,在剩下的元素中找到最小的元素,将它与数组的第二个元素位置交换 。如此往复, 直到将整个数组排序。这种方法叫做选择排序,因为它在不断地选择剩余元素之中的最小者。12345678910111213141516171819202122232425262728293031323334public class selectSort &#123; /* * 基本思路先找到数组中最小的元素，然后与数组的第一个元素交换，然后再找到剩下数组元素中的最小元素,与数组中的第二个元素位置交换 * */ public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] arr=&#123;4,8,2,47,56,3,9&#125;; System.out.println(\"交换之前：\"); for(int num:arr)&#123; System.out.print(num+\" \"); &#125; //选择排序的优化 for(int i = 0; i &lt; arr.length - 1; i++) &#123;// 做第i趟排序 int k = i; //用k 来标记最小元素的下标 for(int j = k + 1; j &lt; arr.length; j++)&#123;// 选最小的记录 if(arr[j] &lt; arr[k])&#123; k = j; //记下目前找到的最小值所在的位置 &#125; &#125; //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换 if(i != k)&#123; //交换a[i]和a[k] int temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; &#125; System.out.println(); System.out.println(\"交换后：\"); for(int num:arr)&#123; System.out.print(num+\" \"); &#125; &#125; &#125; 冒泡排序算法冒泡排序外层共需要对序列进行n-1次遍历，内层从e[0]到e[n-i]（i为外层遍历的次数）两两进行比较，如果e[j-1]&gt;e[j]则进行交换，直到比较e[0]和e[1]后为止，冒泡排序算法的时间复杂度为O(n²)；123456789101112131415161718192021222324252627public class bubleSort &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub /* * 基本思路:两个元素进行比较， */ int[] arr = &#123;4,3,2,6,7,1,8,5&#125;; System.out.print(\"冒泡排序之前:\"); for (int i : arr) &#123; System.out.print(i + \" \"); &#125; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if (arr[j]&lt;arr[i]) &#123; int k = arr[i]; arr[i] = arr[j]; arr[j] = k; &#125; &#125; &#125; System.out.print(\"冒泡排序之后:\"); for (int i : arr) &#123; System.out.print(i + \" \"); &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://www.devzou.com/tags/算法/"}]},{"title":"为Hexo的Next主题增加畅言评论的支持","date":"2017-06-13T10:40:12.000Z","path":"2017/06/13/hexo/2017-06-13-为Hexo的Next主题增加畅言评论的支持/","text":"设置步骤next主题的配置文件_config.yml增加配置:123#changyanchangyan_appid: changyan_appkey:","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.devzou.com/tags/hexo/"}]},{"title":"openCV简述","date":"2017-05-17T00:11:59.000Z","path":"2017/05/17/digitalImage/2017-05-17-openCV简述/","text":"前言OpenCV 声明了命名空间 cv，因此 OpenCV 的类的前面会有个 cv:: 前缀，就像 cv::Mat、 cv::Algorithm 等等。你也可以在 .mm 文件中使用 using namespace cv 来避免在一堆类名前使用 cv:: 前缀。但是，在某些类名前你必须使用命名空间前缀，比如 cv::Rect 和 cv::Point，因为它们会跟定义在 MacTypes.h 中的 Rect 和 Point 相冲突。尽管这只是个人偏好问题，我还是偏向在任何地方都使用 cv:: 以保持一致性。 模块下面是在官方文档中列出的最重要的模块。 core：简洁的核心模块，定义了基本的数据结构，包括稠密多维数组 Mat 和其他模块需要的基本函数。imgproc：图像处理模块，包括线性和非线性图像滤波、几何图像转换 (缩放、仿射与透视变换、一般性基于表的重映射)、颜色空间转换、直方图等等。video：视频分析模块，包括运动估计、背景消除、物体跟踪算法。calib3d：包括基本的多视角几何算法、单体和立体相机的标定、对象姿态估计、双目立体匹配算法和元素的三维重建。features2d：包含了显著特征检测算法、描述算子和算子匹配算法。objdetect：物体检测和一些预定义的物体的检测 (如人脸、眼睛、杯子、人、汽车等)。ml：多种机器学习算法，如 K 均值、支持向量机和神经网络。highgui：一个简单易用的接口，提供视频捕捉、图像和视频编码等功能，还有简单的 UI 接口 (iOS 上可用的仅是其一个子集)。gpu：OpenCV 中不同模块的 GPU 加速算法 (iOS 上不可用)。ocl：使用 OpenCL 实现的通用算法 (iOS 上不可用)。一些其它辅助模块，如 Python 绑定和用户贡献的算法。 基础类和操作OpenCV 包含几百个类。为简便起见，我们只看几个基础的类和操作，进一步阅读请参考全部文档。过一遍这几个核心类应该足以对这个库的机理产生一些感觉认识。 cv::Mat cv::Mat 是 OpenCV 的核心数据结构，用来表示任意 N 维矩阵。因为图像只是 2 维矩阵的一个特殊场景，所以也是使用 cv::Mat 来表示的。也就是说，cv::Mat 将是你在 OpenCV 中用到最多的类。 一个 cv::Mat 实例的作用就像是图像数据的头，其中包含着描述图像格式的信息。图像数据只是被引用，并能为多个 cv::Mat 实例共享。OpenCV 使用类似于 ARC 的引用计数方法，以保证当最后一个来自 cv::Mat 的引用也消失的时候，图像数据会被释放。图像数据本身是图像连续的行的数组 (对 N 维矩阵来说，这个数据是由连续的 N-1 维数据组成的数组)。使用 step[] 数组中包含的值，图像的任一像素地址都可通过下面的指针运算得到： uchar pixelPtr = cvMat.data + rowIndex cvMat.step[0] + colIndex * cvMat.step[1]每个像素的数据格式可以通过 type() 方法获得。除了常用的每通道 8 位无符号整数的灰度图 (1 通道，CV_8UC1) 和彩色图 (3 通道，CV_8UC3)，OpenCV 还支持很多不常用的格式，例如 CV_16SC3 (每像素 3 通道，每通道使用 16 位有符号整数)，甚至 CV_64FC4 (每像素 4 通道，每通道使用 64 位浮点数)。 cv::Algorithm Algorithm 是 OpenCV 中实现的很多算法的抽象基类，包括将在我们的 demo 工程中用到的 FaceRecognizer。它提供的 API 与苹果的 Core Image 框架中的 CIFilter 有些相似之处。创建一个 Algorithm 的时候使用算法的名字来调用 Algorithm::create()，并且可以通过 get() 和 set()方法来获取和设置各个参数，这有点像是键值编码。另外，Algorithm 从底层就支持从/向 XML 或 YAML 文件加载/保存参数的功能。","tags":[{"name":"openCV","slug":"openCV","permalink":"https://www.devzou.com/tags/openCV/"}]},{"title":"openCV在iOS工程中的应用之项目配置","date":"2017-05-16T10:04:28.000Z","path":"2017/05/16/ios/2017-05-16-openCV在iOS工程中的应用之项目配置/","text":"前言使用 C++ API 并不是绝大多数 iOS 开发者每天都做的事，你需要使用 Objective-C++ 文件来调用 OpenCV 的函数。 也就是说，你不能在 Swift 或者 Objective-C 语言内调用 OpenCV 的函数。 这篇 OpenCV 的 iOS 教程告诉你只要把所有用到 OpenCV 的类的文件后缀名改为 .mm 就行了，包括视图控制器类也是如此。这么干或许能行得通，却不是什么好主意。正确的方式是给所有你要在 app 中使用到的 OpenCV 功能写一层 Objective-C++ 封装。这些 Objective-C++ 封装把 OpenCV 的 C++ API 转化为安全的 Objective-C API，以方便地在所有 Objective-C 类中使用。走封装的路子，你的工程中就可以只在这些封装中调用 C++ 代码，从而避免掉很多让人头痛的问题，比如直接改文件后缀名会因为在错误的文件中引用了一个 C++ 头文件而产生难以追踪的编译错误。 在新建项目中集成openCV这里我选择使用cocoapods集成,关于cocoapods的使用，请参考这篇文章这是我的Podfile文件 Objective-C++如前面所说，OpenCV 是一个 C++ 的 API，因此不能直接在 Swift 和 Objective-C 代码中使用，但能在 Objective-C++ 文件中使用。 Objective-C++ 是 Objective-C 和 C++ 的混合物，让你可以在 Objective-C 类中使用 C++ 对象。clang 编译器会把所有后缀名为 .mm 的文件都当做是 Objective-C++。一般来说，它会如你所期望的那样运行，但还是有一些使用 Objective-C++ 的注意事项。内存管理是你最应该格外注意的点，因为 ARC 只对 Objective-C 对象有效。当你使用一个 C++ 对象作为类属性的时候，其唯一有效的属性就是 assign。因此，你的 dealloc 函数应确保 C++ 对象被正确地释放了。 第二重要的点就是，如果你在 Objective-C++ 头文件中引入了 C++ 头文件，当你在工程中使用该 Objective-C++ 文件的时候就泄露了 C++ 的依赖。任何引入你的 Objective-C++ 类的 Objective-C 类也会引入该 C++ 类，因此该 Objective-C 文件也要被声明为 Objective-C++ 的文件。这会像森林大火一样在工程中迅速蔓延。所以，应该把你引入 C++ 文件的地方都用 #ifdef __cplusplus 包起来，并且只要可能，就尽量只在 .mm 实现文件中引入 C++ 头文件。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"软件破解","date":"2017-05-16T09:01:46.000Z","path":"2017/05/16/tool/2017-05-16-软件破解/","text":"webstorm phpstorm 系列破解webStorm系列破解http://idea.imsxm.com/","tags":[{"name":"工具","slug":"工具","permalink":"https://www.devzou.com/tags/工具/"}]},{"title":"常用自动化软件","date":"2017-05-16T08:19:50.000Z","path":"2017/05/16/tool/2017-05-16-公司常用自动化软件/","text":"自动部署工具jenkins","tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.devzou.com/tags/Windows/"}]},{"title":"CADisplayLink","date":"2017-05-01T00:17:27.000Z","path":"2017/05/01/ios/2017-05-01-CADisplayLink/","text":"CADisplayLink原理一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。 duration属性提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是 duration只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。frameInterval属性是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval 设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。我们通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的 target跟selector另外CADisplayLink 不能被继承。 CADisplayLink 与 NSTimer 的区别iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 CADisplayLink使用的例子self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateTextColor)]; self.displayLink.paused = YES; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; -(void)updateTextColor{} - (void)startAnimation{ self.beginTime = CACurrentMediaTime(); self.displayLink.paused = NO; } - (void)stopAnimation{ self.displayLink.paused = YES; [self.displayLink invalidate]; self.displayLink = nil; } 给非UI对象添加动画效果我们知道动画效果就是一个属性的线性变化，比如UIView 动画的 EasyIn EasyOut 。通过数值按照不同速率的变化我们能生成更接近真实世界的动画效果。我们也可以利用这个特性来使一些其他属性按照我们期望的曲线变化。比如当播放视频时关掉视频的声音我可以通过CADisplayLink来实现一个 EasyOut的渐出效果：先快速的降低音量，在慢慢的渐变到静音。 【注意】 通常来讲：iOS设备的刷新频率事60HZ也就是每秒60次。那么每一次刷新的时间就是1/60秒 大概16.7毫秒。当我们的frameInterval值为1的时候我们需要保证的是 CADisplayLink调用的｀target｀的函数计算时间不应该大于 16.7否则就会出现严重的丢帧现象。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"密码学原理","date":"2017-04-12T14:57:21.000Z","path":"2017/04/12/Java/2017-04-12-Base64编码/","text":"密码学综述密码学基本功能 1.机密性:只有指定的发送方和接收方才能理解传输的内容,窃听者可以截取到加密的报文,但不能还原出原来 的信息 2.鉴别:发送方和接收方都能证实通信过程中的另一方,通信的另一方确实有 他们所生成的身份 3.报文完整性 4.不可否认性 密码学算法的分类消息编码:Base64消息摘要:MD类、SHA类、MAC对称密码:DES、3DES、AES非对称密码:RSA、DH密钥交换数字签名:RSASignature、DSASignature 密码学五元组明文、密文、加密算法、解密算法、密钥【注】密钥 != 密码 密钥+规则=密码 对称密码(传统密码)与非对称密码(公钥密码) 对称密码:加解密使用相同密钥的密码体制 非对称密码:加解密使用不同的密钥—–公钥与私钥 Java中编程中常用的类消息编码:BASE64Encoder BASE64Decoder消息摘要:MessageDiest对称密码:KeyGenerator、SecretKey、Cipher非对称密码:KeyPairGenerator、KeyFactory、KeyPair、PublicKey、PrivateKey、Cipher数字签名:Signature Base64编码算法的使用Base64编码示例 密文:SGVsbG8gV29ybGQh 明文:Hello World! Base64算法定义base64是一种基于64个字符的编码算法,以任意8位字节序列组合的描述形式,这种形式不易直接识别。经base64编码后的字符串的字符数是以4为单位的整数倍 Base64密钥 Base64编程使用","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"iOS View层架构设计","date":"2017-04-07T09:55:24.000Z","path":"2017/04/07/ios/2017-04-07-iOSView层架构设计/","text":"一般也就是这两种时机会去做View层架构，基于这个时机的特殊性，我们在这时候必须清楚认识到：View层的架构一旦实现或定型，在App发版后可修改的余地就已经非常之小了。因为它跟业务关联最为紧密，所以哪怕稍微动一点点，它所引发的蝴蝶效应都不见得是业务方能够hold住的。这样的情况，就要求我们在实现这个架构时，代码必须得改得勤快，不能偷懒。也必须抱着充分的自我怀疑态度，做决策时要拿捏好尺度。View层的架构非常之重要，在我看来，这部分架构是这系列文章涉及4个方面最重要的一部分，没有之一。为什么这么说？ 1.View层架构是影响业务方迭代周期的因素之一产品经理产生需求的速度会非常快，尤其是公司此时仍处于创业初期，在规模稍大的公司里面，产品经理也喜欢挖大坑来在leader面前刷存在感，比如阿里。这就导致业务工程师任务非常繁重。正常情况下让产品经理砍需求是不太可能的，因此作为架构师，在架构里有一些可做可不做的事情，最好还是能做就做掉，不要偷懒。这可以帮业务方减负，编写代码的时候也能更加关注业务。我跟一些朋友交流的时候，他们都会或多或少地抱怨自己的团队迭代速度不够快，或者说，迭代速度不合理地慢。我认为迭代速度不是想提就能提的，迭代速度的影响因素有很多，一期PRD里的任务量和任务复杂度都会影响迭代周期能达到什么样的程度。抛开这些外在的不谈，从内在可能导致迭代周期达不到合理的速度的原因来看，其中有一个原因很有可能就是View层架构没有做好，让业务工程师完成一个不算复杂的需求时，需要处理太多额外的事情。当然，开会多，工程师水平烂也属于迭代速度提不上去的内部原因，但这个不属于本文讨论范围。还有，加班不是优化迭代周期的正确方式，嗯。一般来说，一个不够好的View层架构，主要原因有以下五种： 代码混乱不规范 过多继承导致的复杂依赖关系 模块化程度不够高，组件粒度不够细 横向依赖 架构设计失去传承这五个地方会影响业务工程师实现需求的效率，进而拖慢迭代周期。View架构的其他缺陷也会或多或少地产生影响，但在我看来这里五个是比较重要的影响因素。如果大家觉得还有什么因素比这四个更高的，可以在评论区提出来我补上去。对于第五点我想做一下强调：架构的设计是一定需要有传承的，有传承的架构从整体上看会非常协调。但实际情况有可能是一个人走了，另一个顶上，即便任务交接得再完整，都不可避免不同的人有不同的架构思路，从而导致整个架构的流畅程度受到影响。要解决这个问题，一方面要尽量避免单点问题，让架构师做架构的时候再带一个人。另一方面，架构要设计得尽量简单，平缓接手人的学习曲线。我离开安居客的时候，做过保证：凡是从我手里出来的代码，终身保修。所以不要想着离职了就什么事儿都不管了，这不光是职业素养问题，还有一个是你对你的代码是否足够自信的问题。传承性对于View层架构非常重要，因为它距离业务最近，改动余地最小。所以当各位CTO、技术总监、TeamLeader们觉得迭代周期不够快时，你可以先不忙着急吼吼地去招新人，《人月神话》早就说过加人不能完全解决问题。这时候如果你可以回过头来看一下是不是View层架构不合理，把这个弄好也是优化迭代周期的手段之一。嗯，至于本系列其他三项的架构方案对于迭代周期的影响程度，我认为都不如View层架构方案对迭代周期的影响高，所以这是我认为View层架构是最重要的其中一个理由。2.View层架构是最贴近业务的底层架构View层架构虽然也算底层，但还没那么底层，它跟业务的对接面最广，影响业务层代码的程度也最深。在所有的底层都牵一发的时候，在View架构上牵一发导致业务层动全身的面积最大。所以View架构在所有架构中一旦定型，可修改的空间就最小，我们在一开始考虑View相关架构时，不光要实现功能，还要考虑更多规范上的东西。制定规范的目的一方面是防止业务工程师的代码腐蚀View架构，另一方面也是为了能够有所传承。按照规范来，总还是不那么容易出差池的。 还有就是，架构师一开始考虑的东西也会有很多，不可能在第一版就把它们全部实现，对于一个尚未发版的App来说，第一版架构往往是最小完整功能集，那么在第二版第三版的发展过程中，架构的迭代任务就很有可能不只是你一个人的事情了，相信你一个人也不见得能搞定全部。所以你要跟你的合作者们有所约定。另外，第一版出去之后，业务工程师在使用过程中也会产生很多修改意见，哪些意见是合理的，哪些意见是不合理的，也要通过事先约定的规范来进行筛选，最终决定如何采纳。规范也不是一成不变的，什么时候枪毙意见，什么时候改规范，这就要靠各位的技术和经验了。 3.View代码结构的规定关于view的布局何时使用storyboard，何时使用nib，何时使用代码写View是否有必要让业务方统一派生ViewController？方便View布局的小工具MVC、MVVM、MVCS、VIPER本门心法跨业务时View的处理留给评论区各种补总结View代码结构的规定架构师不是写SDK出来交付业务方使用就没事儿了的，每家公司一定都有一套代码规范，架构师的职责也包括定义代码规范。按照道理来讲，定代码规范应该是属于通识，放在这里讲的原因只是因为我这边需要为View添加一个规范。制定代码规范严格来讲不属于View层架构的事情，但它对View层架构未来的影响会比较大，也是属于架构师在设计View层架构时需要考虑的事情。制定View层规范的重要性在于： 提高业务方View层的可读性可维护性 防止业务代码对架构产生腐蚀 确保传承 保持架构发展的方向不轻易被不合理的意见所左右在这一节里面我不打算从头开始定义一套规范，苹果有一套Coding Guidelines，当我们定代码结构或规范的时候，首先一定要符合这个规范。然后，相信大家各自公司里面也都有一套自己的规范，具体怎么个规范法其实也是根据各位架构师的经验而定，我这边只是建议各位在各自规范的基础上再加上下面这一点。 viewController的代码应该差不多是这样： 要点如下：所有的属性都使用getter和setter不要在viewDidLoad里面初始化你的view然后再add，这样代码就很难看。在viewDidload里面只做addSubview的事情，然后在viewWillAppear里面做布局的事情（勘误1），最后在viewDidAppear里面做Notification的监听之类的事情。至于属性的初始化，则交给getter去做。比如这样：12345678910111213141516171819202122232425262728293031#pragma mark - life cycle- (void)viewDidLoad&#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; [self.view addSubview:self.firstTableView]; [self.view addSubview:self.secondTableView]; [self.view addSubview:self.firstFilterLabel]; [self.view addSubview:self.secondFilterLabel]; [self.view addSubview:self.cleanButton]; [self.view addSubview:self.originImageView]; [self.view addSubview:self.processedImageView]; [self.view addSubview:self.activityIndicator]; [self.view addSubview:self.takeImageButton];&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; CGFloat width = (self.view.width - 30) / 2.0f; self.originImageView.size = CGSizeMake(width, width); [self.originImageView topInContainer:70 shouldResize:NO]; [self.originImageView leftInContainer:10 shouldResize:NO]; self.processedImageView.size = CGSizeMake(width, width); [self.processedImageView right:10 FromView:self.originImageView]; [self.processedImageView topEqualToView:self.originImageView]; CGFloat labelWidth = self.view.width - 100; self.firstFilterLabel.size = CGSizeMake(labelWidth, 20); [self.firstFilterLabel leftInContainer:10 shouldResize:NO]; [self.firstFilterLabel top:10 FromView:self.originImageView]; ... ...&#125; 这样即便在属性非常多的情况下，还是能够保持代码整齐，view的初始化都交给getter去做了。总之就是尽量不要出现以下的情况：12345678910- (void)viewDidLoad&#123; [super viewDidLoad]; self.textLabel = [[UILabel alloc] init]; self.textLabel.textColor = [UIColor blackColor]; self.textLabel ... ... self.textLabel ... ... self.textLabel ... ... [self.view addSubview:self.textLabel];&#125; 这种做法就不够干净，都扔到getter里面去就好了。关于这个做法，在唐巧的技术博客里面有一篇文章和我所提倡的做法不同，这个我会放在后面详细论述。 getter和setter全部都放在最后 因为一个ViewController很有可能会有非常多的view，就像上面给出的代码样例一样，如果getter和setter写在前面，就会把主要逻辑扯到后面去，其他人看的时候就要先划过一长串getter和setter，这样不太好。然后要求业务工程师写代码的时候按照顺序来分配代码块的位置，先是life cycle，然后是Delegate方法实现，然后是event response，然后才是getters and setters。这样后来者阅读代码时就能省力很多。 每一个delegate都把对应的protocol名字带上，delegate方法不要到处乱写，写到一块区域里面去 比如UITableViewDelegate的方法集就老老实实写上#pragma mark - UITableViewDelegate。这样有个好处就是，当其他人阅读一个他并不熟悉的Delegate实现方法时，他只要按住command然后去点这个protocol名字，Xcode就能够立刻跳转到对应这个Delegate的protocol定义的那部分代码去，就省得他到处找了。 event response专门开一个代码区域 所有button、gestureRecognizer的响应事件都放在这个区域里面，不要到处乱放。 关于private methods，正常情况下ViewController里面不应该写 不是delegate方法的，不是event response方法的，不是life cycle方法的，就是private method了。对的，正常情况下ViewController里面一般是不会存在private methods的，这个private methods一般是用于日期换算、图片裁剪啥的这种小功能。这种小功能要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。 ViewController基本上是大部分业务的载体，本身代码已经相当复杂，所以跟业务关联不大的东西能不放在ViewController里面就不要放。另外一点，这个private method的功能这时候只是你用得到，但是将来说不定别的地方也会用到，一开始就独立出来，有利于将来的代码复用。 为什么要这样要求？ 我见过无数ViewController，代码布局乱得一塌糊涂，这里一个delegate那里一个getter，然后ViewController的代码一般都死长死长的，看了就让人头疼。 定义好这个规范，就能使得ViewController条理清晰，业务方程序员很能够区分哪些放在ViewController里面比较合适，哪些不合适。另外，也可以提高代码的可维护性和可读性。 关于View的布局 业务工程师在写View的时候一定逃不掉的就是这个命题。用Frame也好用Autolayout也好，如果没有精心设计过，布局部分一定惨不忍睹。 直接使用CGRectMake的话可读性很差，光看那几个数字，也无法知道view和view之间的位置关系。用Autolayout可读性稍微好点儿，但生成Constraint的长度实在太长，代码观感不太好。 Autolayout这边可以考虑使用Masonry，代码的可读性就能好很多。如果还有使用Frame的，可以考虑一下使用这个项目。 这个项目里面提供了Frame相关的方便方法(UIView+LayoutMethods)，里面的方法也基本涵盖了所有布局的需求，可读性非常好，使用它之后基本可以和CGRectMake说再见了。因为天猫在最近才切换到支持iOS6，所以之前天猫都是用Frame布局的，在天猫App中，首页，范儿部分页面的布局就使用了这些方法。使用这些方便方法能起到事半功倍的效果。 这个项目也提供了Autolayout方案下生产Constraints的方便方法(UIView+AEBHandyAutoLayout)，可读性比原生好很多。我当时在写这系列方法的时候还不知道有Masonry。知道有Masonry之后我特地去看了一下，发现Masonry功能果然强大。不过这系列方法虽然没有Masonry那么强大，但是也够用了。当时安居客iPad版App全部都是Autolayout来做的View布局，就是使用的这个项目里面的方法。可读性很好。 让业务工程师使用良好的工具来做View的布局，能提高他们的工作效率，也能减少bug发生的几率。架构师不光要关心那些高大上的内容，也要多给业务工程师提供方便易用的小工具，才能发挥架构师的价值。 何时使用storyboard，何时使用nib，何时使用代码写View 这个问题唐巧的博客里这篇文章也提到过，我的意见和他是基本一致的。 在这里我还想补充一些内容： 具有一定规模的团队化iOS开发（10人以上）有以下几个特点： 同一份代码文件的作者会有很多，不同作者同时修改同一份代码的情况也不少见。因此，使用Git进行代码版本管理时出现Conflict的几率也比较大。需求变化非常频繁，产品经理一时一个主意，为了完成需求而针对现有代码进行微调的情况，以及针对现有代码的部分复用的情况也比较多。复杂界面元素、复杂动画场景的开发任务比较多。如果这三个特点你一看就明白了，下面的解释就可以不用看了。如果你针对我的倾向愿意进一步讨论的，可以先看我下面的解释，看完再说。 同一份代码文件的作者会有很多，不同作者同时修改同一份代码的情况也不少见。因此，使用Git进行代码版本管理时出现Conflict的几率也比较大。 iOS开发过程中，会遇到最蛋疼的两种Conflict一个是project.pbxproj，另外一个就是StoryBoard或XIB。因为这些文件的内容的可读性非常差，虽然苹果在XCode5（现在我有点不确定是不是这个版本了）中对StoryBoard的文件描述方式做了一定的优化，但只是把可读性从非常差提升为很差。 然而在StoryBoard中往往包含了多个页面，这些页面基本上不太可能都由一个人去完成，如果另一个人在做StoryBoard的操作的时候，出于某些目的动了一下不属于他的那个页面，比如为了美观调整了一下位置。然后另外一个人也因为要添加一个页面，而在Storyboard中调整了一下某个其他页面的位置。那么针对这个情况我除了说个呵呵以外，我就只能说：祝你好运。看清楚哦，这还没动具体的页页面内容呢。 但如果使用代码绘制View，Conflict一样会发生，但是这种Conflict就好解很多了，你懂的。 需求变化非常频繁，产品经理一时一个主意，为了完成需求而针对现有代码进行微调的情况，以及针对现有代码的部分复用的情况也比较多。 我觉得产品经理一时一个主意不是他的错，他说不定也是被逼的，比如谁都会来掺和一下产品的设计，公司里的所有人，上至CEO，下至基层员工都有可能对产品设计评头论足，只要他个人有个地方用得不爽（极大可能是个人喜好）然后又正好跟产品经理比较熟悉能够搭得上话，都会提出各种意见。产品经理躲不起也惹不起，有时也是没办法，嗯。 但落实到工程师这边来，这种情况就很蛋疼。因为这种改变有时候不光是UI，UI所对应的逻辑也有要改的可能，工程师就会两边文件都改，你原来link的那个view现在不link了，然后你的outlet对应也要删掉，这两部分只要有一个没做，编译通过之后跑一下App，一会儿就crash了。看起来这不是什么大事儿，但很影响心情。 另外，如果出现部分的代码复用，比如说某页面下某个View也希望放在另外一个页面里，相关的操作就不是复制粘贴这么简单了，你还得重新link一遍。也很影响心情。 复杂界面元素，复杂动画交互场景的开发任务比较多。 要是想在基于StoryBoard的项目中做一个动画，很烦。做几个复杂界面元素，也很烦。有的时候我们挂Custom View上去，其实在StoryBoard里面看来就是一个空白View。然后另外一点就是，当你的layout出现问题需要调整的时候，还是挺难找到问题所在的，尤其是在复杂界面元素的情况下。 所以在针对View层这边的要求时，我也是建议不要用StoryBoard。实现简单的东西，用Code一样简单，实现复杂的东西，Code比StoryBoard更简单。所以我更加提倡用code去画view而不是storyboard。 是否有必要让业务方统一派生ViewController 有的时候我们出于记录用户操作行为数据的需要，或者统一配置页面的目的，会从UIViewController里面派生一个自己的ViewController，来执行一些通用逻辑。比如天猫客户端要求所有的ViewController都要继承自TMViewController。这个统一的父类里面针对一个ViewController的所有生命周期都做了一些设置，至于这里都有哪些设置对于本篇文章来说并不重要。在这里我想讨论的是，在设计View架构时，如果为了能够达到统一设置或执行统一逻辑的目的，使用派生的手段是有必要的吗？ 我觉得没有必要，为什么没有必要？ 使用派生比不使用派生更容易增加业务方的使用成本不使用派生手段一样也能达到统一设置的目的这两条原因是我认为没有必要使用派生手段的理由，如果两条理由你都心领神会，那么下面的就可以不用看了。如果你还有点疑惑，请看下面我来详细讲一下原因。 为什么使用了派生，业务方的使用成本会提升？ 其实不光是业务方的使用成本，架构的维护成本也会上升。那么具体的成本都来自于哪里呢？ 集成成本这里讲的集成成本是这样的：如果业务方自己开了一个独立demo，快速完成了某个独立流程，现在他想把这个现有流程集合进去。那么问题就来了，他需要把所有独立的UIViewController改变成TMViewController。那为什么不是一开始就立刻使用TMViewController呢？因为要想引入TMViewController，就要引入整个天猫App所有的业务线，所有的基础库，因为这个父类里面涉及很多天猫环境才有的内容，所谓拔出萝卜带出泥，你要是想简单继承一下就能搞定的事情，搭环境就要搞半天，然后这个小Demo才能跑得起来。 对于业务层存在的所有父类来说，它们是很容易跟项目中的其他代码纠缠不清的，这使得业务方开发时遇到一个两难问题：要么把所有依赖全部搞定，然后基于App环境（比如天猫）下开发Demo，要么就是自己Demo写好之后，按照环境要求改代码。这里的两难问题都会带来成本，都会影响业务方的迭代进度。 我不确定各位所在公司是否会有这样的情况，但我可以在这里给大家举一个我在阿里的真实的例子：我最近在开发某滤镜Demo和相关页面流程，最终是要合并到天猫这个App里面去的。使用天猫环境进行开发的话，pod install完所有依赖差不多需要10分钟，然后打开workspace之后，差不多要再等待1分钟让xcode做好索引，然后才能正式开始工作。在这里要感谢一下则平，因为他在此基础上做了很多优化，使得这个1分钟已经比原来的时间短很多了。但如果天猫环境有更新，你就要再重复一次上面的流程，否则 就很有可能编译不过。 拜托，我只是想做个Demo而已，不想搞那么复杂。 上手接受成本新来的业务工程师有的时候不见得都记得每一个ViewController都必须要派生自TMViewController而不是直接的UIViewController。新来的工程师他不能直接按照苹果原生的做法去做事情，他需要额外学习，比如说：所有的ViewController都必须继承自TMViewController。 架构的维护难度尽可能少地使用继承能提高项目的可维护性，具体内容我在《跳出面向对象思想（一） 继承》里面说了，在这里我想偷懒不想把那篇文章里说过的东西再说一遍。 其实对于业务方来说，主要还是第一个集成成本比较蛋疼，因为这是长痛，每次要做点什么事情都会遇到。第二点倒还好，短痛。第三点跟业务工程师没啥关系。 那么如果不使用派生，我们应该使用什么手段？ 我的建议是使用AOP。 在架构师实现具体的方案之前，必须要想清楚几个问题，然后才能决定采用哪种方案。是哪几个问题？ 方案的效果，和最终要达到的目的是什么？在自己的知识体系里面，是否具备实现这个方案的能力？在业界已有的开源组件里面，是否有可以直接拿来用的轮子？这三个问题按照顺序一一解答之后，具体方案就能出来了。 我们先看第一个问题：方案的效果，和最终要达到的目的是什么？ 方案的效果应该是： 业务方可以不用通过继承的方法，然后框架能够做到对ViewController的统一配置。业务方即使脱离框架环境，不需要修改任何代码也能够跑完代码。业务方的ViewController一旦丢入框架环境，不需要修改任何代码，框架就能够起到它应该起的作用。其实就是要实现不通过业务代码上对框架的主动迎合，使得业务能够被框架感知这样的功能。细化下来就是两个问题，框架要能够拦截到ViewController的生命周期，另一个问题就是，拦截的定义时机。 对于方法拦截，很容易想到Method Swizzling，那么我们可以写一个实例，在App启动的时候添加针对UIViewController的方法拦截，这是一种做法。还有另一种做法就是，使用NSObject的load函数，在应用启动时自动监听。使用后者的好处在于，这个模块只要被项目包含，就能够发挥作用，不需要在项目里面添加任何代码。 然后另外一个要考虑的事情就是，原有的TMViewController（所谓的父类）也是会提供额外方法方便子类使用的，Method Swizzling只支持针对现有方法的操作，拓展方法的话，嗯，当然是用Category啦。 我本人不赞成Category的过度使用，但鉴于Category是最典型的化继承为组合的手段，在这个场景下还是适合使用的。还有的就是，关于Method Swizzling手段实现方法拦截，业界也已经有了现成的开源库：Aspects，我们可以直接拿来使用。 我这边有个非常非常小的Demo可以放出来给大家，这个Demo只是一个点睛之笔，有一些话我也写在这个Demo里面了，各位架构师们你们可以基于各自公司App的需求去拓展。 这个Demo不包含Category，毕竟Category还是得你们自己去写啊～然后这套方案能够完成原来通过派生手段所有可以完成的任务，但同时又允许业务方不必添加任何代码，直接使用原生的UIViewController。 然后另外要提醒的是，这方案的目的是消除不必要的继承，虽然不限定于UIViewController，但它也是有适用范围的，在适用继承的地方，还是要老老实实使用继承。比如你有一个数据模型，是由基本模型派生出的一整套模型，那么这个时候还是老老实实使用继承。至于拿捏何时使用继承，相信各位架构师一定能够处理好，或者你也可以参考我前面提到的那篇文章来控制拿捏的尺度。 关于MVC、MVVM等一大堆思想 其实这些都是相对通用的思想，万变不离其宗的还是在开篇里面我提到的那三个角色：数据管理者，数据加工者，数据展示者。这些五花八门的思想，不外乎就是制订了一个规范，规定了这三个角色应当如何进行数据交换。但同时这些也是争议最多的话题，所以我在这里来把几个主流思想做一个梳理，当你在做View层架构时，能够有个比较好的参考。 MVC MVC（Model-View-Controller）是最老牌的的思想，老牌到4人帮的书里把它归成了一种模式，其中Model就是作为数据管理者，View作为数据展示者，Controller作为数据加工者，Model和View又都是由Controller来根据业务需求调配，所以Controller还负担了一个数据流调配的功能。正在我写这篇文章的时候，我看到InfoQ发了这篇文章，里面提到了一个移动开发中的痛点是：对MVC架构划分的理解。我当时没能够去参加这个座谈会，也没办法发表个人意见，所以就只能在这里写写了。 在iOS开发领域，我们应当如何进行MVC的划分？ 这里面其实有两个问题： 为什么我们会纠结于iOS开发领域中MVC的划分问题？在iOS开发领域中，怎样才算是划分的正确姿势？为什么我们会纠结于iOS开发领域中MVC的划分问题？ 关于这个，每个人纠结的点可能不太一样，我也不知道当时座谈会上大家的观点。但请允许我猜一下：是不是因为UIViewController中自带了一个View，且控制了View的整个生命周期（viewDidLoad,viewWillAppear…），而在常识中我们都知道Controller不应该和View有如此紧密的联系，所以才导致大家对划分产生困惑？，下面我会针对这个猜测来给出我的意见。 在服务端开发领域，Controller和View的交互方式一般都是这样，比如Yii： 123456789101112 / … 数据库取数据 … 处理数据 … / // 此处$this就是Controller $this-&gt;render(“plan”,array( ‘planList’ =&gt; $planList, ‘plan_id’ =&gt; $_GET[‘id’], ));这里Controller和View之间区分得非常明显，Controller做完自己的事情之后，就把所有关于View的工作交给了页面渲染引擎去做，Controller不会去做任何关于View的事情，包括生成View，这些都由渲染引擎代劳了。这是一个区别，但其实服务端View的概念和Native应用View的概念，真正的区别在于：从概念上严格划分的话，服务端其实根本没有View，拜HTTP协议所赐，我们平时所讨论的View只是用于描述View的字符串（更实质的应该称之为数据），真正的View是浏览器。。 所以服务端只管生成对View的描述，至于对View的长相，UI事件监听和处理，都是浏览器负责生成和维护的。但是在Native这边来看，原本属于浏览器的任务也逃不掉要自己做。那么这件事情由谁来做最合适？苹果给出的答案是：UIViewController。 鉴于苹果在这一层做了很多艰苦卓绝的努力，让iOS工程师们不必亲自去实现这些内容。而且，它把所有的功能都放在了UIView上，并且把UIView做成不光可以展示UI，还可以作为容器的一个对象。 看到这儿你明白了吗？UIView的另一个身份其实是容器！UIViewController中自带的那个view，它的主要任务就是作为一个容器。如果它所有的相关命名都改成ViewContainer，那么代码就会变成这样： 12345678 (void)viewContainerDidLoad{ [self.viewContainer addSubview:self.label]; [self.viewContainer addSubview:self.tableView]; [self.viewContainer addSubview:self.button]; [self.viewContainer addSubview:self.textField];}… …仅仅改了个名字，现在是不是感觉清晰了很多？如果再要说详细一点，我们平常所认为的服务端MVC是这样划分的： 1432264217309340.jpg 但事实上，整套流程的MVC划分是这样： 屏幕快照 2015-05-22 上午11.01.56.jpg 由图中可以看出，我们服务端开发在这个概念下，其实只涉及M和C的开发工作，浏览器作为View的容器，负责View的展示和事件的监听。那么对应到iOS客户端的MVC划分上面来，就是这样： 1432264253909859.jpg 唯一区别在于，View的容器在服务端，是由Browser负责，在整个网站的流程中，这个容器放在Browser是非常合理的。在iOS客户端，View的容器是由UIViewController中的view负责，我也觉得苹果做的这个选择是非常正确明智的。 因为浏览器和服务端之间的关系非常松散，而且他们分属于两个不同阵营，服务端将对View的描述生成之后，交给浏览器去负责展示，然而一旦view上有什么事件产生，基本上是很少传递到服务器（也就是所谓的Controller）的（要传也可以：AJAX），都是在浏览器这边把事情都做掉，所以在这种情况下，View容器就适合放在浏览器（V）这边。 但是在iOS开发领域，虽然也有让View去监听事件的做法，但这种做法非常少，都是把事件回传给Controller，然后Controller再另行调度。所以这时候，View的容器放在Controller就非常合适。Controller可以因为不同事件的产生去很方便地更改容器内容，比如加载失败时，把容器内容换成失败页面的View，无网络时，把容器页面换成无网络的View等等。 在iOS开发领域中，怎样才算是MVC划分的正确姿势？ 这个问题其实在上面已经解答掉一部分了，那么这个问题的答案就当是对上面问题的一个总结吧。 M应该做的事： 给ViewController提供数据给ViewController存储数据提供接口提供经过抽象的业务基本组件，供Controller调度C应该做的事： 管理View Container的生命周期负责生成所有的View实例，并放入View Container监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。V应该做的事： 响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。界面元素表达我通过与服务端MVC划分的对比来回答了这两个问题，之所以这么做，是因为我知道有很多iOS工程师之前是从服务端转过来的。我也是这样，在进安居客之前，我也是做服务端开发的，在学习iOS的过程中，我也曾经对iOS领域的MVC划分问题产生过疑惑，我疑惑的点就是前面开篇我猜测的点。如果有人问我iOS中应该怎么做MVC的划分，我就会像上面这么回答。 MVCS 苹果自身就采用的是这种架构思路，从名字也能看出，也是基于MVC衍生出来的一套架构。从概念上来说，它拆分的部分是Model部分，拆出来一个Store。这个Store专门负责数据存取。但从实际操作的角度上讲，它拆开的是Controller。 这算是瘦Model的一种方案，瘦Model只是专门用于表达数据，然后存储、数据处理都交给外面的来做。MVCS使用的前提是，它假设了你是瘦Model，同时数据的存储和处理都在Controller去做。所以对应到MVCS，它在一开始就是拆分的Controller。因为Controller做了数据存储的事情，就会变得非常庞大，那么就把Controller专门负责存取数据的那部分抽离出来，交给另一个对象去做，这个对象就是Store。这么调整之后，整个结构也就变成了真正意义上的MVCS。 关于胖Model和瘦Model 我在面试和跟别人聊天时，发现知道胖Model和瘦Model的概念的人不是很多。大约两三年前国外业界曾经对此有过非常激烈的讨论，主题就是Fat model, skinny controller。现在关于这方面的讨论已经不多了，然而直到今天胖Model和瘦Model哪个更好，业界也还没有定论，所以这算是目前业界悬而未解的一个争议。我很少看到国内有讨论这个的资料，所以在这里我打算补充一下什么叫胖Model什么叫瘦Model。以及他们的争论来源于何处。 什么叫胖Model？胖Model包含了部分弱业务逻辑。胖Model要达到的目的是，Controller从胖Model这里拿到数据之后，不用额外做操作或者只要做非常少的操作，就能够将数据直接应用在View上。举个例子： 123456789Raw Data: timestamp:1234567FatModel: @property (nonatomic, assign) CGFloat timestamp; - (NSString *)ymdDateString; // 2015-04-20 15:16 - (NSString *)gapString; // 3分钟前、1小时前、一天前、2015-3-13 12:34Controller: self.dateLabel.text = [FatModel ymdDateString]; self.gapLabel.text = [FatModel gapString]; 把timestamp转换成具体业务上所需要的字符串，这属于业务代码，算是弱业务。FatModel做了这些弱业务之后，Controller就能变得非常skinny，Controller只需要关注强业务代码就行了。众所周知，强业务变动的可能性要比弱业务大得多，弱业务相对稳定，所以弱业务塞进Model里面是没问题的。另一方面，弱业务重复出现的频率要大于强业务，对复用性的要求更高，如果这部分业务写在Controller，类似的代码会洒得到处都是，一旦弱业务有修改（弱业务修改频率低不代表就没有修改），这个事情就是一个灾难。如果塞到Model里面去，改一处很多地方就能跟着改，就能避免这场灾难。 然而其缺点就在于，胖Model相对比较难移植，虽然只是包含弱业务，但好歹也是业务，迁移的时候很容易拔出萝卜带出泥。另外一点，MVC的架构思想更加倾向于Model是一个Layer，而不是一个Object，不应该把一个Layer应该做的事情交给一个Object去做。最后一点，软件是会成长的，FatModel很有可能随着软件的成长越来越Fat，最终难以维护。 什么叫瘦Model？瘦Model只负责业务数据的表达，所有业务无论强弱一律扔到Controller。瘦Model要达到的目的是，尽一切可能去编写细粒度Model，然后配套各种helper类或方法来对弱业务做抽象，强业务依旧交给Controller。举个例子： 12345678910111213141516Raw Data:&#123; \"name\":\"casa\", \"sex\":\"male\",&#125;SlimModel: @property (nonatomic, strong) NSString *name; @property (nonatomic, strong) NSString *sex;Helper: #define Male 1; #define Female 0; + (BOOL)sexWithString:(NSString *)sex;Controller: if ([Helper sexWithString:SlimModel.sex] == Male) &#123; ... &#125; 由于SlimModel跟业务完全无关，它的数据可以交给任何一个能处理它数据的Helper或其他的对象，来完成业务。在代码迁移的时候独立性很强，很少会出现拔出萝卜带出泥的情况。另外，由于SlimModel只是数据表达，对它进行维护基本上是0成本，软件膨胀得再厉害，SlimModel也不会大到哪儿去。 缺点就在于，Helper这种做法也不见得很好，这里有一篇文章批判了这个事情。另外，由于Model的操作会出现在各种地方，SlimModel在一定程度上违背了DRY（Don’t Repeat Yourself）的思路，Controller仍然不可避免在一定程度上出现代码膨胀。 我的态度？嗯，我会在本门心法这一节里面说。 说回来，MVCS是基于瘦Model的一种架构思路，把原本Model要做的很多事情中的其中一部分关于数据存储的代码抽象成了Store，在一定程度上降低了Controller的压力。 MVVM MVVM去年在业界讨论得非常多，无论国内还是国外都讨论得非常热烈，尤其是在ReactiveCocoa这个库成熟之后，ViewModel和View的信号机制在iOS下终于有了一个相对优雅的实现。MVVM本质上也是从MVC中派生出来的思想，MVVM着重想要解决的问题是尽可能地减少Controller的任务。不管MVVM也好，MVCS也好，他们的共识都是Controller会随着软件的成长，变很大很难维护很难测试。只不过两种架构思路的前提不同，MVCS是认为Controller做了一部分Model的事情，要把它拆出来变成Store，MVVM是认为Controller做了太多数据加工的事情，所以MVVM把数据加工的任务从Controller中解放了出来，使得Controller只需要专注于数据调配的工作，ViewModel则去负责数据加工并通过通知机制让View响应ViewModel的改变。 MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel。关于这个观点我要做一个额外解释：胖Model做的事情是先为Controller减负，然后由于Model变胖，再在此基础上拆出ViewModel，跟业界普遍认知的MVVM本质上是为Controller减负这个说法并不矛盾，因为胖Model做的事情也是为Controller减负。 另外，我前面说MVVM把数据加工的任务从Controller中解放出来，跟MVVM拆分的是胖Model也不矛盾。要做到解放Controller，首先你得有个胖Model，然后再把这个胖Model拆成Model和ViewModel。 那么MVVM究竟应该如何实现？ 这很有可能是大多数人纠结的问题，我打算凭我的个人经验试图在这里回答这个问题，欢迎大家在评论区交流。 在iOS领域大部分MVVM架构都会使用ReactiveCocoa，但是使用ReactiveCocoa的iOS应用就是基于MVVM架构的吗？那当然不是，我觉得很多人都存在这个误区，我面试过的一些人提到了ReactiveCocoa也提到了MVVM，但他们对此的理解肤浅得让我忍俊不禁。嗯，在网络层架构我会举出不使用ReactiveCocoa的例子，现在举我感觉有点儿早。 MVVM的关键是要有View Model！而不是ReactiveCocoa(勘误2) ViewModel做什么事情？就是把RawData变成直接能被View使用的对象的一种Model。举个例子： Raw Data: { ( (123, 456), (234, 567), (345, 678) ) } 这里的RawData我们假设是经纬度，数字我随便写的不要太在意。然后你有一个模块是地图模块，把经纬度数组全部都转变成MKAnnotation或其派生类对于Controller来说是弱业务，（记住，胖Model就是用来做弱业务的），因此我们用ViewModel直接把它转变成MKAnnotation的NSArray，交给Controller之后Controller直接就可以用了。 嗯，这就是ViewModel要做的事情，是不是觉得很简单，看不出优越性？","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"IOS离线教程下载与Dash的使用","date":"2017-04-07T08:25:10.000Z","path":"2017/04/07/ios/2017-04-07-IOS离线教程下载与Dash的使用/","text":"但是，我们可以手动下载离线版的！离线的文档，在这里，叫做DocSet，意指文档集合。 下载方法：1、打开这个官网提供的连接：https://developer.apple.com/library/downloads/docset-index.dvtdownloadableindex这个链接返回的是XML数据，里面可以清晰的看到每个IOS版本的文档下载地址，以最新的ios8.3来说，拉到页面最底部： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!-- START iOS 8.3 full --&gt;&lt;dict&gt; &lt;key&gt;fileSize&lt;/key&gt; &lt;integer&gt;437051958&lt;/integer&gt; &lt;key&gt;identifier&lt;/key&gt; &lt;string&gt;com.apple.adc.documentation.iOS&lt;/string&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;iOS 8.3&lt;/string&gt; &lt;key&gt;source&lt;/key&gt; &lt;string&gt;https://devimages.apple.com.edgekey.net/docsets/20150408/Xcode_6.3_iOS_Docset.dmg&lt;/string&gt; &lt;key&gt;userInfo&lt;/key&gt; &lt;dict&gt; 。。。 &lt;/dict&gt; &lt;key&gt;version&lt;/key&gt; &lt;string&gt;83.3&lt;/string&gt;&lt;/dict&gt;&lt;!-- END iOS 8.3 full --&gt;&lt;!-- START Xcode 6.3 full --&gt;&lt;dict&gt; &lt;key&gt;fileSize&lt;/key&gt; &lt;integer&gt;351699366&lt;/integer&gt; &lt;key&gt;identifier&lt;/key&gt; &lt;string&gt;com.apple.adc.documentation.Xcode&lt;/string&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;Xcode 6.3&lt;/string&gt; &lt;key&gt;source&lt;/key&gt; &lt;string&gt;https://devimages.apple.com.edgekey.net/docsets/20150408/Xcode_6.3_DevTools_Docset.dmg&lt;/string&gt; &lt;key&gt;userInfo&lt;/key&gt; &lt;dict&gt; 。。。 &lt;/dict&gt; &lt;key&gt;version&lt;/key&gt; &lt;string&gt;630.4&lt;/string&gt;&lt;/dict&gt;&lt;!-- END Xcode 6.3 full --&gt;&lt;!-- START OS X 10.10.3 full --&gt;&lt;dict&gt; &lt;key&gt;fileSize&lt;/key&gt; &lt;integer&gt;615749973&lt;/integer&gt; &lt;key&gt;identifier&lt;/key&gt; &lt;string&gt;com.apple.adc.documentation.OSX&lt;/string&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;OS X 10.10.3&lt;/string&gt; &lt;key&gt;source&lt;/key&gt; &lt;string&gt;https://devimages.apple.com.edgekey.net/docsets/20150408/Xcode_6.3_OS_X_Docset.dmg&lt;/string&gt; &lt;key&gt;userInfo&lt;/key&gt; &lt;dict&gt; 。。。 &lt;/dict&gt; &lt;key&gt;version&lt;/key&gt; &lt;string&gt;1010.4&lt;/string&gt;&lt;/dict&gt; 每个dict节点，对应一个文件，这里一共有3个，分别是：IOS开发：Xcode_6.3_iOS_Docset.dmgDevtool工具：Xcode_6.3_DevTools_Docset.dmgOSX开发：Xcode_6.3_OS_X_Docset.dmg下载完成后，我们需要让Dash能读取这个docset，很简单哦，只需要把dmg里面的docset文件，放到这个目录下：1~/Library/Application Support/Dash/DocSets 好了，现在我们只需打开Dash，在Manage DocSets中，点击右下角的Rescan，Dash会自动读取我们放置的docset文件！您也可以在Dahs目录新建一个目录，对docset进行分类","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"iOS调用通讯录兼容7、8、9及以上系统","date":"2017-04-07T03:55:32.000Z","path":"2017/04/07/ios/2017-04-07-iOS调用通讯录兼容7、8、9及以上系统/","text":"前言大家用到通讯录无外乎就三个功能：1.点击弹出通讯录页面，选择了一个联系人的电话后直接将信息填到页面输入框内。 2.遍历所有的通讯录数据统一做批量操作，搭建新页面或直接上传。 3.给通讯录写入一条信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#pragma mark - ABPeoplePickerNavigationControllerDelegate- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier &#123; ABMultiValueRef phone = ABRecordCopyValue(person, kABPersonPhoneProperty); long index = ABMultiValueGetIndexForIdentifier(phone,identifier); NSString *phoneNO = (__bridge NSString *)ABMultiValueCopyValueAtIndex(phone, index); phoneNO = [phoneNO stringByReplacingOccurrencesOfString:@\"-\" withString:@\"\"]; NSLog(@\"%@\", phoneNO); if (phone &amp;&amp; phoneNO.length == 11) &#123; [peoplePicker dismissViewControllerAnimated:YES completion:nil]; return; &#125;else&#123; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"错误提示\" message:@\"请选择正确手机号\" delegate:self cancelButtonTitle:@\"确定\" otherButtonTitles:nil]; [alertView show]; &#125;&#125;- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController*)peoplePicker didSelectPerson:(ABRecordRef)person NS_AVAILABLE_IOS(8_0)&#123; ABPersonViewController *personViewController = [[ABPersonViewController alloc] init]; personViewController.displayedPerson = person; [peoplePicker pushViewController:personViewController animated:YES]; &#125;- (void)peoplePickerNavigationControllerDidCancel:(ABPeoplePickerNavigationController *)peoplePicker&#123; [peoplePicker dismissViewControllerAnimated:YES completion:nil];&#125;- (BOOL)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker shouldContinueAfterSelectingPerson:(ABRecordRef)person NS_DEPRECATED_IOS(2_0, 8_0)&#123; return YES;&#125;- (BOOL)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker shouldContinueAfterSelectingPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier NS_DEPRECATED_IOS(2_0, 8_0)&#123; ABMultiValueRef phone = ABRecordCopyValue(person, kABPersonPhoneProperty); long index = ABMultiValueGetIndexForIdentifier(phone,identifier); NSString *phoneNO = (__bridge NSString *)ABMultiValueCopyValueAtIndex(phone, index); phoneNO = [phoneNO stringByReplacingOccurrencesOfString:@\"-\" withString:@\"\"]; NSLog(@\"%@\", phoneNO); if (phone &amp;&amp; phoneNO.length == 11) &#123; [peoplePicker dismissViewControllerAnimated:YES completion:nil]; return NO; &#125;else&#123; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"错误提示\" message:@\"请选择正确手机号\" delegate:self cancelButtonTitle:@\"确定\" otherButtonTitles:nil]; [alertView show]; &#125; return YES;&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"关于iOS和OS X废弃的API你需要知道的一切","date":"2017-04-06T09:11:08.000Z","path":"2017/04/06/ios/2017-04-06-关于iOS和OS X废弃的API你需要知道的一切/","text":"原文:Everything You Need to Know about iOS and OS X Deprecated APIs如你所知，已废弃(Deprecated)的API指的是那些已经过时的并且在将来某个时间最终会被移除掉的方法或类。通常，苹果在引入一个更优秀的API后就会把原来的API给废弃掉。因为，新引入的API通常意味着可以更好的发挥新硬件或操作系统的性能，或者可以使用一些在构建原有API时根本还没有的语言特性(e.g. blocks)。每当苹果添加新方法的时候，他们都会在方法声明的后面用一个很特殊的宏来标明哪些iOS版本支持它们。例如，在UIViewController中，苹果引入了一个使用block来处理回调的方法用来展示一个模态controller，它的声明是这样的：1- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^)(void))completion NS_AVAILABLE_IOS(5_0); 注意到NS_AVAILABLE_IOS(5_0)了吗？这就告诉我们这个方法可以在iOS5.0及以后的版本中使用。如果我们在比指定版本更老的版本中调用这个方法，就会引起崩溃。那被这个方法替换了的那个旧方法又怎么样了呢？同样，它的声明后面也带了一个类似的语法，表示它已经被废弃了：1- (void)presentModalViewController:(UIViewController *)modalViewController animated:(BOOL)animated NS_DEPRECATED_IOS(2_0, 6_0); NS_DEPRECATED_IOS(2_0, 6_0)这个宏中有两个版本号。前面一个表明了这个方法被引入时的iOS版本，后面一个表明它被废弃时的iOS版本。被废弃并不是指这个方法就不存在了，只是意味着我们应当开始考虑将相关代码迁移到新的API上去了。还有类似形式的一些宏用在iOS和OS X共用的类上。比如NSArray中的这个方法：1- (void)setObject:(id)obj atIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0); 这里的NS_AVAILABLE宏告诉我们这方法分别随Mac OS 10.8和iOS 6.0被引入。和NS_DEPRECATED_IOS类似，也有个宏叫NS_DEPRECATED，但它的参数要稍微复杂些：1- (void)removeObjectsFromIndices:(NSUInteger *)indices numIndices:(NSUInteger)cnt NS_DEPRECATED(10_0, 10_6, 2_0, 4_0); 这里表示这个方法随Mac OS 10.0和iOS 2.0被引入，在Mac OS 10.6和iOS 4.0后被废弃。Easy Come, Easy Go上周我们讨论了在iOS7和Mac OS 10.9 SDK中被新引入的Base64 API。有趣的是，有一组有相同功能的Base64方法，在被引入的同时也被废弃掉了。为什么苹果在引入一个API的同时又把它废弃掉了？那不是毫无意义的吗？好吧，其实也不是——它在下面这种情况下就非常有意义：实际上，这些现在已经废弃的Base64方法从iOS4和Mac 0S 10.6开始就一直存在，只是它们是私有的。直到现在苹果才把它们公开，大概是苹果一直对它们的实现不满意，一直都想把它们改写。果然，在iOS7中，苹果选定了一个他们感到满意的Base64 API，并且将它添加到了NSData的一个公有类别中。但现在，他们知道老方法已经被取代，不会被改写了，因此他们把它公开出来。当开发者的app仍然需要支持iOS6及以前的版本时，就有了一个系统内置的Base64 api可以用。这就是为什么，如果你查看这些新API的方法声明，可以看到NS_DEPRECATED宏部分中的起始版本是4_0，虽然实际上直到iOS7之前，它从来都没有被作为公有API被引入过：1- (NSString *)base64Encoding NS_DEPRECATED(10_6, 10_9, 4_0, 7_0); 这告诉你，基于iOS7 SDK开发的app如果调用了这个方法，它同样可以运行在iOS4+或Mac OS 10.6+的系统上而不会崩溃。很有用的吧？如何使用已废弃的API那么，如果我们有一个app需要同时支持iOS6和iOS7，想用内置的Base64方法，我们该怎么做呢？事实上，这相当简单，你只需要调用这些废弃的API就可以了。那样编译器不是会产生警告吗？不会——只有你的deployment target版本号设置成大于或等于方法被弃用的版本号的时候才会收到编译器警告。只要你仍然在支持那些还没有废弃这个方法的iOS版本，都不会收到警告。那么，如果苹果决定在iOS8中移除已弃用的Base64方法，你的应用程序会发生情况？简单来说，它肯定会崩溃，但是不要让这把你吓跑了：苹果不可能只在几个iOS版本后就将已废弃的API给移除(绝大多数已废弃的API在任何的iOS版本中都还没有被移除)，除非你决定不再更新你的app，否则在你放弃支持iOS6之前有很多机会都可以更新到新的API。但是如果假定我们在最坏的情况下(例如：我们不更新我们的app了，而苹果突然宣布了一个零容忍的不再向下兼容的政策)，怎样让我们的代码保持永不过时并且仍然能够支持旧的系统版本呢？这其实很简单，我们只需要做一些运行时的方法检测。使用NSObject的respondsToSelector:方法，我们可以检测，如果新的API存在，我们就调用它。否则，我们退回到已废弃的API。很简单:1234567891011121314NSData *someData = ...NSString *base64String = nil;// Check if new API is availableif ([someData respondsToSelector:@selector(base64EncodedDataWithOptions:)])&#123; // It exists, so let's call it base64String = [someData base64EncodedDataWithOptions:0];&#125;else&#123; // Use the old API base64String = [someData base64Encoding];&#125; 此代码在iOS4及以上版本中有效，并且如果苹果在未来的iOS版本中移除base64Encoding方法后，同样可以正常工作。为其他开发者编码的时候如果你是在写一个app，这一切都很好，但是如果你是在编写一个给其他人使用的代码库呢？如果project的target是iOS4或iOS6的时候，上面的代码会工作的很好。但是如果deployment target是iOS 7+的时候，你就会收到编译器警告，说你使用了已废弃的base64Encoding方法。该代码实际上永远都可以正常工作，因为那个方法在运行时永远都不会被调用(因为respondsToSelector:那个检查在iOS7上总是会返回YES)。但是可惜的是，编译器还不是足够的聪明能发现这点。而且，比如像我，你不会想用那些会产生编译器警告的第三方库，你肯定也不想自己的库中产生任何警告。那么，我们如何改写我们的代码，以便它可以用于任何deployment target，而不会产生警告？幸好，有一个编译器宏指令可以基于不同的deployment target做不同的代码分支。取决于app是为哪个最小的iOS版本编译的，我们可以用__IPHONE_OS_VERSION_MIN_REQUIRED这个宏来生成不同的代码。下面的代码可以工作在任何的iOS版本上（不管是过去的还是将来的），而且不会产生任何警告：12345678910111213141516#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0// Check if new API is not availableif (![someData respondsToSelector:@selector(base64EncodedDataWithOptions:)])&#123; // Use the old API base64String = [someData base64Encoding];&#125;else#endif&#123; // Use the new API base64String = [someData base64EncodedDataWithOptions:0];&#125; 看清楚我们在这里做了什么吗？我们变换了respondsToSelector:的用法：我们用它来测试是否新的API不可用，然后将整段代码放到一个条件代码块中，这样它就只会在deployment target比iOS7低的情况下才会被编译。如果app是为iOS6编译的，它就会先检查新的API是否存在，如果不存在就调用旧的API。如果app是为iOS7编译的，那一整块逻辑代码都会被跳过，直接调用新的API。补充阅读苹果有一个关于废弃API用法的实例和相关的编译器警告的简单文档，如果感兴趣可以看看。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"iOS初级开发之自动引用计数","date":"2017-03-26T11:45:38.000Z","path":"2017/03/26/ios/2017-03-26-iOS初级开发之自动引用计数/","text":"","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"iOS开发之weak","date":"2017-03-26T02:35:49.000Z","path":"2017/03/26/ios/2017-03-26-iOS开发之weak/","text":"weak的实现方法初识化一个weak变量 当我们初始化一个weak变量时，runtime会调用objc_initWeak函数。这个函数在Clang中的声明如下1id objc_initWeak(id *object, id value); 其具体实现如下:12345id objc_initWeak(id *object, id value)&#123; *object = 0; return objc_storeWeak(object, value);&#125; 示例代码轮换成编译器的模拟代码如下：12id obj1;objc_initWeak(&amp;obj1, obj); 因此，这里所做的事是先将obj1初始化为0(nil)，然后将obj1的地址及obj作为参数传递给objc_storeWeak函数。objc_initWeak函数有一个前提条件：就是object必须是一个没有被注册为weak对象的有效指针。而value则可以是null，或者指向一个有效的对象。如果value是一个空指针或者其指向的对象已经被释放了，则object是zero-initialized的。否则，object将被注册为一个指向value的weak对象。而这事应该是objc_storeWeak函数干的。objc_storeWeak的函数声明如下：1id objc_storeWeak(id *location, id value); 其具体实现如下：123456789101112131415161718192021222324252627282930313233id objc_storeWeak(id *location, id newObj)&#123; id oldObj; SideTable *oldTable; SideTable *newTable; ...... // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: oldObj = *location; oldTable = SideTable::tableForPointer(oldObj); newTable = SideTable::tableForPointer(newObj); ...... if (*location != oldObj) &#123; OSSpinLockUnlock(lock1);#if SIDE_TABLE_STRIPE &gt; 1 if (lock1 != lock2) OSSpinLockUnlock(lock2);#endif goto retry; &#125; if (oldObj) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; if (newObj) &#123; newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location); // weak_register_no_lock returns NULL if weak store should be rejected &#125; // Do not set *location anywhere else. That would introduce a race. *location = newObj; ...... return newObj;&#125; 我们撇开源码中各种锁操作，来看看这段代码都做了些什么。在此之前，我们先来了解下weak表和SideTable。 weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在objc-weak.h中)：12345struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; ......&#125;; 其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下：1234567891011121314struct weak_entry_t &#123; DisguisedPtr referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; ...... &#125;; struct &#123; // out_of_line=0 is LSB of one of these (don't care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;;&#125;; 其中referent是被引用的对象，即示例代码中的obj对象。下面的union即存储了所有指向该对象的弱引用。由注释可以看到，当out_of_line等于0时，hash表被一个数组所代替。另外，所有的弱引用对象的地址都是存储在weak_referrer_t指针的地址中。其定义如下：1typedef objc_object ** weak_referrer_t; SideTable是一个用C++实现的类，它的具体定义在NSObject.mm中，我们来看看它的一些成员变量的定义：12345678class SideTable &#123;private: static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];public: RefcountMap refcnts; weak_table_t weak_table; ......&#125; RefcountMap refcnts，大家应该能猜到这个做什么用的吧？看着像是引用计数什么的。哈哈，貌似就是啊，这东东存储了一个对象的引用计数的信息。当然，我们在这里不去探究它，我们关注的是weak_table。这个成员变量指向的就是一个对象的weak表。 了解了weak表和SideTable，让我们再回过头来看看objc_storeWeak。首先是根据weak指针找到其指向的老的对象：1oldObj = *location; 然后获取到与新旧对象相关的SideTable对象：12oldTable = SideTable::tableForPointer(oldObj);newTable = SideTable::tableForPointer(newObj); 下面要做的就是在老对象的weak表中移除指向信息，而在新对象的weak表中建立关联信息：1234567if (oldObj) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);&#125;if (newObj) &#123; newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location); // weak_register_no_lock returns NULL if weak store should be rejected&#125; 接下来让弱引用指针指向新的对象：1*location = newObj; 最后会返回这个新对象：1return newObj; objc_storeWeak的基本实现就是这样。当然，在objc_initWeak中调用objc_storeWeak时，老对象是空的，所有不会执行weak_unregister_no_lock操作。 而当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下： 调用objc_release因为对象的引用计数为0，所以执行dealloc在dealloc中，调用了_objc_rootDealloc函数在_objc_rootDealloc中，调用了object_dispose函数调用objc_destructInstance最后调用objc_clear_deallocating我们重点关注一下最后一步，objc_clear_deallocating的具体实现如下：12345678910111213void objc_clear_deallocating(id obj) &#123; ...... SideTable *table = SideTable::tableForPointer(obj); // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) OSSpinLockLock(&amp;table-&gt;slock); if (seen_weak_refs) &#123; arr_clear_deallocating(&amp;table-&gt;weak_table, obj); &#125; ......&#125; 我们可以看到，在这个函数中，首先取出对象对应的SideTable实例，如果这个对象有关联的弱引用，则调用arr_clear_deallocating来清除对象的弱引用信息。我们来看看arr_clear_deallocating具体实现：1234567891011121314151617181920212223PRIVATE_EXTERN void arr_clear_deallocating(weak_table_t *weak_table, id referent) &#123; &#123; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == NULL) &#123; ...... return; &#125; // zero out references for (int i = 0; i &lt; entry-&gt;referrers.num_allocated; ++i) &#123; id *referrer = entry-&gt;referrers.refs[i].referrer; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(\"__weak variable @ %p holds %p instead of %p\\n\", referrer, *referrer, referent); &#125; &#125; &#125; weak_entry_remove_no_lock(weak_table, entry); weak_table-&gt;num_weak_refs--; &#125;&#125; 这个函数首先是找出对象对应的weak_entry_t链表，然后挨个将弱引用置为nil。最后清理对象的记录。 通过上面的描述，我们基本能了解一个weak引用从生到死的过程。从这个流程可以看出，一个weak引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用weak变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用weak呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用weak修饰符。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.devzou.com/tags/iOS/"}]},{"title":"Scrapy入门教程","date":"2017-03-19T10:23:19.000Z","path":"2017/03/19/python/2017-03-19-scrapy入门教程/","text":"创建一个scrapy项目在开始爬取之前，您必须创建一个新的Scrapy项目。 进入您打算存储代码的目录中，运行下列命令:1scrapy startproject scrapyProject 该命令将会创建包含下列内容的 scrapyProject 目录:12345678910scrapyProject/ scrapy.cfg scrapyProject/ __init__.py items.py pipelines.py settings.py spiders/ __init__.py ... 这些文件分别是: scrapy.cfg: 项目的配置文件scrapyProject/: 该项目的python模块。之后您将在此加入代码。scrapyProject/items.py: 项目中的item文件.scrapyProject/pipelines.py: 项目中的pipelines文件.scrapyProject/settings.py: 项目的设置文件.scrapyProject/spiders/: 放置spider代码的目录. 定义ItemItem 是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。 类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field 的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单) 首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 scrapyProject 目录中的 items.py 文件:123456import scrapyclass DmozItem(scrapy.Item): title = scrapy.Field() link = scrapy.Field() desc = scrapy.Field() 一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义。 编写第一个爬虫(Spider)Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。以下为我们的第一个Spider代码，保存在 scrapyProject/spiders 目录下的 dmoz_spider.py 文件中:1234567891011121314import scrapyclass DmozSpider(scrapy.Spider): name = \"dmoz\" allowed_domains = [\"dmoz.org\"] start_urls = [ \"http://www.dmoz.org/Computers/Programming/Languages/Python/Books/\", \"http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/\" ] def parse(self, response): filename = response.url.split(\"/\")[-2] with open(filename, 'wb') as f: f.write(response.body) 爬取进入项目的根目录，执行下列命令启动spider:1scrapy crawl dmoz 提取ItemSelectors选择器简介从网页中提取数据有很多方法。Scrapy使用了一种基于 XPath和CSS 表达式机制: Scrapy Selectors 。 关于selector和其他提取机制的信息请参考 Selector文档 。这里给出XPath表达式的例子及对应的含义: /html/head/title: 选择HTML文档中 标签内的 元素/html/head/title/text(): 选择上面提到的 元素的文字//td: 选择所有的 元素//div[@class=”mine”]: 选择所有具有 class=”mine” 属性的 div 元素上边仅仅是几个简单的XPath例子，XPath实际上要比这远远强大的多。为了配合XPath，Scrapy除了提供了 Selector 之外，还提供了方法来避免每次从response中提取数据时生成selector的麻烦。Selector有四个基本的方法(点击相应的方法可以看到详细的API文档):xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表.extract(): 序列化该节点为unicode字符串并返回list。re(): 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。 在Shell中尝试Selector选择器为了介绍Selector的使用方法，接下来我们将要使用内置的 Scrapy shell 。Scrapy Shell需要您预装好IPython(一个扩展的Python终端)。 您需要进入项目的根目录，执行下列命令来启动shell:1scrapy shell &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python高级编程之爬虫Scrapy框架安装配置","date":"2017-03-19T01:12:00.000Z","path":"2017/03/19/python/2017-03-19-python高级编程之爬虫Scrapy框架安装配置/","text":"Mac下安装Scrapy框架刚刚试了下可以，可以简化为下面三个步骤一、删除Mac自带的Pythonsudo rm -rf /usr/bin/python二、homebrew安装最新的Pythonbrew install python创建一个软链接sudo ln -s /usr/local/bin/python /usr/bin/python三、使用pip安装scrapy使用homebrew安装完python后会自动安装好包管理工具pip，所以执行下面安装命令pip install scrapy安装完成后如下所示12345678910111213141516171819machaismile$ scrapyScrapy 0.22.2 - no active projectUsage: scrapy &lt;command&gt; [options] [args]Available commands: bench Run quick benchmark test fetch Fetch a URL using the Scrapy downloader runspider Run a self-contained spider (without creating a project) settings Get settings values shell Interactive scraping console startproject Create new project version Print Scrapy version view Open URL in browser, as seen by Scrapy [ more ] More commands available when run from project directoryUse &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command 出现 zsh: command not found: scrapy 执行 ln -s /Library/Frameworks/Python.framework/Versions/2.7/bin/scrapy /usr/local/bin/scrapy","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python高级编程之正则表达式","date":"2017-03-19T00:25:58.000Z","path":"2017/03/19/python/2017-03-19-python高级编程之正则表达式/","text":"Python Re模块Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下12345678910#返回pattern对象re.compile(string[,flag]) #以下为匹配所用函数re.match(pattern, string[, flags])re.search(pattern, string[, flags])re.split(pattern, string[, maxsplit])re.findall(pattern, string[, flags])re.finditer(pattern, string[, flags])re.sub(pattern, repl, string[, count])re.subn(pattern, repl, string[, count]) 在介绍这几个方法之前，我们先来介绍一下pattern的概念，pattern可以理解为一个匹配模式，那么我们怎么获得这个匹配模式呢？很简单，我们需要利用re.compile方法就可以。例如1pattern = re.compile(r'hello') 在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配。 另外大家可能注意到了另一个参数 flags，在这里解释一下这个参数的含义： 参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。 可选值有： • re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同） • re.M(全拼：MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图） • re.S(全拼：DOTALL): 点任意匹配模式，改变’.’的行为 • re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 • re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 re.match(pattern, string[, flags])这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败，否则匹配pattern成功，同时匹配终止，不再对string向后匹配。下面我们通过一个例子理解一下1234567891011121314151617181920212223242526272829303132333435363738394041424344__author__ = 'CQC'# -*- coding: utf-8 -*-#导入re模块import re# 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串”pattern = re.compile(r'hello')# 使用re.match匹配文本，获得匹配结果，无法匹配时将返回Noneresult1 = re.match(pattern,'hello')result2 = re.match(pattern,'helloo CQC!')result3 = re.match(pattern,'helo CQC!')result4 = re.match(pattern,'hello CQC!')#如果1匹配成功if result1: # 使用Match获得分组信息 print result1.group()else: print '1匹配失败！'#如果2匹配成功if result2: # 使用Match获得分组信息 print result2.group()else: print '2匹配失败！'#如果3匹配成功if result3: # 使用Match获得分组信息 print result3.group()else: print '3匹配失败！'#如果4匹配成功if result4: # 使用Match获得分组信息 print result4.group()else: print '4匹配失败！' 运行结果:1234hellohello3匹配失败！hello 匹配分析1.第一个匹配，pattern正则表达式为’hello’，我们匹配的目标字符串string也为hello，从头至尾完全匹配，匹配成功。2.第二个匹配，string为helloo CQC，从string头开始匹配pattern完全可以匹配，pattern匹配结束，同时匹配终止，后面的o CQC不再匹配，返回匹配成功的信息。3.第三个匹配，string为helo CQC，从string头开始匹配pattern，发现到 ‘o’ 时无法完成匹配，匹配终止，返回None4.第四个匹配，同第二个匹配原理，即使遇到了空格符也不会受影响。我们还看到最后打印出了result.group()，这个是什么意思呢？下面我们说一下关于match对象的的属性和方法Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。re.search(pattern, string[, flags])search方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。同样，search方法的返回对象同样match()返回对象的方法和属性。我们用一个例子感受一下12345678910111213#导入re模块import re# 将正则表达式编译成Pattern对象pattern = re.compile(r'world')# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None# 这个例子中使用match()无法成功匹配match = re.search(pattern,'hello world!')if match: # 使用Match获得分组信息 print match.group()### 输出 #### world re.split(pattern, string[, maxsplit])按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。我们通过下面的例子感受一下。1234567import repattern = re.compile(r'\\d+')print re.split(pattern,'one1two2three3four4')### 输出 #### ['one', 'two', 'three', 'four', ''] re.findall(pattern, string[, flags]) 搜索string，以列表形式返回全部能匹配的子串。我们通过这个例子来感受一下1234567import repattern = re.compile(r'\\d+')print re.findall(pattern,'one1two2three3four4')### 输出 #### ['1', '2', '3', '4'] re.finditer(pattern, string[, flags]) 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。我们通过下面的例子来感受一下12345678import repattern = re.compile(r'\\d+')for m in re.finditer(pattern,'one1two2three3four4'): print m.group(),### 输出 #### 1 2 3 4 re.sub(pattern, repl, string[, count]) 使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。12345678910import repattern = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!'print re.sub(pattern,r'\\2 \\1', s)def func(m): return m.group(1).title() + ' ' + m.group(2).title()print re.sub(pattern,func, s)### output #### say i, world hello!# I Say, Hello World! re.subn(pattern, repl, string[, count])返回 (sub(repl, string[, count]), 替换次数)。1234567891011import repattern = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!'print re.subn(pattern,r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print re.subn(pattern,func, s) ### output #### ('say i, world hello!', 2)# ('I Say, Hello World!', 2)","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python爬虫实战之爬取糗事百科段子","date":"2017-03-17T15:25:55.000Z","path":"2017/03/17/python/2017-03-17-Python爬虫实战之爬取糗事百科段子/","text":"确定URL并抓取页面代码首先我们确定好页面的URL是 http://www.qiushibaike.com/hot/page/1，其中最后一个数字1代表页数，我们可以传入不同的值来获得某一页的段子内容。 我们初步构建如下的代码来打印页面代码内容试试看，先构造最基本的页面抓取方式，看看会不会成功12345678910111213141516171819# -*- coding:utf-8 -*-import urllibimport urllib2page = 1url = 'http://www.qiushibaike.com/hot/page/' + str(page)user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'headers = &#123; 'User-Agent' : user_agent &#125;try: request = urllib2.Request(url,headers = headers) response = urllib2.urlopen(request) print response.read()except urllib2.URLError, e: if hasattr(e,\"code\"): print e.code if hasattr(e,\"reason\"): print e.reason 提取某一页的所有段子好，获取了HTML代码之后，我们开始分析怎样获取某一页的所有段子。 首先我们审查元素看一下，按浏览器的F12，截图如下 我们可以看到，每一个段子都是…包裹的内容。 现在我们想获取发布人，发布日期，段子内容，以及点赞的个数。不过另外注意的是，段子有些是带图片的，如果我们想在控制台显示图片是不现实的，所以我们直接把带有图片的段子给它剔除掉，只保存仅含文本的段子。 所以我们加入如下正则表达式来匹配一下，用到的方法是 re.findall 是找寻所有匹配的内容。方法的用法详情可以看前面说的正则表达式的介绍。 好，我们的正则表达式匹配语句书写如下，在原来的基础上追加如下代码123456content = response.read().decode('utf-8')pattern = re.compile('&lt;div.*?author\"&gt;.*?&lt;a.*?&lt;img.*?&gt;(.*?)&lt;/a&gt;.*?&lt;div.*?'+ 'content\"&gt;(.*?)&lt;!--(.*?)--&gt;.*?&lt;/div&gt;(.*?)&lt;div class=\"stats.*?class=\"number\"&gt;(.*?)&lt;/i&gt;',re.S)items = re.findall(pattern,content)for item in items: print item[0],item[1],item[2],item[3],item[4] 现在正则表达式在这里稍作说明 1）.? 是一个固定的搭配，.和代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配，以后我们还会大量用到 .*? 的搭配。 2）(.?)代表一个分组，在这个正则表达式中我们匹配了五个分组，在后面的遍历item中，item[0]就代表第一个(.?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。 3）re.S 标志代表在匹配时为点任意匹配模式，点 . 也可以代表换行符。 这样我们就获取了发布人，发布时间，发布内容，附加图片以及点赞数。 在这里注意一下，我们要获取的内容如果是带有图片，直接输出出来比较繁琐，所以这里我们只获取不带图片的段子就好了。 所以，在这里我们就需要对带图片的段子进行过滤。 我们可以发现，带有图片的段子会带有类似下面的代码，而不带图片的则没有，所以，我们的正则表达式的item[3]就是获取了下面的内容，如果不带图片，item[3]获取的内容便是空。","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python 高级教程之爬虫urllib库高级使用","date":"2017-03-17T15:07:56.000Z","path":"2017/03/17/python/2017-03-17.-Python 高级教程之爬虫urllib库高级使用/","text":"1.设置Headers有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，我们需要设置一些Headers 的属性。 首先，打开我们的浏览器，调试浏览器F12，我用的是Chrome，打开网络监听，示意如下，比如知乎，点登录之后，我们会发现登陆之后界面都变化了，出现一个新的界面，实质上这个页面包含了许许多多的内容，这些内容也不是一次性就加载完成的，实质上是执行了好多次请求，一般是首先请求HTML文件，然后加载JS，CSS 等等，经过多次请求之后，网页的骨架和肌肉全了，整个网页的效果也就出来了。拆分这些请求，我们只看一第一个请求，你可以看到，有个Request URL，还有headers，下面便是response，图片显示得不全，小伙伴们可以亲身实验一下。那么这个头中包含了许许多多是信息，有文件编码啦，压缩方式啦，请求的agent啦等等。其中，agent就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在headers中设置agent,例如下面的例子，这个例子只是说明了怎样设置的headers，小伙伴们看一下设置格式就好。 1234567891011import urllib import urllib2 url = 'http://www.server.com/login'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' values = &#123;'username' : 'cqc', 'password' : 'XXXX' &#125; headers = &#123; 'User-Agent' : user_agent &#125; data = urllib.urlencode(values) request = urllib2.Request(url, data, headers) response = urllib2.urlopen(request) page = response.read() 另外，我们还有对付”反盗链”的方式，对付防盗链，服务器会识别headers中的referer是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在headers中加入referer 例如我们可以构建下面的headers12headers = &#123; 'User-Agent' : 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' , 'Referer':'http://www.zhihu.com/articles' &#125; 同上面的方法，在传送请求时把headers传入Request参数里，这样就能应付防盗链了。 另外headers的一些属性，下面的需要特别注意一下： User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用application/json ： 在 JSON RPC 调用时使用application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务 Proxy（代理）的设置 urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！ 下面一段代码说明了代理的设置用法123456789import urllib2enable_proxy = Trueproxy_handler = urllib2.ProxyHandler(&#123;\"http\" : 'http://some-proxy.com:8080'&#125;)null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)if enable_proxy: opener = urllib2.build_opener(proxy_handler)else: opener = urllib2.build_opener(null_proxy_handler)urllib2.install_opener(opener) Timeout 设置上一节已经说过urlopen方法了，第三个参数就是timeout的设置，可以设置等待多久超时，为了解决一些网站实在响应过慢而造成的影响。 例如下面的代码,如果第二个参数data为空那么要特别指定是timeout是多少，写明形参，如果data已经传入，则不必声明。12import urllib2response = urllib2.urlopen('http://www.baidu.com', timeout=10) 12import urllib2response = urllib2.urlopen('http://www.baidu.com',data, 10) 使用 HTTP 的 PUT 和 DELETE 方法http协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求 PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。 如果要使用 HTTP PUT 和 DELETE ，只能使用比较低层的 httplib 库。虽然如此，我们还是能通过下面的方式，使 urllib2 能够发出 PUT 或DELETE 的请求，不过用的次数的确是少，在这里提一下。1234import urllib2request = urllib2.Request(uri, data=data)request.get_method = lambda: 'PUT' # or 'DELETE'response = urllib2.urlopen(request)","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python 高级教程之爬虫urllib基本使用","date":"2017-03-17T14:48:25.000Z","path":"2017/03/17/python/2017-03-17-python高级教程之爬虫urllib基本使用/","text":"如下程序1234import urllib2response = urllib2.urlopen(\"http://www.baidu.com\")print response.read() 把它保存成 demo.py，进入该文件的目录，执行命令python demo.py查看运行结果，感受一下。 分析扒网页的方法1response = urllib2.urlopen(\"http://www.baidu.com\") 首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，当然你也可以把HTTP换做FTP,FILE,HTTPS 等等，只是代表了一种访问控制协议，urlopen一般接受三个参数，它的参数如下：1urlopen(url, data, timeout) 第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。 1print response.read() response对象有一个read方法，可以返回获取到的网页内容。 构造Request其实上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。比如上面的两行代码，我们可以这么改写12345import urllib2request = urllib2.Request(\"http://www.baidu.com\")response = urllib2.urlopen(request)print response.read() 运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。 POST和GET数据传送上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。最常见的情况是什么？对了，就是登录注册的时候呀。 把数据用户名和密码传送到一个URL，然后你得到服务器处理之后的响应，这个该怎么办？下面让我来为小伙伴们揭晓吧！ 数据传送分为POST和GET两种方式，两种方式有什么区别呢？ 最重要的区别是GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。 POST方式： 上面我们说了data参数是干嘛的？对了，它就是用在这里的，我们传送的数据就是这个参数data，下面演示一下POST方式。 123456789import urllibimport urllib2values = &#123;\"username\":\"1315751082@qq.com\",\"password\":\"XXXX\"&#125;data = urllib.urlencode(values) url = \"https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn\"request = urllib2.Request(url,data)response = urllib2.urlopen(request)print response.read() 【抓取糗事百科页面的数据例子】 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-import urllibimport urllib2import re page = 1url = 'https://www.qiushibaike.com/text/' + str(page)user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6)'headers = &#123; 'User-Agent' : user_agent &#125;try: request = urllib2.Request(url,headers = headers) response = urllib2.urlopen(request)# print response.read() content = response.read().decode('utf-8') pattern = re.compile('&lt;div.*?author.*?&lt;a.*?&lt;img.*?&gt;(.*?)&lt;/a&gt;.*?&lt;div.*?'+ 'content\"&gt;(.*?)&lt;/div&gt;(.*?)&lt;div class=\"stats.*?class=\"number\"&gt;(.*?)&lt;/i&gt;',re.S) items = re.findall(pattern,content)# print items for item in items: print item# haveImg = re.search(\"img\",item[3])# if not haveImg:# print item[0],item[1],item[2],item[4]except urllib2.URLError, e: if hasattr(e,\"code\"): print e.code if hasattr(e,\"reason\"): print e.reason","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python 基础教程之文件I/O","date":"2017-03-16T23:52:18.000Z","path":"2017/03/17/python/2017-03-17-Python基础教程之文件I:O/","text":"打印到屏幕最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：1234#!/usr/bin/python# -*- coding: UTF-8 -*- print \"Python 是一个非常棒的语言，不是吗？\"; 你的标准屏幕上会产生以下结果：1Python 是一个非常棒的语言，不是吗？ 读取键盘输入Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：raw_inputinputraw_input函数raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：12345#!/usr/bin/python# -*- coding: UTF-8 -*- str = raw_input(\"请输入：\");print \"你输入的内容是: \", str 这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入”Hello Python！”，它的输出如下：12请输入：Hello Python！你输入的内容是: Hello Python！ input函数input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。12345#!/usr/bin/python# -*- coding: UTF-8 -*- str = input(\"请输入：\");print \"你输入的内容是: \", str 这会产生如下的对应着输入的结果：12请输入：[x*5 for x in range(2,10,2)]你输入的内容是: [10, 20, 30, 40] 打开和关闭文件现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。open 函数你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。语法：1file object = open(file_name [, access_mode][, buffering]) 各个参数的细节如下：file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。不同模式打开文件的完全列表： 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 || rb | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 || r+ | 打开一个文件用于读写。文件指针将会放在文件的开头。 || rb+ | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 || w | 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 || wb | 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 || w+ | 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 || wb+ | 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 || a | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 || ab | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 || a+ | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 || ab+ | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 | File对象的属性一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。以下是和file对象相关的所有属性的列表：| 属性 | 描述 || — | — || file.closed | 返回true如果文件已被关闭，否则返回false。 || file.mode | 返回被打开文件的访问模式。 || file.name | 返回文件的名称。 || file.softspace | 如果用print输出后，必须跟一个空格符，则返回false。否则返回true。 |如下实例：123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"wb\")print \"文件名: \", fo.nameprint \"是否已关闭 : \", fo.closedprint \"访问模式 : \", fo.modeprint \"末尾是否强制加空格 : \", fo.softspace 以上实例输出结果：1234文件名: foo.txt是否已关闭 : False访问模式 : wb末尾是否强制加空格 : 0 close()方法File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。语法：1fileObject.close(); 例子：123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"wb\")print \"文件名: \", fo.name # 关闭打开的文件fo.close() 以上实例输出结果：1文件名: foo.txt 读写文件：file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。write()方法write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。write()方法不会在字符串的结尾添加换行符(‘\\n’)：语法：1fileObject.write(string); 在这里，被传递的参数是要写入到已打开文件的内容。例子：123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"wb\")fo.write( \"www.lianyucode.top!\\nVery good site!\\n\"); # 关闭打开的文件fo.close() 上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容: 123cat foo.txt www.lianyucode.top!Very good site! read()方法read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。语法：1fileObject.read([count]); 在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。例子：这里我们用到以上创建的 foo.txt 文件。123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"r+\")str = fo.read(10);print \"读取的字符串是 : \", str# 关闭打开的文件fo.close() 以上实例输出结果：1读取的字符串是 : www.lianyucode.top 文件定位tell()方法告诉你文件内的当前位置；换句话说，下一次的读写会发生在文件开头这么多字节之后。seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。例子：就用我们上面创建的文件foo.txt。123456789101112131415161718#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"r+\")str = fo.read(10);print \"读取的字符串是 : \", str # 查找当前位置position = fo.tell();print \"当前文件位置 : \", position # 把指针再次重新定位到文件开头position = fo.seek(0, 0);str = fo.read(10);print \"重新读取字符串 : \", str# 关闭打开的文件fo.close() 以上实例输出结果：123读取的字符串是 : www.runoob当前文件位置 : 10重新读取字符串 : www.runoob 重命名和删除文件Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。rename()方法：rename()方法需要两个参数，当前的文件名和新文件名。语法：1os.rename(current_file_name, new_file_name) 例子：下例将重命名一个已经存在的文件test1.txt。1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 重命名文件test1.txt到test2.txt。os.rename( \"test1.txt\", \"test2.txt\" ) remove()方法你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。语法：1os.remove(file_name) 例子：下例将删除一个已经存在的文件test2.txt。1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 删除一个已经存在的文件test2.txtos.remove(\"test2.txt\") Python里的目录：所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。mkdir()方法可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。语法：1os.mkdir(\"newdir\") 例子：下例将在当前目录下创建一个新目录test。1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 创建目录testos.mkdir(\"test\") chdir()方法可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。语法：1os.chdir(\"newdir\") 例子：下例将进入”/home/newdir”目录。1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 将当前目录改为\"/home/newdir\"os.chdir(\"/home/newdir\") getcwd()方法：getcwd()方法显示当前的工作目录。语法：1os.getcwd() 例子：下例给出当前目录：1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 给出当前的目录print os.getcwd() rmdir()方法rmdir()方法删除目录，目录名称以参数传递。在删除这个目录之前，它的所有内容应该先被清除。语法：1os.rmdir('dirname') 例子：以下是删除” /tmp/test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 删除”/tmp/test”目录os.rmdir( \"/tmp/test\" )","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python 基础教程之模块","date":"2017-03-16T15:38:25.000Z","path":"2017/03/16/python/2017-03-16-python基本教程之模块(module)/","text":"下例是个简单的模块 support.py：123def print_func( par ): print \"Hello : \", par return import 语句模块的引入模块定义好后，我们可以使用 import 语句来引入模块，语法如下：1import module1[, module2[,... moduleN] 比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：1模块名.函数名 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端：12345678#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入模块import support # 现在可以调用模块里包含的函数了support.print_func(\"Python\") 以上实例输出结果：1Hello : Python 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。 From…import 语句Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：1from modname import name1[, name2[, ... nameN]] 例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：1from fib import fibonacci 这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。 From…import* 语句把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：1from modname import * 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。例如我们想一次性引入 math 模块中所有的东西，语句如下：1from math import * 搜索路径当你导入一个模块，Python 解析器对模块位置的搜索顺序是：1、当前目录2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 PYTHONPATH 变量作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。在 Windows 系统，典型的 PYTHONPATH 如下：1set PYTHONPATH=c:\\python27\\lib; 在 UNIX 系统，典型的 PYTHONPATH 如下：1set PYTHONPATH=/usr/local/lib/python 命名空间和作用域变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给全局变量在一个函数里赋值，必须使用 global 语句。global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句的注释就能解决这个问题。123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- Money = 2000def AddMoney(): # 想改正代码就取消以下注释: # global Money Money = Money + 1 print MoneyAddMoney()print Money Python中的包包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在 init.py 文件, 该文件的内容可以为空。int.py用于标识当前文件夹是一个包。考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、init.py 文件，test.py 为测试调用包的代码，目录结构如下：12345test.pypackage_runoob|-- __init__.py|-- runoob1.py|-- runoob2.py 源代码如下：package_runoob/runoob1.py12345#!/usr/bin/python# -*- coding: UTF-8 -*- def runoob1(): print \"I'm in runoob1\" package_runoob/runoob2.py12345#!/usr/bin/python# -*- coding: UTF-8 -*- def runoob2(): print \"I'm in runoob2\" 现在，在 package_runoob 目录下创建 init.py：package_runoob/init.py1234567#!/usr/bin/python# -*- coding: UTF-8 -*- if __name__ == '__main__': print '作为主程序运行'else: print 'package_runoob 初始化' 然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包test.py123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入 Phone 包from package_runoob.runoob1 import runoob1from package_runoob.runoob2 import runoob2 runoob1()runoob2() 以上实例输出结果：package_runoob 初始化I’m in runoob1I’m in runoob2如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python 基础教程之函数","date":"2017-03-16T15:07:53.000Z","path":"2017/03/16/python/2017-03-16-Python 基础教程之函数/","text":"定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则：函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。函数内容以冒号起始，并且缩进。return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。1234def functionname( parameters ): \"函数_文档字符串\" function_suite return [expression] 默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。实例以下为一个简单的Python函数，它将一个字符串作为传入参数，再打印到标准显示设备上。1234def printme( str ): \"打印传入的字符串到标准显示设备上\" print str return 函数调用定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。如下实例调用了printme（）函数：123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 定义函数def printme( str ): \"打印任何传入的字符串\" print str; return; # 调用函数printme(\"我要调用用户自定义函数!\");printme(\"再次调用同一函数\"); 以上实例输出结果：12我要调用用户自定义函数!再次调用同一函数 参数传递在 python 中，类型属于对象，变量是没有类型的：123a=[1,2,3]a=\"hello\" 以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第二个元素值更改，本身la没有动，只是其内部的一部分值被修改了。python 函数的参数传递：不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 python 传不可变对象实例123456789#!/usr/bin/python# -*- coding: UTF-8 -*- def ChangeInt( a ): a = 10b = 2ChangeInt(b)print b # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传可变对象实例1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明def changeme( mylist ): \"修改传入的列表\" mylist.append([1,2,3,4]); print \"函数内取值: \", mylist return # 调用changeme函数mylist = [10,20,30];changeme( mylist );print \"函数外取值: \", mylist 实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下：12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型：必备参数关键字参数默认参数不定长参数必备参数必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。调用printme()函数，你必须传入一个参数，不然会出现语法错误：1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- #可写函数说明def printme( str ): \"打印任何传入的字符串\" print str; return; #调用printme函数printme(); 以上实例输出结果：1234Traceback (most recent call last): File &quot;test.py&quot;, line 11, in &lt;module&gt; printme();TypeError: printme() takes exactly 1 argument (0 given) 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。以下实例在函数 printme() 调用时使用参数名：1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- #可写函数说明def printme( str ): \"打印任何传入的字符串\" print str; return; #调用printme函数printme( str = \"My string\"); 以上实例输出结果：1My string 下例能将关键字参数顺序不重要展示得更清楚：123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- #可写函数说明def printinfo( name, age ): \"打印任何传入的字符串\" print \"Name: \", name; print \"Age \", age; return; #调用printinfo函数printinfo( age=50, name=\"miki\" ); 以上实例输出结果：12Name: mikiAge 50 缺省参数调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：12345678910111213#!/usr/bin/python# -*- coding: UTF-8 -*- #可写函数说明def printinfo( name, age = 35 ): \"打印任何传入的字符串\" print \"Name: \", name; print \"Age \", age; return; #调用printinfo函数printinfo( age=50, name=\"miki\" );printinfo( name=\"miki\" ); 以上实例输出结果：1234Name: mikiAge 50Name: mikiAge 35 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：1234def functionname([formal_args,] *var_args_tuple ): \"函数_文档字符串\" function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。选择不多传参数也可。如下实例：123456789101112131415#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明def printinfo( arg1, *vartuple ): \"打印任何传入的参数\" print \"输出: \" print arg1 for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo( 70, 60, 50 ); 以上实例输出结果：123456输出:10输出:706050 匿名函数python 使用 lambda 来创建匿名函数。lambda只是一个表达式，函数体比def简单很多。lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。语法lambda函数的语法只包含一个语句，如下：1lambda [arg1 [,arg2,.....argn]]:expression 如下实例：123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数print \"相加后的值为 : \", sum( 10, 20 )print \"相加后的值为 : \", sum( 20, 20 ) 以上实例输出结果：12相加后的值为 : 30相加后的值为 : 40 return 语句return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做：123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明def sum( arg1, arg2 ): # 返回2个参数的和.\" total = arg1 + arg2 print \"函数内 : \", total return total; # 调用sum函数total = sum( 10, 20 ); 以上实例输出结果：1函数内 : 30 变量作用域一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：全局变量局部变量 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*-total = 0; # 这是一个全局变量# 可写函数说明def sum( arg1, arg2 ): #返回2个参数的和.\" total = arg1 + arg2; # total在这里是局部变量. print \"函数内是局部变量 : \", total return total; #调用sum函数sum( 10, 20 );print \"函数外是全局变量 : \", total 以上实例输出结果：12函数内是局部变量 : 30函数外是全局变量 : 0","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python 基础教程之变量类型","date":"2017-03-16T14:31:23.000Z","path":"2017/03/16/python/2017-03-16-python基础教程之变量类型/","text":"变量赋值Python 中的变量赋值不需要类型声明。每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。等号（=）用来给变量赋值。等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：12345678910#!/usr/bin/python# -*- coding: UTF-8 -*- counter = 100 # 赋值整型变量miles = 1000.0 # 浮点型name = \"John\" # 字符串 print counterprint milesprint name 以上实例中，100，1000.0和”John”分别赋值给counter，miles，name变量。执行以上程序会输出如下结果：1231001000.0John 多个变量赋值Python允许你同时为多个变量赋值。例如：1a = b = c = 1 以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。您也可以为多个对象指定多个变量。例如：1a, b, c = 1, 2, \"john\" 以上实例，两个整型对象1和2的分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。 标准数据类型在内存中存储的数据可以有多种类型。例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。Python 定义了一些标准类型，用于存储各种类型的数据。Python有五个标准的数据类型：Numbers（数字）String（字符串）List（列表）Tuple（元组）Dictionary（字典） Python数字数字数据类型用于存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。当你指定一个值时，Number对象就会被创建：12var1 = 1var2 = 10 您也可以使用del语句删除一些对象的引用。del语句的语法是：1del var1[,var2[,var3[....,varN]]]] 您可以通过使用del语句删除单个或多个对象的引用。例如：12del vardel var_a, var_b Python支持四种不同的数字类型：int（有符号整型）long（长整型[也可以代表八进制和十六进制]）float（浮点型）complex（复数） Python字符串字符串或串(String)是由数字、字母、下划线组成的一串字符。一般记为 :1s=\"a1a2···an\"(n&gt;=0) 它是编程语言中表示文本的数据类型。python的字串列表有2种取值顺序:从左到右索引默认0开始的，最大范围是字符串长度少1从右到左索引默认-1开始的，最大范围是字符串开头如果你要实现从字符串中获取一段子字符串的话，可以使用变量 [头下标:尾下标]，就可以截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。比如:1s = 'ilovepython' s[1:5]的结果是love。当使用以冒号分隔的字符串，python返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。上面的结果包含了s[1]的值l，而取到的最大范围不包括上边界，就是s[5]的值p。加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例：12345678910111213#!/usr/bin/python# -*- coding: UTF-8 -*- str = 'Hello World!' print str # 输出完整字符串print str[0] # 输出字符串中的第一个字符print str[2:5] # 输出字符串中第三个至第五个之间的字符串print str[2:] # 输出从第三个字符开始的字符串print str * 2 # 输出字符串两次print str + \"TEST\" # 输出连接的字符串``` 以上实例输出结果： Hello World!Hllollo World!Hello World!Hello World!Hello World!TEST12345678910111213141516171819## Python列表List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。列表用[ ]标识。是python最通用的复合数据类型。看这段代码就明白。列表中的值得分割也可以用到变量[头下标:尾下标]，就可以截取相应的列表，从左到右索引默认0开始的，从右到左索引默认-1开始，下标可以为空表示取到头或尾。加号（+）是列表连接运算符，星号（*）是重复操作。如下实例：```python#!/usr/bin/python# -*- coding: UTF-8 -*- list = [ &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 ]tinylist = [123, &apos;john&apos;] print list # 输出完整列表print list[0] # 输出列表的第一个元素print list[1:3] # 输出第二个至第三个的元素 print list[2:] # 输出从第三个开始至列表末尾的所有元素print tinylist * 2 # 输出列表两次print list + tinylist # 打印组合的列表 以上实例输出结果：123456[&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2]runoob[786, 2.23][2.23, &apos;john&apos;, 70.2][123, &apos;john&apos;, 123, &apos;john&apos;][&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2, 123, &apos;john&apos;] Python元组元组是另一个数据类型，类似于List（列表）。元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )tinytuple = (123, 'john') print tuple # 输出完整元组print tuple[0] # 输出元组的第一个元素print tuple[1:3] # 输出第二个至第三个的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素print tinytuple * 2 # 输出元组两次print tuple + tinytuple # 打印组合的元组 以上实例输出结果：123456(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)runoob(786, 2.23)(2.23, &apos;john&apos;, 70.2)(123, &apos;john&apos;, 123, &apos;john&apos;)(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2, 123, &apos;john&apos;) 以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的：1234567#!/usr/bin/python# -*- coding: UTF-8 -*- tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]tuple[2] = 1000 # 元组中是非法应用list[2] = 1000 # 列表中是合法应用 Python 字典字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。123456789101112131415#!/usr/bin/python# -*- coding: UTF-8 -*- dict = &#123;&#125;dict['one'] = \"This is one\"dict[2] = \"This is two\" tinydict = &#123;'name': 'john','code':6734, 'dept': 'sales'&#125; print dict['one'] # 输出键为'one' 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 输出结果为：12345This is oneThis is two&#123;&apos;dept&apos;: &apos;sales&apos;, &apos;code&apos;: 6734, &apos;name&apos;: &apos;john&apos;&#125;[&apos;dept&apos;, &apos;code&apos;, &apos;name&apos;][&apos;sales&apos;, 6734, &apos;john&apos;] Python数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。int(x [,base]) 将x转换为一个整数long(x [,base] ) 将x转换为一个长整数float(x) 将x转换到一个浮点数complex(real [,imag]) 创建一个复数str(x) 将对象 x 转换为字符串repr(x) 将对象 x 转换为表达式字符串eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象tuple(s) 将序列 s 转换为一个元组list(s) 将序列 s 转换为一个列表set(s) 转换为可变集合dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。frozenset(s) 转换为不可变集合chr(x) 将一个整数转换为一个字符unichr(x) 将一个整数转换为Unicode字符ord(x) 将一个字符转换为它的整数值hex(x) 将一个整数转换为一个十六进制字符串oct(x) 将一个整数转换为一个八进制字符串","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python 基础教程之基础语法","date":"2017-03-16T13:08:08.000Z","path":"2017/03/16/python/2017-03-16-Python 基础教程之基础语法/","text":"python交互式编程交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码mac上你只需要在命令行中输入 Python 命令即可启动交互式编程,提示窗口如下：http://okjl482qy.bkt.clouddn.com/python_01.png在 python 提示符中输入以下文本信息，然后按 Enter 键查看运行效果：1&gt;&gt;&gt; print \"Hello, Python!\"; 在 Python 2.7.6 版本中,以上实例输出结果如下：1Hello, Python! 脚本式编程通过脚本参数调用解释器开始执行脚本，直到脚本执行完毕。当脚本执行完成后，解释器不再有效。让我们写一个简单的Python脚本程序。所有Python文件将以.py为扩展名。将以下的源代码拷贝至lesson1.py文件中。1print \"Hello, Python!\"; 这里，假设你已经设置了Python解释器PATH变量。使用以下命令运行程序：1python test.py 输出结果：1Hello, Python! 让我们尝试另一种方式来执行Python脚本。修改lesson1.py文件，如下所示：123 #!/usr/bin/pythonprint \"Hello, Python!\"; 这里，假定您的Python解释器在/usr/bin目录中，使用以下命令执行脚本：12chmod +x lesson1.py # 脚本文件添加可执行权限./lesson1.py 输出结果：1Hello, Python! Python 标识符在python里，标识符有字母、数字、下划线组成。在python中，所有标识符可以包括英文、数字以及下划线（_），但不能以数字开头。python中的标识符是区分大小写的。以下划线开头的标识符是有特殊意义的。以单下划线开头（_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用”from xxx import *”而导入；以双下划线开头的（foo）代表类的私有成员；以双下划线开头和结尾的（foo）代表python里特殊方法专用的标识，如init__（）代表类的构造函数。| and | exec | not || — | — | — || assert | finally | or || break | for | pass || class | from | print || continue | global | raise || def | if | return || del | import | try || elif | in | while || else | is | with || except | lambda | yield | 行和缩进学习Python与其他语言最大的区别就是，Python的代码块不使用大括号（{}）来控制类，函数以及其他逻辑判断。python最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示：1234if True: print \"True\"else: print \"False\" 以下代码将会执行错误：1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：lesson1.py if True: print \"Answer\" print \"True\"else: print \"Answer\" # 没有严格缩进，在执行时会报错 print \"False\" 执行以上代码，会出现如下错误提醒：12345python lesson1.py File &quot;lesson1.py&quot;, line 5 if True: ^IndentationError: unexpected indent IndentationError: unexpected indent 错误是python编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有python对格式要求非常严格。如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。因此，在Python的代码块中必须使用相同数目的行首缩进空格数。建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用 多行语句Python语句中一般以新行作为为语句的结束符。但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示：123total = item_one + \\ item_two + \\ item_three 语句中包含[], {} 或 () 括号就不需要使用多行连接符。如下实例：12days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] Python 引号Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法，常用语文档字符串，在文件的特定地点，被当做注释。1234word = 'word'sentence = \"这是一个句子。\"paragraph = \"\"\"这是一个段落。包含了多个语句\"\"\" Python注释python中单行注释采用 # 开头。123456#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：lesson1.py# 第一个注释print \"Hello, Python!\"; # 第二个注释 输出结果：1Hello, Python! python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。12345678910111213141516#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：lesson1.py'''这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。'''\"\"\"这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。\"\"\" Python空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。记住：空行也是程序代码的一部分。 等待用户输入下面的程序在按回车键后就会等待用户输入：123#!/usr/bin/pythonraw_input(\"\\n\\nPress the enter key to exit.\") 以上代码中 ，”\\n\\n”在结果输出前会输出两个新的空行。一旦用户按下 enter(回车) 键退出，其它键显示。 同一行显示多条语句Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：123#!/usr/bin/pythonimport sys; x = 'hello'; sys.stdout.write(x + '\\n') 执行以上代码，输入结果为：12python lesson1.pyhello 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之代码组。像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。我们将首行及后面的代码组称为一个子句(clause)。如下实例：123456if expression : suite elif expression : suite else : suite 命令行参数很多程序可以执行一些操作来查看一些基本信，Python可以使用-h参数查看各参数帮助信息：123456789 python -h usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ... Options and arguments (and corresponding environment variables): -c cmd : program passed in as string (terminates option list) -d : debug output from parser (also PYTHONDEBUG=x) -E : ignore environment variables (such as PYTHONPATH) -h : print this help message and exit [ etc. ]","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Python 基础教程","date":"2017-03-16T13:02:47.000Z","path":"2017/03/16/python/2017-03-16-python基础教程简介/","text":"Python 简介Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 Python 特点1.易于学习：Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。2.易于阅读：Python代码定义的更清晰。3.易于维护：Python的成功在于它的源代码是相当容易维护的。4.一个广泛的标准库：Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。5.互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。6.可移植：基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。7.可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。8.数据库：Python提供所有主要的商业数据库的接口。9.GUI编程：Python支持GUI可以创建和移植到许多系统调用。10.可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。 Python 发展历史Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。现在 Python 是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。","tags":[{"name":"python","slug":"python","permalink":"https://www.devzou.com/tags/python/"}]},{"title":"Cocoapods 之pod search无法搜索到类库的解决办法","date":"2017-03-15T01:00:07.000Z","path":"2017/03/15/ios/2017-03-15-pod search/","text":"问题描述pod search ViewLayoutExtention(自己向cocoapods提交的代码库)提示如下错误1[!] Unable to find a pod with name, author, summary, or descriptionmatching '······' 解决办法12rm ~/Library/Caches/CocoaPods/search_index.jsonpod search ViewLayoutExtention 我当时的操作过程在终端输入pod setup,会出现Setting up CocoaPods master repo，等几分钟，会输入Setup completed，说明pod setup执行成功。结果pod search还是失败在终端输入pod search ViewLayoutExtention依然还是提示Unable to find a pod with name, author, summary, or description matching ‘ZLYNetWorking’。但是我输入pod search AFNetworking，却有相应的结果。删除~/Library/Caches/CocoaPods目录下的search_index.json文件 pod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。终端输入rm ~/Library/Caches/CocoaPods/search_index.json删除成功后再执行pod search终端输入：pod search ViewLayoutExtention(不区分大小写)输出：Creating search index for spec repo ‘master’.. Done!，稍等片刻就会出现所有带ViewLayoutExtention字段的类库出现。","tags":[{"name":"cocoapods","slug":"cocoapods","permalink":"https://www.devzou.com/tags/cocoapods/"}]},{"title":"让你的库文件支持cocoapods","date":"2017-03-13T14:36:24.000Z","path":"2017/03/13/ios/2017-03-13-让你的库文件支持cocoapods/","text":"整体步骤1.在本地创建静态库工程2.创建podspec文件,并验证是否通过3.上传到github,并创建release版本4.注册cocoapods账号5.上传代码到cocoapods6.检查上传是否成功 首先我们打开github.com，然后创建自己的项目工程：【注】因为我的github中已经创建了上面那个仓库，所以才会有上面那个提示这里注意那个MIT License，在后面添加Cocoapods支持的时候会用到（稍后介绍）。然后点击创建即可。然后用SouceTree将代码down到本地,你会发现文件夹中包含一个LICENSE文件，这里的LICENSE就是刚才说的MIT License添加的文件。然后我们在ZLYNetWorking文件夹中创建一个静态库工程 接下来就开始编写自己的代码了，然后提交到Github就可以了。 创建podspec文件我们使用终端到仓库的根目录下ZLYNetWorking.然后执行下面的命令：pod spec create ZLYNetWorking这里的ZLYNetWorking就是pod添加市的名字（例如MBProgressHUD）。执行完后的结果：此时在工程文件夹下也会多一个ZLYNetWorking.podspec文件。这里我用xcode打开并做了如下编辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768## Be sure to run `pod spec lint ZLYNetWorking.podspec' to ensure this is a# valid spec and to remove all comments including this before submitting the spec.## To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html# To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/#Pod::Spec.new do |s|# ――― Spec Metadata ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # These will help people to find your library, and whilst it # can feel like a chore to fill in it's definitely to your advantage. The # summary should be tweet-length, and the description more in depth. # s.name = \"ZLYNetWorking\" s.version = \"0.0.1\" s.summary = \"A network Framework based on AFNetworking\" # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don't worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESC 网络请求模块 网络请求模块 网络请求模块 网络请求模块 网络请求模块 网络请求模块 DESC s.homepage = \"https://github.com/lianyu125/ZLYNetWorking\" # s.screenshots = \"www.example.com/screenshots_1.gif\", \"www.example.com/screenshots_2.gif\" # ――― Spec License ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Licensing your code is important. See http://choosealicense.com for more info. # CocoaPods will detect a license file if there is a named LICENSE* # Popular ones are 'MIT', 'BSD' and 'Apache License, Version 2.0'. # # s.license = \"MIT\" s.license = &#123; :type =&gt; \"MIT\", :file =&gt; \"LICENSE\" &#125; # ――― Author Metadata ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Specify the authors of the library, with email addresses. Email addresses # of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also # accepts just a name if you'd rather not provide an email address. # # Specify a social_media_url where others can refer to, for example a twitter # profile URL. # s.author = &#123; \"lianyu.zou\" =&gt; \"lianyu125@gmail.com\" &#125; s.platform = :ios, \"7.0\" s.source = &#123; :git =&gt; \"https://github.com/lianyu125/ZLYNetWorking.git\", :branch =&gt; \"master\" &#125; s.source_files = \"ZLYNetWorking\", \"ZLYNetWorking/**/*.&#123;h,m&#125;\" s.exclude_files = \"ZLYNetWorking/Exclude\"end name:类库的名称这里字段介绍如下：version:库的版本summary就是介绍语,就是：homtepage:Github上项目地址license:许可证author:作者source:项目的https链接地址source_files:要共享的代码，这里是ZLYNetWorking下面的所有代码。接下来执行下面的命令进行验证： pod lib lint ZLYNetWorking.podspec结果多种多样，如果有错，则按照提示进行改错即可。在这里，我执行的结果如下图：发现了多个警告，只要不是错误就行，警告可以直接忽略（红色也提示如何忽略）：pod lib lint ZLYNetWorking.podspec —allow-warnings结果如下：当看到ZLYNetWorking passed validation之后，就说明验证通过了。 在Github上创建release版本打开项目的目录，然后创建release版本的类库：点击 箭头指向开始创建release版本，（点击 Create a new release）：点击Publish release即可。创建完成后如图所示：这样第三步就完成了 注册CocoaPods账号执行命令行： pod trunk register 邮箱地址 ‘用户名’ —description=&#39;描述信息&#39; 黄色提示已经发送了一个验证码到邮箱，你可以打开你的邮箱验证即可。这样就成功注册了Cocoapods账号。 可以用 pod trunk me检查是否创建成功。成功的结果如下： 上传代码到CocoaPods首先检测文件格式的有效性： pod spec lint结果如下：没有错误，但是有警告。可以使用 —allow-warnings忽略：出现passed validation就说明通过验证了。然后执行： pod trunk push ZLYNetWorking.podspec —allow-warnings执行结果如下：（速度应该有的慢）说明了已经上传成功。 检查上传是否成功使用pod search ZLYNetWorking 若果提示如下错误1[!] Unable to find a pod with name, author, summary, or descriptionmatching '······' 则请看我的另一篇博客 ok，已经成功了。这样就可以让其他人进行搜索使用了。","tags":[{"name":"cocoapods","slug":"cocoapods","permalink":"https://www.devzou.com/tags/cocoapods/"}]},{"title":"Mac下解压命令大全","date":"2017-03-13T08:18:04.000Z","path":"2017/03/13/tool/2017-03-13-.tar.gz格式的文件安装/","text":"Mac下解压命令大全.tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）——————————————— .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName——————————————— .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName——————————————— .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知——————————————— .Z解压：uncompress FileName.Z压缩：compress FileName .tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName——————————————— .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName——————————————— .rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName——————————————— .lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName——————————————— .rpm解包：rpm2cpio FileName.rpm | cpio -div——————————————— .deb解包：ar p FileName.deb data.tar.gz | tar zxf -———————————————.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea解压：sEx x FileName.压缩：sEx a FileName. FileName sEx只是调用相关程序，本身并无压缩、解压功能，请注意！ gzip 命令减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。 语法：gzip [选项] 压缩（解压缩）的文件名该命令的各选项含义如下： -c 将输出写到标准输出上，并保留原有文件。-d 将压缩文件解压。-l 对每个压缩文件，显示下列字段： 压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。-t 测试，检查压缩文件是否完整。-v 对每一个压缩和解压的文件，显示文件名和压缩比。-num 用指定的数字 num 调整压缩的速度，-1 或 –fast 表示最快压缩方法（低压缩比），-9 或–best表示最慢压缩方法（高压缩比）。系统缺省值为 6。指令实例： gzip % 把当前目录下的每个文件压缩成 .gz 文件。gzip -dv % 把当前目录下每个压缩的文件解压，并列出详细的信息。gzip -l *% 详细显示例1中每个压缩的文件的信息，并不解压。gzip usr.tar% 压缩 tar 备份文件 usr.tar，此时压缩文件的扩展名为.tar.gz。","tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.devzou.com/tags/Windows/"}]},{"title":"Java高级编程之连接MySQL","date":"2017-03-12T01:39:35.000Z","path":"2017/03/12/Java/2017-03-12-Java高级编程之连接MySQL/","text":"准备工作Java 连接 MySQL 需要驱动包，最新版下载地址为：http://dev.mysql.com/downloads/connector/j/，解压后得到jar库文件，然后在对应的项目中导入该库文件。 创建测试数据接下来我们在 MySQL 中创建 RUNOOB 数据库，并创建 websites 数据表，表结构如下：12345678CREATE TABLE `websites` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` char(20) NOT NULL DEFAULT '' COMMENT '站点名称', `url` varchar(255) NOT NULL DEFAULT '', `alexa` int(11) NOT NULL DEFAULT '0' COMMENT 'Alexa 排名', `country` char(10) NOT NULL DEFAULT '' COMMENT '国家', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8; 插入一些数据：1INSERT INTO `websites` VALUES ('1', 'Google', 'https://www.google.cm/', '1', 'USA'), ('2', '淘宝', 'https://www.taobao.com/', '13', 'CN'), ('3', 'Baidu', 'http://www.baidu.com', '5892', ''), ('4', '微博', 'http://weibo.com/', '20', 'CN'), ('5', 'Facebook', 'https://www.facebook.com/', '3', 'USA'); 连接数据库以下实例使用了 JDBC 连接 MySQL 数据库，注意一些数据如用户名，密码需要根据你的开发环境来配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.runoob.test; import java.sql.*; public class MySQLDemo &#123; // JDBC 驱动名及数据库 URL static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost:3306/RUNOOB\"; // 数据库的用户名与密码，需要根据自己的设置 static final String USER = \"root\"; static final String PASS = \"123456\"; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try&#123; // 注册 JDBC 驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 打开链接 System.out.println(\"连接数据库...\"); conn = DriverManager.getConnection(DB_URL,USER,PASS); // 执行查询 System.out.println(\" 实例化Statement对...\"); stmt = conn.createStatement(); String sql; sql = \"SELECT id, name, url FROM websites\"; ResultSet rs = stmt.executeQuery(sql); // 展开结果集数据库 while(rs.next())&#123; // 通过字段检索 int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String url = rs.getString(\"url\"); // 输出数据 System.out.print(\"ID: \" + id); System.out.print(\", 站点名称: \" + name); System.out.print(\", 站点 URL: \" + url); System.out.print(\"\\n\"); &#125; // 完成后关闭 rs.close(); stmt.close(); conn.close(); &#125;catch(SQLException se)&#123; // 处理 JDBC 错误 se.printStackTrace(); &#125;catch(Exception e)&#123; // 处理 Class.forName 错误 e.printStackTrace(); &#125;finally&#123; // 关闭资源 try&#123; if(stmt!=null) stmt.close(); &#125;catch(SQLException se2)&#123; &#125;// 什么都不做 try&#123; if(conn!=null) conn.close(); &#125;catch(SQLException se)&#123; se.printStackTrace(); &#125; &#125; System.out.println(\"Goodbye!\"); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java高级编程之发送邮件","date":"2017-03-12T01:01:41.000Z","path":"2017/03/12/Java/2017-03-12-Java高级编程之发送邮件/","text":"准备工作从 Java 网站下载最新版本的JavaMail ，打开网页右侧有个 Downloads 链接，点击它下载。从 Java 网站下载最新版本的JAF（版本 1.1.1） 。下载并解压缩这些文件，在新创建的顶层目录中，您会发现这两个应用程序的一些 jar 文件。您需要把 mail.jar 和 activation.jar 文件添加到您的 CLASSPATH 中。如果你使用第三方邮件服务器如QQ的SMTP服务器，可查看文章底部用户认证完整的实例。 发送一封简单的 E-mail下面是一个发送简单E-mail的例子。假设你的localhost已经连接到网络。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 文件名 SendEmail.java import java.util.*;import javax.mail.*;import javax.mail.internet.*;import javax.activation.*; public class SendEmail&#123; public static void main(String [] args) &#123; // 收件人电子邮箱 String to = \"abcd@gmail.com\"; // 发件人电子邮箱 String from = \"web@gmail.com\"; // 指定发送邮件的主机为 localhost String host = \"localhost\"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); // 获取默认session对象 Session session = Session.getDefaultInstance(properties); try&#123; // 创建默认的 MimeMessage 对象 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头部头字段 message.setSubject(\"This is the Subject Line!\"); // 设置消息体 message.setText(\"This is actual message\"); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully....\"); &#125;catch (MessagingException mex) &#123; mex.printStackTrace(); &#125; &#125;&#125; 编译并运行这个程序来发送一封简单的E-mail： 12$ java SendEmailSent message successfully.... 如果你想发送一封e-mail给多个收件人，那么使用下面的方法来指定多个收件人ID： 123void addRecipients(Message.RecipientType type, Address[] addresses)throws MessagingException 下面是对于参数的描述：type:要被设置为 TO, CC 或者 BCC，这里 CC 代表抄送、BCC 代表秘密抄送。举例：Message.RecipientType.TOaddresses: 这是 email ID 的数组。在指定电子邮件 ID 时，你将需要使用 InternetAddress() 方法。 发送一封 HTML E-mail下面是一个发送 HTML E-mail 的例子。假设你的 localhost 已经连接到网络。和上一个例子很相似，除了我们要使用 setContent() 方法来通过第二个参数为 “text/html”，来设置内容来指定要发送HTML 内容。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 文件名 SendHTMLEmail.java import java.util.*;import javax.mail.*;import javax.mail.internet.*;import javax.activation.*; public class SendHTMLEmail&#123; public static void main(String [] args) &#123; // 收件人电子邮箱 String to = \"abcd@gmail.com\"; // 发件人电子邮箱 String from = \"web@gmail.com\"; // 指定发送邮件的主机为 localhost String host = \"localhost\"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); // 获取默认的 Session 对象。 Session session = Session.getDefaultInstance(properties); try&#123; // 创建默认的 MimeMessage 对象。 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头字段 message.setSubject(\"This is the Subject Line!\"); // 发送 HTML 消息, 可以插入html标签 message.setContent(\"&lt;h1&gt;This is actual message&lt;/h1&gt;\", \"text/html\" ); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully....\"); &#125;catch (MessagingException mex) &#123; mex.printStackTrace(); &#125; &#125;&#125; 编译并运行此程序来发送HTML e-mail： 12$ java SendHTMLEmailSent message successfully.... 发送带有附件的 E-mail下面是一个发送带有附件的 E-mail的例子。假设你的localhost已经连接到网络。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 文件名 SendFileEmail.java import java.util.*;import javax.mail.*;import javax.mail.internet.*;import javax.activation.*; public class SendFileEmail&#123; public static void main(String [] args) &#123; // 收件人电子邮箱 String to = \"abcd@gmail.com\"; // 发件人电子邮箱 String from = \"web@gmail.com\"; // 指定发送邮件的主机为 localhost String host = \"localhost\"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); // 获取默认的 Session 对象。 Session session = Session.getDefaultInstance(properties); try&#123; // 创建默认的 MimeMessage 对象。 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头字段 message.setSubject(\"This is the Subject Line!\"); // 创建消息部分 BodyPart messageBodyPart = new MimeBodyPart(); // 消息 messageBodyPart.setText(\"This is message body\"); // 创建多重消息 Multipart multipart = new MimeMultipart(); // 设置文本消息部分 multipart.addBodyPart(messageBodyPart); // 附件部分 messageBodyPart = new MimeBodyPart(); String filename = \"file.txt\"; DataSource source = new FileDataSource(filename); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(filename); multipart.addBodyPart(messageBodyPart); // 发送完整消息 message.setContent(multipart ); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully....\"); &#125;catch (MessagingException mex) &#123; mex.printStackTrace(); &#125; &#125;&#125; 编译并运行你的程序来发送一封带有附件的邮件。12$ java SendFileEmailSent message successfully.... 用户认证部分如果需要提供用户名和密码给e-mail服务器来达到用户认证的目的，你可以通过如下设置来完成：123props.put(\"mail.smtp.auth\", \"true\");props.setProperty(\"mail.user\", \"myuser\");props.setProperty(\"mail.password\", \"mypwd\"); e-mail其他的发送机制和上述保持一致。需要用户名密码验证邮件发送实例:本实例以 QQ 邮件服务器为例，你需要在登录QQ邮箱后台在”设置”=》账号中开启POP3/SMTP服务 ，如下图所示：QQ 邮箱通过生成授权码来设置密码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 需要用户名密码邮件发送实例//文件名 SendEmail2.java//本实例以QQ邮箱为例，你需要在qq后台设置 import java.util.Properties; import javax.mail.Authenticator;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.PasswordAuthentication;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage; public class SendEmail2&#123; public static void main(String [] args) &#123; // 收件人电子邮箱 String to = \"xxx@qq.com\"; // 发件人电子邮箱 String from = \"xxx@qq.com\"; // 指定发送邮件的主机为 smtp.qq.com String host = \"smtp.qq.com\"; //QQ 邮件服务器 // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); properties.put(\"mail.smtp.auth\", \"true\"); // 获取默认session对象 Session session = Session.getDefaultInstance(properties,new Authenticator()&#123; public PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(\"xxx@qq.com\", \"qq邮箱密码\"); //发件人邮件用户名、密码 &#125; &#125;); try&#123; // 创建默认的 MimeMessage 对象 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头部头字段 message.setSubject(\"This is the Subject Line!\"); // 设置消息体 message.setText(\"This is actual message\"); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully....from w3cschool.cc\"); &#125;catch (MessagingException mex) &#123; mex.printStackTrace(); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java高级编程之数据结构","date":"2017-03-11T15:30:46.000Z","path":"2017/03/11/Java/2017-03-11-Java 高级编程之数据结构/","text":"枚举（Enumeration）枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。 位集合（BitSet）位集合类实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。 向量（Vector）向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。和数组一样，Vector对象的元素也能通过索引访问。使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。 栈（Stack）栈（Stack）实现了一个后进先出（LIFO）的数据结构。你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。 字典（Dictionary）字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。 哈希表（Hashtable）Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。 属性（Properties）Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java 包(package)","date":"2017-03-11T14:59:01.000Z","path":"2017/03/11/Java/2017-03-11-Java 包(package)/","text":"包的作用1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。包语句的语法格式为：package pkg1[．pkg2[．pkg3…]];例如,一个Something.java 文件它的内容1234package net.java.utilpublic class Something&#123; ...&#125; 那么它的路径应该是 net/java/util/Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。以下是一些 Java 中的包：java.lang-打包基础的类java.io-包含输入输出功能的函数开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。 创建包创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。例子让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。在 animals 包中加入一个接口（interface）：1234567/* 文件名: Animal.java */package animals; interface Animal &#123; public void eat(); public void travel();&#125; 接下来，在同一个包中加入该接口的实现：1234567891011121314151617181920212223package animals; /* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(\"Mammal eats\"); &#125; public void travel()&#123; System.out.println(\"Mammal travels\"); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行：12345$ mkdir animals$ cp Animal.class MammalInt.class animals$ java animals/MammalIntMammal eatsMammal travel import 关键字为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：import package1[.package2…].(classname|*);如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。例子下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss类的实例如下。123456789package payroll; public class Boss&#123; public void payEmployee(Employee e) &#123; e.mailCheck(); &#125;&#125; 如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。使用类全名描述，例如：payroll.Employee用 import 关键字引入，使用通配符 ““`import payroll.;使用 import 关键字引入 Employee 类:import payroll.Employee;` 【注意】类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 package 的目录结构类放在包中会有两种主要的结果：包名成为类名的一部分，正如我们前面讨论的一样。包名必须与相应的字节码所在的目录结构相吻合。下面是管理你自己 java 中文件的一种简单方式：将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：1234567// 文件名 : Car.java package vehicle; public class Car &#123; // 类实现 &#125; 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。....\\vehicle\\Car.java现在，正确的类名和路径将会是如下样子：类名 -&gt; vehicle.Car路径名 -&gt; vehicle\\Car.java (在 windows 系统中)通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。例如：有一个 com.lianyucode.test 的包，这个包包含一个叫做 Hello.java 的源文件，那么相应的，应该有如下面的一连串子目录：....\\com\\lianyucode\\test\\Hello.java编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如： 123456789// 文件名: Hello.java package com.lianyucode.test;public class Hello &#123; &#125;class Google &#123; &#125; 现在，我们用-d选项来编译这个文件，如下：$javac -d . Hello.java这样会像下面这样放置编译了的文件：12.\\com\\lianyucode\\test\\Runoob.class.\\com\\lianyucode\\test\\Google.class","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java接口","date":"2017-03-11T14:38:18.000Z","path":"2017/03/11/Java/2017-03-11-Java接口/","text":"接口与类相似点：一个接口可以有多个方法。接口文件保存在 .java 结尾的文件中，文件名使用接口名。接口的字节码文件保存在 .class 结尾的文件中。接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别：接口不能用于实例化对象。接口没有构造方法。接口中所有的方法必须是抽象方法。接口不能包含成员变量，除了 static 和 final 变量。接口不是被类继承了，而是要被类实现。接口支持多重继承。 接口特性接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误。接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能还有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。接口的声明接口的声明语法格式如下： 1234[可见度] interface 接口名称 [extends 其他的类名] &#123; // 声明变量 // 抽象方法&#125; Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。123456789/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包 public interface NameOfInterface&#123; //任何类型 final, static 字段 //抽象方法&#125; 接口有以下特性：接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。接口中的方法都是公有的。 实例12345/* 文件名 : Animal.java */interface Animal &#123; public void eat(); public void travel();&#125; 接口的实现当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。实现一个接口的语法，可以使用这个公式：...implements 接口名称[, 其他接口, 其他接口..., ...] ... 实例123456789101112131415161718192021/* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(\"Mammal eats\"); &#125; public void travel()&#123; System.out.println(\"Mammal travels\"); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 以上实例编译运行结果如下:12Mammal eatsMammal travels 重写接口中声明的方法时，需要注意以下规则：类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。如果实现接口的类是抽象类，那么就没必要实现该接口的方法。在实现接口的时候，也要注意一些规则：一个类可以同时实现多个接口。一个类只能继承一个类，但是能实现多个接口。一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。下面的Sports接口被Hockey和Football接口继承：1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports&#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125; // 文件名: Football.javapublic interface Football extends Sports&#123; public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);&#125; // 文件名: Hockey.javapublic interface Hockey extends Sports&#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 接口的多重继承在Java中，类的多重继承是不合法，但接口允许多重继承，。在接口的多重继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：1public interface Hockey extends Sports, Event 标记接口最常用的继承接口是没有包含任何方法的接口。标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：123package java.util;public interface EventListener&#123;&#125; 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：建立一个公共的父接口：正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。向一个类添加数据类型：这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java封装","date":"2017-03-11T13:32:19.000Z","path":"2017/03/11/Java/2017-03-11-1-Java 封装/","text":"封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 实现Java封装的步骤1. 修改属性的可见性来限制对属性的访问（一般限制为private），例如： 1234567891011121314151617181920212223242526272829public class Person &#123; private String name; private int age;&#125;``` 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。**2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：** ```javapublic class Person&#123; private String name; private int age;​ public int getAge()&#123; return age; &#125;​ public String getName()&#123; return name; &#125;​ public void setAge(int age)&#123; this.age = age; &#125;​ public void setName(String name)&#123; this.name = name; &#125;&#125; 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 实例让我们来看一个java封装类的例子：12345678910111213141516171819202122232425262728293031/* 文件名: EncapTest.java */public class EncapTest&#123; private String name; private String idNum; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public String getIdNum()&#123; return idNum; &#125; public void setAge( int newAge)&#123; age = newAge; &#125; public void setName(String newName)&#123; name = newName; &#125; public void setIdNum( String newId)&#123; idNum = newId; &#125;&#125; 以上实例中public方法是外部类访问该类成员变量的入口。通常情况下，这些方法被称为getter和setter方法。因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。通过如下的例子说明EncapTest类的变量怎样被访问：123456789101112/* F文件名 : RunEncap.java */public class RunEncap&#123; public static void main(String args[])&#123; EncapTest encap = new EncapTest(); encap.setName(\"James\"); encap.setAge(20); encap.setIdNum(\"12343ms\"); System.out.print(\"Name : \" + encap.getName()+ \" Age : \"+ encap.getAge()); &#125;&#125; 以上代码编译运行结果如下:Name : James Age : 20","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java抽象类","date":"2017-03-11T13:08:31.000Z","path":"2017/03/11/Java/2017-03-11-1-Java 抽象类/","text":"抽象类在Java语言中使用abstract class来定义抽象类。如下实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 文件名 : Employee.java */public abstract class Employee&#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println(\"Constructing an Employee\"); this.name = name; this.address = address; this.number = number; &#125; public double computePay() &#123; System.out.println(\"Inside Employee computePay\"); return 0.0; &#125; public void mailCheck() &#123; System.out.println(\"Mailing a check to \" + this.name + \" \" + this.address); &#125; public String toString() &#123; return name + \" \" + address + \" \" + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; 注意到该Employee类没有什么不同，尽管该类是抽象类，但是它仍然有3个成员变量，7个成员方法和1个构造方法。 现在如果你尝试如下的例子：123456789101112/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; /* 以下是不允许的，会引发错误 */ Employee e = new Employee(\"George W.\", \"Houston, TX\", 43); System.out.println(\"\\n Call mailCheck using Employee reference--\"); e.mailCheck(); &#125;&#125; 当你尝试编译AbstractDemo类时，会产生如下错误：1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 继承抽象类我们能通过一般的方法继承Employee类：123456789101112131415161718192021222324252627282930313233/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; //Annual salary public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println(\"Within mailCheck of Salary class \"); System.out.println(\"Mailing check to \" + getName() + \" with salary \" + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println(\"Computing salary pay for \" + getName()); return salary/52; &#125;&#125; 尽管我们不能实例化一个Employee类的对象，但是如果我们实例化一个Salary类对象，该对象将从Employee类继承3个成员变量和7个成员方法。123456789101112131415/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta, UP\", 3, 3600.00); Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2, 2400.00); System.out.println(\"Call mailCheck using Salary reference --\"); s.mailCheck(); System.out.println(\"\\n Call mailCheck using Employee reference--\"); e.mailCheck(); &#125;&#125; 以上程序编译运行结果如下：123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 抽象方法如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 12345678910public abstract class Employee&#123; private String name; private String address; private int number; public abstract double computePay(); //其余代码&#125; 声明抽象方法会造成以下两个结果：如果一个类包含抽象方法，那么该类必须是抽象类。任何子类必须重写父类的抽象方法，或者声明自身为抽象类。继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。如果Salary类继承了Employee类，那么它必须实现computePay()方法：12345678910111213/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; // Annual salary public double computePay() &#123; System.out.println(\"Computing salary pay for \" + getName()); return salary/52; &#125; //其余代码&#125; 抽象类总结规定 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java多态","date":"2017-03-11T12:40:36.000Z","path":"2017/03/11/Java/2017-03-11-1-Java-多态/","text":"多态性是对象多种表现形式的体现。现实中，比如我们按下 F1 键这个动作：如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性多态存在的三个必要条件继承重写父类引用指向子类对象 例如 Parent p = new Child();当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。以下是一个多态实例的演示，详细说明请看注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 catchMouse &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事情 Cat c = (Cat)a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事情 Dog c = (Dog)a; c.work(); &#125; &#125; &#125; abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125; public void work() &#123; System.out.println(\"抓老鼠\"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125; public void work() &#123; System.out.println(\"看家\"); &#125; &#125; 执行以上程序，输出结果为：123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 虚方法我们将介绍在Java中，当设计类时，被重写的方法的行为怎样影响多态性。我们已经讨论了方法的重写，也就是子类能够重写父类的方法。当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，则必须使用关键字super。12345678910111213141516171819202122232425262728293031/* 文件名 : Employee.java */public class Employee &#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println(\"Employee 构造函数\"); this.name = name; this.address = address; this.number = number; &#125; public void mailCheck() &#123; System.out.println(\"邮寄支票给： \" + this.name + \" \" + this.address); &#125; public String toString() &#123; return name + \" \" + address + \" \" + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; 假设下面的类继承Employee类：1234567891011121314151617181920212223242526/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; // 全年工资 public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println(\"Salary 类的 mailCheck 方法 \"); System.out.println(\"邮寄支票给：\" + getName() + \" ，工资为：\" + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println(\"计算工资，付给：\" + getName()); return salary/52; &#125;&#125; 现在我们仔细阅读下面的代码，尝试给出它的输出结果：1234567891011/* 文件名 : VirtualDemo.java */public class VirtualDemo &#123; public static void main(String [] args) &#123; Salary s = new Salary(\"员工 A\", \"北京\", 3, 3600.00); Employee e = new Salary(\"员工 B\", \"上海\", 2, 2400.00); System.out.println(\"使用 Salary 的引用调用 mailCheck -- \"); s.mailCheck(); System.out.println(\"\\n使用 Employee 的引用调用 mailCheck--\"); e.mailCheck(); &#125;&#125; 123456789Employee 构造函数Employee 构造函数使用 Salary 的引用调用 mailCheck -- Salary 类的 mailCheck 方法 邮寄支票给：员工 A ，工资为：3600.0使用 Employee 的引用调用 mailCheck--Salary 类的 mailCheck 方法 邮寄支票给：员工 B ，工资为：2400.0 例子解析实例中，实例化了两个 Salary 对象：一个使用 Salary 引用 s，另一个使用 Employee 引用 e。当调用 s.mailCheck() 时，编译器在编译时会在 Salary 类中找到 mailCheck()，执行过程 JVM 就调用 Salary 类的 mailCheck()。因为 e 是 Employee 的引用，所以调用 e 的 mailCheck() 方法时，编译器会去 Employee 类查找 mailCheck() 方法 。在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。 多态的实现方式方式一：重写：这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。方式二：接口 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。方式三：抽象类和抽象方法","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java继承","date":"2017-03-11T12:11:29.000Z","path":"2017/03/11/Java/2017-03-11-1-Java继承/","text":"类的继承格式在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：1234class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 为什么需要继承接下来我们通过实例来说明这个需求。开发动物类，其中动物分别为企鹅以及老鼠，要求如下：企鹅：属性（姓名，id），方法（吃，睡，自我介绍）老鼠：属性（姓名，id），方法（吃，睡，自我介绍）123456789101112131415161718//企鹅类：public class Penguin &#123; private String name; private int id; public Penguin(String myName, int myid) &#123; name = myName; id = myid; &#125; public void eat()&#123; System.out.println(name+\"正在吃\"); &#125; public void sleep()&#123; System.out.println(name+\"正在睡\"); &#125; public void introduction() &#123; System.out.println(\"大家好！我是\" + id + \"号\" + name + \".\"); &#125; &#125; 123456789101112131415161718//老鼠类public class Mouse &#123; private String name; private int id; public Mouse(String myName, int myid) &#123; name = myName; id = myid; &#125; public void eat()&#123; System.out.println(name+\"正在吃\"); &#125; public void sleep()&#123; System.out.println(name+\"正在睡\"); &#125; public void introduction() &#123; System.out.println(\"大家好！我是\" + id + \"号\" + name + \".\"); &#125; &#125; 从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类：123456789101112131415161718//公共父类public class Animal &#123; private String name; private int id; public Animal(String myName, int myid) &#123; name = myName; id = myid; &#125; public void eat()&#123; System.out.println(name+\"正在吃\"); &#125; public void sleep()&#123; System.out.println(name+\"正在睡\"); &#125; public void introduction() &#123; System.out.println(\"大家好！我是\" + id + \"号\" + name + \".\"); &#125; &#125; 这个Animal类就可以作为一个父类，然后企鹅类和老鼠类继承这个类之后，就具有父类当中的属性和方法，子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 继承之后的代码：123456//企鹅类public class Penguin extends Animal &#123; public Penguin(String myName, int myid) &#123; super(myName, myid); &#125; &#125; 123456//老鼠类public class Mouse extends Animal &#123; public Mouse(String myName, int myid) &#123; super(myName, myid); &#125; &#125; 继承的特性子类拥有父类非private的属性，方法。子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。 继承关键字继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。extends关键字在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。123456789101112//extends 关键字public class Animal &#123; private String name; private int id; public Animal(String myName, String myid) &#123; //初始化属性值 &#125; public void eat() &#123; //吃东西方法的具体实现 &#125; public void sleep() &#123; //睡觉方法的具体实现 &#125; &#125; public class Penguin extends Animal&#123; &#125; implements关键字使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）123456789101112//implements 关键字public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; super 与 this 关键字super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。this关键字：指向自己的引用。12345678910111213141516public class SuperDemo &#123; public static void main(String []args) &#123; new SubClass().showMessage(); &#125;&#125; class SuperClass &#123; int i = 50;&#125; class SubClass extends SuperClass &#123; int i =100; public void showMessage() &#123; System.out.printf(\"super.i = %d, this.i = %d\\n\", super.i, this.i); &#125;&#125; 输出的结果为super.i = 50, this.i = 100final关键字final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：声明类：final class 类名 {//类体}声明方法：修饰符(public,private,void,protected等) final 返回值类型 方法名(){//方法体}构造器子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。1234567891011121314151617181920212223242526272829 class SuperClass &#123; private int n; SuperClass()&#123; System.out.println(\"SuperClass()\"); &#125; SuperClass(int n) &#123; System.out.println(\"SuperClass(int n)\"); this.n = n; &#125;&#125;class SubClass extends SuperClass&#123; private int n; SubClass()&#123; super(300); System.out.println(\"SubClass\"); &#125; public SubClass(int n)&#123; System.out.println(\"SubClass(int n):\"+n); this.n = n; &#125;&#125;public class TestSuperSub&#123; public static void main (String args[])&#123; SubClass sc = new SubClass(); SubClass sc2 = new SubClass(200); &#125;&#125; 输出的结果为1234SuperClass(int n)SubClassSuperClass()SubClass(int n):200","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java对象和类","date":"2017-03-11T11:53:03.000Z","path":"2017/03/11/Java/2017-03-11-1-Java-对象和类/","text":"基本概念对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。类：类是一个模板，它描述一类对象的行为和状态。 Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 Java中的类类可以看成是创建Java对象的模板。通过下面一个简单的类来理解下Java中类的定义：12345678910111213public class Dog&#123; String breed; int age; String color; void barking()&#123; &#125; void hungry()&#123; &#125; void sleeping()&#123; &#125;&#125; 一个类可以包含以下类型变量：局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法 构造方法每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。下面是一个构造方法示例：12345678public class Puppy&#123; public Puppy()&#123; &#125; public Puppy(String name)&#123; // 这个构造器仅有一个参数：name &#125;&#125; 创建对象对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：声明：声明一个对象，包括对象名称和对象类型。实例化：使用关键字new来创建一个对象。初始化：使用new创建对象时，会调用构造方法初始化对象。下面是一个创建对象的例子：12345678910public class Puppy&#123; public Puppy(String name)&#123; //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); &#125; public static void main(String []args)&#123; // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); &#125;&#125; 编译并运行上面的程序，会打印出下面的结果：小狗的名字是 : tommy 访问实例变量和方法通过已创建的对象来访问成员变量和成员方法，如下所示：123456/* 实例化对象 */ObjectReference = new Constructor();/* 访问其中的变量 */ObjectReference.variableName;/* 访问类中的方法 */ObjectReference.MethodName(); 实例下面的例子展示如何访问实例变量和调用成员方法：123456789101112131415161718192021222324252627public class Puppy&#123; int puppyAge; public Puppy(String name)&#123; // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); &#125; public void setAge( int age )&#123; puppyAge = age; &#125; public int getAge( )&#123; System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; &#125; public static void main(String []args)&#123; /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); &#125;&#125; 源文件声明规则在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。一个源文件中只能有一个public类一个源文件可以有多个非public类源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。如果一个类定义在某个包中，那么package语句应该在源文件的首行。如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java基础语法","date":"2017-03-11T05:57:33.000Z","path":"2017/03/11/Java/2017-03-11-Java-基础语法/","text":"基本概念类：类是一个模板，它描述一类对象的行为和状态。对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 基本语法编写Java程序时，应注意以下几点：大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstClass 。方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。 Java标识符Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。关于Java标识符，有以下几点需要注意：所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（）开始首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（）或数字的任何字符组合关键字不能用作标识符标识符是大小写敏感的合法标识符举例：age、$salary、_value、__1_value非法标识符举例：123abc、-salary Java修饰符像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：访问控制修饰符 : default, public , protected, private非访问控制修饰符 : final, abstract, strictfp在后面的章节中我们会深入讨论Java修饰符。 Java变量Java中主要有如下几种类型的变量局部变量类变量（静态变量）成员变量（非静态变量） Java枚举Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。 1234567891011class FreshJuice &#123; enum FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125; FreshJuiceSize size;&#125; public class FreshJuiceTest &#123; public static void main(String []args)&#123; FreshJuice juice = new FreshJuice(); juice.size = FreshJuice. FreshJuiceSize.MEDIUM ; &#125;&#125; Java关键字下面列出了Java保留字。这些保留字不能用于常量、变量、和任何标识符的名称。关键字 描述 关键字 描述 abstract 抽象方法，抽象类的修饰符 || assert | 断言条件是否满足 || boolean | 断言条件是否满足 || break | 跳出循环或者label代码段 || byte | 8-bit 有符号数据类型 || case | switch语句的一个条件 || catch | 和try搭配扑捉异常信息 || char | 16-bit Unicode字符数据类型 || class | 定义类 || const | 未使用 || continue | 不执行循环体剩余部分 || default | switch语句中的默认分支 || do | 循环语句，循环体至少会执行一次 || double | 64-bit双精度浮点数 || else | if条件不成立时执行的分支 || enum | 枚举类型 || extends | 表示一个类是另一个类的子类 || final | 表示一个值在初始化之后就不能再改变了 表示方法不能被重写，或者一个类不能有子类 || finally | 为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。 || float | 32-bit单精度浮点数 || for | for循环语句 || goto | 未使用 || if | 条件语句 || implements | 表示一个类实现了接口 || import | 导入类 || instanceof | 测试一个对象是否是某个类的实例 || int | 32位整型数 || interface | 接口，一种抽象的类型，仅有方法和常量的定义 || long | 64位整型数 || native | 表示方法用非java代码实现 || new | 分配新的类实例 || package | 一系列相关类组成一个包 || private | 表示私有字段，或者方法等，只能从类内部访问 || protected | 表示字段只能通过类或者其子类访问 子类或者在同一个包内的其他类 || public | 表示共有属性或者方法 || return | 方法返回值 || short | 16位数字 || static | 表示在类级别定义，所有实例共享的 || strictfp | 浮点数比较使用严格的规则 || super | 表示基类 || switch | 选择语句 || synchronized | 表示同一时间只能由一个线程访问的代码块 || this | 表示调用当前实例 或者调用另一个构造函数 || throw | 抛出异常 || throws | 定义方法可能抛出的异常 || transient | 修饰不要序列化的字段 || try | 表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码 || void | 标记方法不返回任何值 || volatile | 标记字段可能会被多个线程同时访问，而不做同步 || while | while循环 | 继承在Java中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。 接口在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java简介","date":"2017-03-11T05:41:31.000Z","path":"2017/03/11/Java/2017-03-11-java简介/","text":"简介Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。Java分为三个体系：JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字”2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。 Java主要特性Java语言是简单的：Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。 Java语言是面向对象的：Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。 Java语言是分布式的：Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。 Java语言是健壮的：Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。 Java语言是安全的：Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。 Java语言是体系结构中立的：Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。 Java语言是可移植的：这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。 Java语言是解释型的：如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。 Java是高性能的：与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。 Java语言是多线程的：在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。 Java语言是动态的：Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。 Java的发展历史·1995年5月23日，Java语言诞生·1996年1月，第一个JDK-JDK1.0诞生·1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术·1996年9月，约8.3万个网页应用了JAVA技术来制作·1997年2月18日，JDK1.1发布·1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录·1997年9月，JavaDeveloperConnection社区成员超过十万·1998年2月，JDK1.1被下载超过2,000,000次·1998年12月8日，JAVA2企业平台J2EE发布·1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是·J2EE）和微型版（JavaME，以前是J2ME）·2000年5月8日，JDK1.3发布·2000年5月29日，JDK1.4发布·2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机·2001年9月24日，J2EE1.3发布·2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升·2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0·2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字”2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME·2006年12月，SUN公司发布JRE6.0·2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。·2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP[4]。·2011年7月28日，甲骨文发布java7.0的正式版。·2014年3月18日，Oracle公司发表Java SE 8。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"Java入门教程之第一个程序","date":"2017-03-11T04:46:40.000Z","path":"2017/03/11/Java/2017-03-11-java-lesson1/","text":"前言Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。本教程通过简单的实例将让大家更好的了解JAVA编程语言。 编译器安装1.下载eclipse,下载地址 https://www.eclipse.org/downloads/download.php?file=/oomph/epp/neon/R2a/eclipse-inst-mac64.tar.gz&amp;mirror_id=12222.下载下来的文件为tar.gz格式的。【注】3.在终端上执行命令tar zxvf /Users/one/Desktop/eclipse-java-neon-2-macosx-cocoa-x86_64.tar.gz 即可完成安装 第一个Java程序打开编译器,如图选择工作空间,然后点击ok进入下一个页面选择creat a new Java Project为你的工程起一个名字,比如HelloJava在src文件下创建HelloWord类然后点击运行如图第一个程序运行成功Hello World12345public class HelloWorld &#123; public static void main(String []args) &#123; System.out.println(\"Hello World\"); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.devzou.com/tags/Java/"}]},{"title":"iOS静态库、动态库，Framework和.a以及.dylib/.tbd区别","date":"2017-03-09T07:22:51.000Z","path":"2017/03/09/ios/2017-03-09-ios-static_library/","text":"一. 静态库与动态库首先要解释一下什么是库，库(Library)其实就是一段编译好的二进制代码，加上头文件就可以供别人使用，一般会有两种情况要用到库：某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。对于某些不会进行大的改动的代码，比方说很多大公司常用且很少变动的模块都会编译成库，这样做的好处一是可以节省编译时间，二来对于代码的管理也非常方便。因为库是已经编译好的二进制文件了，编译的时候只需要link一下，既然提到了link那就有不同的形式了，静态和动态，与之相对应的就是静态库和动态库。 1. 静态库平时我们用的第三方SDK基本上都是静态库，静态库的几个特点：在App项目编译的时候会被拷贝一份编译到目标程序中，相当于将静态库嵌入了，所以得到的App二进制文件会变大。在使用的时候，需要手动导入静态库所依赖的其他类库。（比如说某个SDK中使用到了CoreMotion.framework，在使用的时候需要手动导入。有的SDK需要link十几个系统库，这个时候非常恶心，只能一个一个手动加，这是静态库一个很大的不便之处。）导入静态库的应用可以减少对外界的依赖，如果导入的是第三方动态库，动态库找不到的话应用就会崩掉，例如Linux上经常出现的lib not found。静态库很大的一个优点是减少耦合性，因为静态库中是不可以包含其他静态库的，使用的时候要另外导入它的依赖库，最大限度的保证了每一个静态库都是独立的，不会重复引用。 2. 动态库这个是我们最常用的一类库，使用频率最高的UIKit.framework和Fundation.framework都属于动态库，所有.dylib和.tbd结尾的都属于动态库。动态库的几个特点：平时使用的系统库都放在iOS系统中，在你打包应用程序的时候这些库不会拷贝到你的程序中，当需要使用的时候会动态从iOS系统中加载它们，因为这个原因，动态库也被称作共享库。编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。这些库是所有应用公用的，换一种说法就是节省了应用安装包的体积，这是区别静态库很重要的一个特点，因为静态库使用一次就要拷贝一次，非常浪费资源。动态库在制作的时候可以直接包含静态库，也能自动link所需要的依赖库。使用动态库的时候不需要再次link依赖库，即导即用，这个就厉害了。唯一需要注意的是在导入自己制作的动态库时，需要在Embedded Binaries中导入，不然会报错：image not found。此时这个动态库会跟静态库一样被拷贝到目标程序中进行编译，苹果又把这种Framework叫做Embedded Framework关于动态库要搞清楚一点，我们自己制作的动态库与系统动态库的区别，我们自己制作的动态库引入App项目的时候需要embed进项目，也就是要拷贝到目标程序中，这就有点不像动态库的特性了，苹果这么做也是考虑安全问题吧！至于能不能正常上架，我也不清楚，查了大量资料都是抄来抄去没说清楚，我猜测是不能上架的，因为一般的第三方SDK也都是静态库的形式，我猜测一个重要原因是iOS的应用本来就是运行在沙盒里面的，不同应用之间不能共享代码，同时动态下载代码苹果肯定也是明令禁止的，所以动态库也就失去意义了。当然可能还有其他因素，欢迎交流学习！ 二. Framework、.a、.dylib/.tbd1. FrameworkFramework的英文释意是框架，主要由Headers、binary文件、.bundle这三部分构成，除此之外还有Info.plist和Modules，后两者主要记录Framework的版本之类的信息，一般都会删掉，不做讨论Headers包含我们在制作Framework的时候暴露的头文件，所有被暴露的.h都放在这里。binary文件整个Framework的核心，所有代码都被编译成了这样一坨二进制文件，这里要注意的是添加的依赖库不会被编译进来，用的时候还需要重新link其他依赖库。.bundle资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。注意：图片放进bundle之后不可以用[UIImage ImageWithName:]读取图片。要先找到bundle包再拿图片。这里要纠正一个误区很多人认为系统的Framework就是动态库，我们自己制作的Framework就是静态库。其实Framework既可以是静态库也可以是动态库，这取决于编译成的Mach-O（就是那个二进制文件）是动态库还是静态库，Framework本质上并不是一个库，它是苹果为了方便开发者提供了一种库的打包方式，Framework会将Mach-O文件、头文件和资源包全都包含进来，不需要你再手动整理，我们也可以通过Xcode来制作framework动态库使用。所以总结： Framework是库的打包形式，既可以是动态库也是静态库。 2. .a静态库这类静态库与Framework基本类似，不同的是在打包成.a文件的同时，还需要提供头文件，使用时相较于Framework比较麻烦，（例如微信支付SDK使用的是.a，不同的是支付宝SDK是以framework的形式打包的）。.a这样打包不够方便，而Framework编译完成暴露的头文件都已经放好了。 3. .dylib/.tbd 动态库这类动态库我们也经常用，基本上都是系统提供的，一般不能自己制作，就算你通过其他方式制作使用，也肯定不能上架的，这里没什么好讲的。","tags":[{"name":"静态库、动态库、Framework","slug":"静态库、动态库、Framework","permalink":"https://www.devzou.com/tags/静态库、动态库、Framework/"}]},{"title":"遗传算法","date":"2017-02-28T09:21:39.000Z","path":"2017/02/28/AI/2017-02-28-遗传算法/","text":"遗传算法思想 借鉴生物进化论，遗传算法将要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰掉适应度函数值低的解，增加适应度函数值高的解。这样进化N代后就很有可能会进化出适应度函数值很高的个体。 举个例子，使用遗传算法解决“0-1背包问题”的思路：0-1背包的解可以编码为一串0-1字符串（0：不取，1：取） ；首先，随机产生M个0-1字符串，然后评价这些0-1字符串作为0-1背包问题的解的优劣；然后，随机选择一些字符串通过交叉、突变等操作产生下一代的M个字符串，而且较优的解被选中的概率要比较高。这样经过G代的进化后就可能会产生出0-1背包问题的一个“近似最优解”。 编码：需要将问题的解编码成字符串的形式才能使用遗传算法。最简单的一种编码方式是二进制编码，即将问题的解编码成二进制位数组的形式。例如，问题的解是整数，那么可以将其编码成二进制位数组的形式。将0-1字符串作为0-1背包问题的解就属于二进制编码。 遗传算法有3个最基本的操作：选择，交叉，变异。 选择：选择一些染色体来产生下一代。一种常用的选择策略是 “比例选择”，也就是个体被选中的概率与其适应度函数值成正比。假设群体的个体总数是M，那么那么一个体Xi被选中的概率为f(Xi)/( f(X1) + f(X2) + …….. + f(Xn) ) 。比例选择实现算法就是所谓的“轮盘赌算法”( Roulette Wheel Selection ) ，轮盘赌算法的一个简单的实现如下：123456789101112131415161718//轮盘对赌法/** 按设定的概率，随机选中一个个体* P[i]表示第i个个体被选中的概率*/int RWS()&#123; m =0; r =Random(0,1); //r为0至1的随机数 for(i=1;i&lt;=N; i++) &#123; /* 产生的随机数在m~m+P[i]间则认为选中了i * 因此i被选中的概率是P[i] */ m = m + P[i]; if(r&lt;=m) return i; &#125;&#125; 交叉(Crossover)：2条染色体交换部分基因，来构造下一代的2条新的染色体。例如： 交叉前：1200000|011100000000|1000011100|000001111110|00101 交叉后：1200000|000001111110|1000011100|011100000000|00101 染色体交叉是以一定的概率发生的，这个概率记为Pc 。变异(Mutation)：在繁殖过程，新产生的染色体中的基因会以一定的概率出错，称为变异。变异发生的概率记为Pm 。例如： 变异前：1000001110000000010000 变异后：1000001110000100010000 适应度函数 ( Fitness Function )：用于评价某个染色体的适应度，用f(x)表示。有时需要区分染色体的适应度函数与问题的目标函数。例如：0-1背包问题的目标函数是所取得物品价值，但将物品价值作为染色体的适应度函数可能并不一定适合。适应度函数与目标函数是正相关的，可对目标函数作一些变形来得到适应度函数。","tags":[{"name":"算法","slug":"算法","permalink":"https://www.devzou.com/tags/算法/"}]},{"title":"openCV之像素值的读写","date":"2017-02-28T00:23:20.000Z","path":"2017/02/28/digitalImage/2017-02-28-openCV-像素值的读写/","text":"at()函数函数 at()来实现读去矩阵中的某个像素,或者对某个像素进行赋值操作。下面两行代码演示了 at()函数的使用方法。1uchar value = grayim.at&lt;uchar&gt;(i,j);//读出第i行第j列像素值 grayim.at&lt;uchar&gt;(i,j)=128; //将第i行第j列像素值设置为128 如果要对图像进行遍历,可以参考下面的例程。这个例程创建了两个图像, 分别是单通道的 grayim 以及 3 个通道的 colorim,然后对两个图像的所有像素值 进行赋值,最后现实结果。1234567#include &lt;iostream&gt; #include &quot;opencv2/opencv.hpp&quot; using namespace std; using namespace cv; int main(int argc, char* argv[]) &#123; Mat grayim(600, 800, CV_8UC1); Mat colorim(600, 800, CV_8UC3); //遍历所有像素,并设置像素值 for( int i = 0; i &lt; grayim.rows; ++i) for( int j = 0; j &lt; grayim.cols; ++j ) grayim.at&lt;uchar&gt;(i,j) = (i+j)%255; //遍历所有像素,并设置像素值 for( int i = 0; i &lt; colorim.rows; ++i) for( int j = 0; j &lt; colorim.cols; ++j ) &#123; Vec3b pixel; pixel[0] = i%255; //Blue pixel[1] = j%255; //Green pixel[2] = 0; //Red colorim.at&lt;Vec3b&gt;(i,j) = pixel; &#125; //显示结果 imshow(&quot;grayim&quot;, grayim); imshow(&quot;colorim&quot;, colorim); waitKey(0); return 0; &#125;","tags":[{"name":"openCV","slug":"openCV","permalink":"https://www.devzou.com/tags/openCV/"}]},{"title":"openCV之矩阵元素的表达","date":"2017-02-28T00:16:19.000Z","path":"2017/02/28/digitalImage/2017-02-28-openCV之矩阵元素的表达/","text":"模板类VecOpenCV 中有模板类 Vec,可以表示一个向量。OpenCV 中使用 Vec 类预定义了一 些小向量,可以将之用于矩阵元素的表达。1typedef Vec&lt;uchar, 2&gt; Vec2b; typedef Vec&lt;uchar, 3&gt; Vec3b; typedef Vec&lt;uchar, 4&gt; Vec4b; typedef Vec&lt;short, 2&gt; Vec2s; typedef Vec&lt;short, 3&gt; Vec3s; typedef Vec&lt;short, 4&gt; Vec4s; typedef Vec&lt;int, 2&gt; Vec2i; typedef Vec&lt;int, 3&gt; Vec3i; typedef Vec&lt;int, 4&gt; Vec4i; typedef Vec&lt;float, 2&gt; Vec2f; typedef Vec&lt;float, 3&gt; Vec3f; typedef Vec&lt;float, 4&gt; Vec4f; typedef Vec&lt;float, 6&gt; Vec6f; typedef Vec&lt;double, 2&gt; Vec2d; typedef Vec&lt;double, 3&gt; Vec3d; typedef Vec&lt;double, 4&gt; Vec4d; typedef Vec&lt;double, 6&gt; Vec6d; 例如 8U 类型的 RGB 彩色图像可以使用 Vec3b,3 通道 float 类型的矩阵可以 使用 Vec3f。对于 Vec 对象,可以使用[]符号如操作数组般读写其元素,如:1Vec3b color; //用color变量描述一种RGB颜色 color[0]=255; //B分量 color[1]=0; //G分量 color[2]=0; //R分量","tags":[{"name":"openCV","slug":"openCV","permalink":"https://www.devzou.com/tags/openCV/"}]},{"title":"openCV使用之Mat类","date":"2017-02-27T23:30:17.000Z","path":"2017/02/28/digitalImage/2017-02-28-openCV-Mat/","text":"新加入的 Mat 类能够自动管理内存。使用 Mat 类,你不再需要花费大量精 力在内存管理上。而且你的代码会变得很简洁,代码行数会变少。但 C++接口唯 一的不足是当前一些嵌入式开发系统可能只支持 C 语言,如果你的开发平台支持 C++,完全没有必要再用 IplImage 和 CvMat。在新版本的 OpenCV 中,开发者依 然可以使用 IplImage 和 CvMat,但是一些新增加的函数只提供了 Mat 接口。本书 中的例程也都将采用新的 Mat 类,不再介绍 IplImage 和 CvMat。Mat 类的定义如下所示,关键的属性如下方代码所示: 12345678910class CV_EXPORTS Mat &#123; public: //一系列函数 ... /* flag参数中包含许多关于矩阵的信息,如: -Mat 的标识 -数据是否连续 -深度 -通道数目 */ int flags; int dims; //矩阵的维数,取值应该大于或等于 2int rows, cols;//矩阵的行数和列数,如果矩阵超过 2 维,这两个变量的值都为-1 uchar* data;//指向数据的指针 int* refcount;//指向引用计数的指针,如果数据是由用户分配的,则为 NULL //其他成员变量和成员函数 ... &#125;; 创建Mat类Mat 是一个非常优秀的图像类,它同时也是一个通用的矩阵类,可以用来创建和操作多维矩阵。有多种方法创建一个 Mat 对象。 构造函数法Mat 类提供了一系列构造函数,可以方便的根据需要创建 Mat 对象。下面是 一个使用构造函数创建对象的例子。 1Mat M(3,2, CV_8UC3, Scalar(0,0,255)); cout &lt;&lt; &quot;M = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; M &lt;&lt; endl; 第一行代码创建一个行数(高度)为 3,列数(宽度)为 2 的图像,图像元 素是 8 位无符号整数类型,且有三个通道。图像的所有像素值被初始化为(0, 0, 255)。由于 OpenCV 中默认的颜色顺序为 BGR,因此这是一个全红色的图像。第二行代码是输出 Mat 类的实例 M 的所有像素值。Mat 重定义了&lt;&lt;操作符, 使用这个操作符,可以方便地输出所有像素值,而不需要使用 for 循环逐个像素输出。该段代码输出的内容为123M= [0,0,255,0,0,255; 0,0,255,0,0,255; 0,0,255,0,0,255] 常用的构造函数有12345678910Mat::Mat() //无参数构造方法Mat::Mat(int rows, int cols, int type) //创建行数为 rows,列数为 col,类型为 type 的图像Mat::Mat(Size size, int type) //创建大小为 size,类型为 type 的图像Mat::Mat(int rows, int cols, int type, const Scalar&amp; s)//创建行数为 rows,列数为 col,类型为 type 的图像,并将所有元素初始 化为值 sMat::Mat(Size size, int type, const Scalar&amp; s)//创建大小为 size,类型为 type 的图像,并将所有元素初始化为值 sMat::Mat(const Mat&amp;m)//将 m 赋值给新创建的对象,此处不会对图像数据进行复制,m 和新对象 共用图像数据Mat::Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP)//创建行数为 rows,列数为 col,类型为 type 的图像,此构造函数不创建 图像数据所需内存,而是直接使用 data 所指内存,图像的行步长由 step 指定Mat::Mat(Size size, int type, void* data, size_t step=AUTO_STEP)//创建大小为 size,类型为 type 的图像,此构造函数不创建图像数据所需 内存,而是直接使用 data 所指内存,图像的行步长由 step 指定。Mat::Mat(const Mat&amp; m, const Range&amp; rowRange, const Range&amp; colRange) //创建的新图像为 m 的一部分,具体的范围由 rowRange 和 colRange 指 定,此构造函数也不进行图像数据的复制操作,新图像与 m 共用图像数据Mat::Mat(const Mat&amp; m, const Rect&amp; roi)//创建的新图像为 m 的一部分,具体的范围 roi 指定,此构造函数也不进 行图像数据的复制操作,新图像与 m 共用图像数据。 这些构造函数中,很多都涉及到类型 type。type 可以是 CV_8UC1,CV_16SC1,…, CV_64FC4 等。里面的 8U 表示 8 位无符号整数,16S 表示 16 位有符号整数,64F 表示 64 位浮点数(即 double 类型);C 后面的数表示通道数,例如 C1 表示一个 通道的图像,C4 表示 4 个通道的图像,以此类推。如果你需要更多的通道数,需要用宏 CV_8UC(n),例如:1Mat M(3,2, CV_8UC(5));//创建行数为3,列数为2,通道数为5的图像 create()函数创建对象方法除了在构造函数中可以创建图像,也可以使用 Mat类的 create()函数创建图 像。如果 create()函数指定的参数与图像之前的参数相同,则不进行实质的内存 申请操作;如果参数不同,则减少原始数据内存的索引,并重新申请内存。使用方法如下面例程所示:12Mat M(2,2, CV_8UC3);//构造函数创建图像 M.create(3,2, CV_8UC2);//释放内存重新创建图像 【注】 使用 create()函数无法设置图像像素的初始值。 Matlab风格的创建对象方法OpenCV 2 中提供了 Matlab 风格的函数,如 zeros(),ones()和 eyes()。这种方 法使得代码非常简洁,使用起来也非常方便。使用这些函数需要指定图像的大小 和类型,使用方法如下:1Mat Z = Mat::zeros(2,3, CV_8UC1); cout &lt;&lt; &quot;Z = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; Z &lt;&lt; endl; Mat O = Mat::ones(2, 3, CV_32F); cout &lt;&lt; &quot;O = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; O &lt;&lt; endl; Mat E = Mat::eye(2, 3, CV_64F); cout &lt;&lt; &quot;E = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; E &lt;&lt; endl; 该代码中,有些 type 参数如 CV_32F 未注明通道数目,这种情况下它表示单 通道。上面代码的输出结果如图 所示。123456Z=[0,0,0; 0,0,0]O=[1,1,1; 1,1,1]E=[1,0,0; 0,1,0]","tags":[{"name":"数字图像处理","slug":"数字图像处理","permalink":"https://www.devzou.com/tags/数字图像处理/"}]},{"title":"图像的基本操作","date":"2017-02-27T14:58:11.000Z","path":"2017/02/27/digitalImage/2017-02-27-图像基本操作/","text":"数字图像的基本概念如图 1中所示的图像,我们看到的是 Lena 的头像,但是计算机看来,这副图像只是一堆亮度各异的点。一副尺寸为 M × N 的图像可以用一个 M × N 的矩阵来表示,矩阵元素的值表示这个位置上的像素的亮度,一般来说像素值越大表示该点越 亮。如图 3.1 中白色圆圈内的区域,进行放大并仔细查看,将会如图2所 示。一般来说,灰度图用二维矩阵表示,彩色(多通道)图像用三维矩阵(M × N × 3)表示。对于图像显示来说,目前大部分设备都是用无符号 8 位整 数(类型为 CV_8U)表示像素亮度。图像数据在计算机内存中的存储顺序为以图像最左上点(也可能是最左下 点)开始,存储如表所示。| I0 0 | I0 1 | … | I0 N-1 || :-: | :-: | :-: | :-: || I1 0 | I1 1 | … | I1 N-1 || … | … | | || IM-1 0 | IM-1 1 | … | IM-1 N-1 |Iij 表示第 i 行 j 列的像素值。如果是多通道图像,比如 RGB 图像,则每个 像素用三个字节表示。在 OpenCV 中,RGB 图像的通道顺序为 BGR ,存储如表2所示。 B0 0 G0 0 R0 0 B0 1 G0 1 R0 1 … B1 0 G1 0 R1 0 B1 1 G1 1 R1 1 … … … … … … … …","tags":[{"name":"数字图像处理","slug":"数字图像处理","permalink":"https://www.devzou.com/tags/数字图像处理/"}]},{"title":"走进openCV","date":"2017-02-27T14:36:11.000Z","path":"2017/02/27/ios/2017-02-27-openCV/","text":"openCV 是什么 OpenCV是一个开源的跨平台计算机视觉库，实现了图像处理和计算机视觉方面的很多通用算法。OpenCV 其实就是一堆 C 和 C++语言的源代码文件,这些源代码文件中实现了许多常用的计算机视觉算法。例如 C 接口函数 cvCanny()实现了 Canny 边缘提 取算法。可以直接将这些源代码添加到我们自己的软件项目中,而不需要自己再 去写代码实现 Canny 算法,也就是不需要重复“造轮子”。由于 OpenCV 中源代码文件巨多,根据算法的功能,将这些源文件分到多个 模块中:core、imgproc、highgui 等。将每个模块中的源文件编译成一个库文件 (如 opencv_core.lib、opencv_imgproc.lib、opencv_highgui.lib 等),用户在使用时, 仅将所需的库文件添加到自己的项目中,与自己的源文件一起连接成可执行程序 则可。 openCV介绍OpenCV 的全称是 Open Source Computer Vision Library,是一个开放源代码的 计算机视觉库。OpenCV 是最初由英特尔公司发起并开发,以 BSD 许可证授权发 行,可以在商业和研究领域中免费使用,现在美国 Willow Garage 为 OpenCV 提 供主要的支持。OpenCV 可用于开发实时的图像处理、计算机视觉以及模式识别 程序,目前在工业界以及科研领域广泛采用。 openCV的前世今生OpenCV 诞生于 Intel。Intel 最初希望提供一个计算机视觉库,使之能充分发掘 CPU 的计算能力,当然更希望以此促进 Intel 的产品的销售。OpenCV 最初的开发工作是由 Intel 在俄罗斯的团队实现。这里面有两个关键人物,一个是 Intel 性能团队(Intel’s Performance Library Team)的李信弘(Shinn Lee)先生,他是团队的经理,负责 IPP 等库,给予 OpenCV 很大的支持。另一个关键人物是 VadimPisarevsky,Vadim 在 Intel 负责 OpenCV 的项目管理、代码集成、代码优化等工作。在后期 Intel 支持渐少的时候,是 Vadim Pisarevsky 一直在维护着 OpenCV。2007 年 6 月,受本书作者之邀,李信弘和 Vadim Pisarevsky 作为嘉宾参加了在北 1京举行的“开放源代码计算机视觉库(OpenCV)研讨会” ,并做了非常有价值的报 告。在 2008 年,一家美国公司,Willow Garage2,开始大力支持 OpenCV,Vadim Pisarevsky 和 Gary Bradski 都加入了 Willow Garage。Gary Bradski 也是 OpenCV 开 发者中的元老级人物,他曾出版《Leaning OpenCV》一书,广受欢迎。Willow Garage 是一家机器人公司,致力于为个人机器人开发开放的硬件平 台和软件。现在已经开发了 PR2 机器人,并支持 ROS、OpenCV、PCL 等软件。ROS (Robot Operating System)是用于机器人的操作系统,是一个开放源代码的软件, OpenCV 作为 ROS 的视觉模块嵌入。自从获得 Willow Garage 支持后,OpenCV 的更新速度明显加快。大量的新特 性被被加入 OpenCV 中,很多算法都是最近一两年的新的科研成果。OpenCV 正日益成为算法研究和产品开发不可缺少的工具。 openCV采用的协议OpenCV 采用 BSD 协议,这是一个非常宽松的协议。简而言之,用户可以修改 OpenCV 的源代码,可以将 OpenCV 嵌入到自己的软件中,可以将包含 OpenCV 的软件销售,可以用于商业产品,也可以用于科研领域。BSD 协议并不具有“传 染性”,如果你的软件中使用了 OpenCV,你不需要公开代码。你可以对 OpenCV 做任何操作,协议对用户的唯一约束是要在软件的文档或者说明中注明使用了 OpenCV,并附上 OpenCV 的协议。在这个宽松协议下,企业可以在 OpenCV 基础之上进行产品开发,而不需要 担心版权问题(当然你要注明使用了 OpenCV,并附上 OpenCV 的协议)。科研领 域的研究者,可以使用 OpenCV 快速地实现系统原型。因此可以这样说,OpenCV 的协议保证了计算机视觉技术快速的传播,让更多的人从 OpenCV 受益。","tags":[]},{"title":"iOS Button在两层View以上的不可点击","date":"2017-02-27T07:58:29.000Z","path":"2017/02/27/ios/2017-02-27-ios-UIButton-双层视图/","text":"问题描述我在ZLYView上创建了一个普通的Button,点击事件已经添加过,但是点击事件就是不响应。 问题产生的原因1.按钮的父视图的userInteractionEnabled 交互属性设为NO了 【注】imageView的这个属性默认是为NO的,如果在ImageView上添加按钮,那么应当设置imageView.userInteractionEnabled = YES;2.按钮的位置未在父视图内。【注】如果一直找不到原因,请仔细分析是否是该原因。 解决方案根据问题对症下药","tags":[]},{"title":"iOS图片处理之位图图像原图修改","date":"2017-02-26T01:24:09.000Z","path":"2017/02/26/ios/2017-02-26-iOS-image处理/","text":"前言本文来源于网络,笔者在学习时参考该文章,特此记录。想象一张最好的生活自拍照。它是很高大尚滴并且以后会有用武之地。转发，票选将会使你获得成千上万份的关注，因为它确实很酷很帅。现在，如果你有什么办法，可以让它看起来更加的高大尚。。。 这就是图形图像处理要做到的！它可以让你的照片带上更多的特殊效果，比如修改颜色，与其它的图片进行合成等等。 在这两部分教程中，你需要先弄明白一些图形图像处理的基础知识。接着，你可以利用如下四个流行的图形图像处理方法编写一个实现“幽灵图像过滤器”的程序：1：位图图像原图修改2：使用Core Graphics库3：使用Core Image库4：使用GPUImage库的第三部分 在图形图像处理教程的第一节，主要讲解位图图像原图的修改。一但你明白基本的图形处理方法，那么其它的相关内容你也会较容易的弄明白。在教程的第二部分，主要介绍另外的三种修改图像方法。 本教程假设你拥有关于IOS系统和Object-C的基础，但在开始本教程前不需要拥有任何关于图形图像处理的知识。 开始在开始写代码之前，先理解一些关于图形图像处理的基本概念很是需要。所以，先别急，放轻松，让我们在最短的时间里去了解一下图形图像的内部工作原理。 第一件事情，看一下我们本教程中的新朋友…幽灵！ 不要怕，幽灵不是真的鬼魂。实际上，它只是一张图像。简单来说，它就是由一堆1和0组成的。这样说听上去会更好一些。 什么是图形图像一张图像就是像素点的集合，每一个像素都是一个单独，明了的颜色。图像一般情况下都存储成数组，你可以把他们相像成2维数组。 这一张是缩放版本的幽灵，被放大后： 图像中这些小的“方块”就是像素，每一像素只表示一种颜色。当成百上千万的像素集体到一起后，就构成了图形图像。 如何用字节来表示颜色表示图形的方式有许多种。在本教程中使用的是最简单的：32位RGBA模式。 如同它的名字一样，32位RGBA模式会将一个颜色值存储在32位，或者4个字节中。每一个字节存储一个部分或者一个颜色通道。这4个部分分别是： ~ R代表红色 ~ G代表绿色 ~ B代表蓝色 ~ A代表透明度 正如你所知道的，红，绿和蓝是所有颜色的基本颜色集。你几乎可以使用他们创建搭配出任何想要的颜色。 由于使用8位表示每一种颜色值，那么使用32位RGBA模式实际上可以创建出不透明的颜色的总数是256256256种，已经接近17亿种。惊叹，那是好多好多好多的颜色！ alpha通道与其它的不同。你可以把它当成透明的东西，就像UIView的alpah属性。 透明颜色意味着没有任何的颜色，除非在它的后面有另外一种颜色；它的主要功能就是要告诉图像处理这个像素的透明度是多少，于是，就会有多少颜色值穿透过它而显示出来。 你将会通过本节后面的内容更新深入的了解。 总结一下，一个图形就是像素的集体，并且每一个像素只能表示一种颜色。本节，你已经了解了32位RGBA模式。 提示：你有没有想过，位图的结构组成？一张位图就是一张2D的地图，每一块就是一个像素！像素就是地图的每一块。哈哈！ 现在你已经了解了用字节表示颜色的基础了。不过在你开始着手写代码前，还有三个以上的概念需要你了解。 颜色空间使用RGB模式表示颜色是颜色空间的一个例子。它只是众多存储颜色方法中的一种。另外一种颜色空间是灰阶空间。像它的名字一样，所有的图形都只有黑和白，只需要保存一个值来表示这种颜色。 下面这种使用RGB模式表示的颜色，人类的肉眼是很难识别的。 Red: 0 Green:104 Blue:55 你认为RGB值为[0,104,55]会产生一种什么颜色？ 认真的思考一下，你也许会说是一种蓝绿色或者绿色，但那是错的。原来，你所看到的是深绿色。 另外两种比较常见的颜色空间是HSV和YUV。 HSV，使用色调，饱和度和亮度来直观的存储颜色值。你可以把这三个部分这样来看： ·色调就是颜色·饱和度就是这个颜色有多么的饱满·值就是颜色的亮度有多亮 在这种颜色空间中，如果你发现自己并不知道HSV的值，那么通过它的三个值，可以很容易的相像出大概是什么颜色。 RGB和HSV颜色空间的区别是很容易理解的，请看下面的图像： YUV是另外一种常见的颜色空间，电视机使用的就是这种方式。 最开始的时候，电视机只有灰阶空间一种颜色通道。后来，当彩色电影出现后，就有了2种通道。当然，如果你想在本教程中使用YUV，那么你需要去研究更多关于YUV和其它颜色空间的相关知识。 NOTE:同样的颜色空间，你也可以使用不同的方法表示颜色。比如16位RGB模式，可以使用5个字节存储R，6个字节存储G，5个字节存储B。 为什么用6个字节存储绿色，5个字节存储蓝色？这是一个有意思的问题，答案就是因为眼球。人类的眼球对绿色比较敏感，所以人类的眼球更空间分辨出绿色的颜色值变化。 坐标系统既然一个图形是由像素构成的平面地图，那么图像的原点需要说明一下。通常原点在图像的左上角，Y轴向下；或者原点在图像的左下，Y轴向上。 没有固定的坐标系统，苹果在不同的地方可能会使用不同的坐标系。 目前，UIImage和UIView使用的是左上原点坐标，Core Image和Core Graphics使用的是左下原点坐标。这个概念很重要，当你遇到图像绘制倒立问题的时候你就知道了。 图形压缩这是在你开始编写代码前的最后一个需要了解的概念了！原图的每一个像素都被存储在各自的内存中。 如果你使用一张8像素的图形做运算，它将会消耗810^6像素4比特/像素=32兆字节内存。关注一下数据！ 这就是为什么会出现jpeg,png和其它图形格式的原因。这些都是图形压缩格式。 当GPU在绘制图像的时候，会使用大量内存把图像的原始尺寸进行解压缩。如果你的程序占用了过多的内存，那么操作系统会将进程杀死（程序崩溃）。所以请确定你的程序使用较大的图像进行过测试。 我需要一些行动… 关注一下像素现在，你已经基础了解了图形图像的内部工作原理，已经可以开始编写代码喽。今天你将会开发一款改变自己照片的程序，叫做SpookCam,该程序会把一张幽灵的图像放到你的照片中！ 下载工具包在xcode中打开该项目，编译并运行。在你的手机上会看到如下的图像： 在控制台，你会看到如下的输出： 当前的程序可以加载这张幽灵的图像，并得到图像的所有像素值，打印出每个像素的亮度值到日志中。 亮度值是神马？它就是红色，绿色和蓝色通过的平均值。 注意输出日志外围的亮度值都为0，这意味着他们代码的是黑色。然而，他们的透明度的值是0，所以它们是透明不可见的。为了证明这一点，试着将imageView的背景颜色设置成红色，然后再次编译并运行。 现在快速的浏览一下代码。ViewController.m 中使用 UIImagePickerController 来在相册中取得图像或者使用机机获得图像。 当它选定一张图像后，调用-setupWithImage:在这行中，输出了每一像素的亮度值到日志中。定位到ViewController.m中的logPixelsOfImage，查看方法中的开始部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227// 1. CGImageRef inputCGImage = [image CGImage]; NSUInteger width = CGImageGetWidth(inputCGImage); NSUInteger height = CGImageGetHeight(inputCGImage); // 2. NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel *width; NSUInteger bitsPerComponent = 8; UInt32 * pixels; pixels = (UInt32 *) calloc(height * width, sizeof(UInt32)); // 3. CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(pixels, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); // 4. CGContextDrawImage(context, CGRectMake(0,0, width, height), inputCGImage); // 5. Cleanup CGColorSpaceRelease(colorSpace); CGContextRelease(context); ``` 现在，让我们分段的来看一下： 1：第一部分：把UIImage对象转换为需要被核心图形库调用的CGImage对象。同时，得到图形的宽度和高度。 2：第二部分：由于你使用的是32位RGB颜色空间模式，你需要定义一些参数bytesPerPixel（每像素大小）和bitsPerComponent（每个颜色通道大小），然后计算图像bytesPerRow（每行有大）。最后，使用一个数组来存储像素的值。 3：第三部分：创建一个RGB模式的颜色空间CGColorSpace和一个容器CGBitmapContext,将像素指针参数传递到容器中缓存进行存储。在后面的章节中将会进一步研究核图形库。 4：第四部分：把缓存中的图形绘制到显示器上。像素的填充格式是由你在创建context的时候进行指定的。 5：第五部分：清除colorSpace和context. NOTE:当你绘制图像的时候，设备的GPU会进行解码并将它显示在屏幕。为了访问本地数据，你需要一份像素的复制，就像刚才做的那样。 此时此刻，pixels存储着图像的所有像素信息。下面的几行代码会对pixels进行遍历，并打印：```objc// 1. #define Mask8(x) ( (x) &amp; 0xFF ) #define R(x) ( Mask8(x) ) #define G(x) ( Mask8(x &gt;&gt; 8 ) ) #define B(x) ( Mask8(x &gt;&gt; 16) ) NSLog(@\"Brightness of image:\"); // 2. UInt32 * currentPixel = pixels; for (NSUInteger j = 0; j &lt; height; j++) &#123; for (NSUInteger i = 0; i &lt; width; i++) &#123; // 3. UInt32 color = *currentPixel; printf(\"%3.0f \", (R(color)+G(color)+B(color))/3.0); // 4. currentPixel++; &#125; printf(\"\\n\"); &#125; ``` 代码解释： 1：定义了一些简单处理32位像素的宏。为了得到红色通道的值，你需要得到前8位。为了得到其它的颜色通道值，你需要进行位移并取截取。 2：定义一个指向第一个像素的指针，并使用2个for循环来遍历像素。其实也可以使用一个for循环从0遍历到width*height，但是这样写更容易理解图形是二维的。 3：得到当前像素的值赋值给currentPixel并把它的亮度值打印出来。 4：增加currentPixel的值，使它指向下一个像素。如果你对指针的运算比较生疏，记住这个：currentPixel是一个指向UInt32的变量，当你把它加1后，它就会向前移动4字节（32位），然后指向了下一个像素的值。 提示：还有一种非正统的方法就是把currentPiexl声明为一个指向8字节的类型的指针，比如char。这种方法，你每增加1，你将会移动图形的下一个颜色通道。与它进行位移运算，你会得到颜色通道的8位数值。 此时此刻，这个程序只是打印出了原图的像素信息，但并没有进行任何修改！下面将会教你如何进行修改。 SpookCame-原图修改四种研究方法都会在本小节进行，你将会花费更多的时间在本节，因为它包括了图形图像处理的第一原则。掌握了这个方法你会明白其它库所做的。 在本方法中，你会遍历每一个像素，就像之前做的那个，但这次，将会对每个像素进行新的赋值。 这种方法的优点是容易实现和理解；缺点就是扫描大的图形和效果的时候会更复杂，不精简。 正如你在程序开始看到的，ImageProcessor类已经存在。将它应用到ViewController中，替换-setupWithImage，代码如下：```objc - (void)setupWithImage:(UIImage*)image &#123; UIImage * fixedImage = [image imageWithFixedOrientation]; self.workingImage = fixedImage; // Commence with processing! [ImageProcessor sharedProcessor].delegate = self; [[ImageProcessor sharedProcessor] processImage:fixedImage]; &#125; ``` 注释掉 -viewDidLoad 中下面的代码：// [self setupWithImage:[UIImage imageNamed:@\"ghost_tiny.png\"]]; 现在，打开 ImageProcessor.m。如你所见，ImageProcessor 是单例模式，调用 -processUsingPixels 来加载图像，然后通过 ImageProcessorDelegate 返回输出。 -processsUsingPixels：是之前你所看到获得图形像素代码的一种复制品，如同inputImage。注意两个额外的宏A(x)和RGBAMake(r,g,b,a)的定义，用来方便处理。 编译，并运行。从相册（拍照）选择一张图片，它将会出现在屏幕上： ![](http://cdn.cocimg.com/cms/uploads/allimg/140812/4196_140812105248_1.png)照片中的人看上去在放松，是时候把幽灵放进去了！ 在processUsingPixels的返回语句前，添加如下代码，创建一个幽灵的CGImageRef对象。UIImage * ghostImage = [UIImage imageNamed:@\"ghost\"];CGImageRef ghostCGImage = [ghostImage CGImage]; 现在，做一些数学运算来确定幽灵图像放在原图的什么位置。```objc CGFloat ghostImageAspectRatio = ghostImage.size.width / ghostImage.size.height; NSInteger targetGhostWidth = inputWidth * 0.25; CGSize ghostSize = CGSizeMake(targetGhostWidth, targetGhostWidth / ghostImageAspectRatio); CGPoint ghostOrigin = CGPointMake(inputWidth * 0.5, inputHeight * 0.2); ``` 以上代码会把幽灵的图像宽度缩小25%，并把它的原点设定在点ghostOrigin。 下一步是创建一张幽灵图像的缓存图， ```objcNSUInteger ghostBytesPerRow = bytesPerPixel * ghostSize.width; UInt32 * ghostPixels = (UInt32 *)calloc(ghostSize.width * ghostSize.height, sizeof(UInt32)); CGContextRef ghostContext = CGBitmapContextCreate(ghostPixels, ghostSize.width, ghostSize.height, bit sPerComponent, ghostBytesPerRow, colorSpace, kCG ImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); CGContextDrawImage(ghostContext, CGRectMake(0, 0, ghostSize.width, ghostSize.height),ghostCGImage); ``` 上面的代码和你从inputImage中获得像素信息一样。不同的地方是，图像会被缩小尺寸，变得更小了。 现在已经到了把幽灵图像合并到你的照片中的最佳时间了。 合并：像前面提到的，每一个颜色都有一个透明通道来标识透明度。并且，你每创建一张图像，每一个像素都会有一个颜色值。 所以，如果遇到有透明度和半透明的颜色值该如何处理呢？ 答案是，对透明度进行混合。在最顶层的颜色会使用一个公式与它后面的颜色进行混合。公式如下： NewColor = TopColor * TopColor.Alpha + BottomColor * (1 - TopColor.Alpha) 这是一个标准的线性差值方程。 ·当顶层透明度为1时，新的颜色值等于顶层颜色值。·当顶层透明度为0时，新的颜色值于底层颜色值。·最后，当顶层的透明度值是0到1之前的时候，新的颜色值会混合借于顶层和底层颜色值之间。 还可以用 premultiplied alpha的方法。 当处理成千上万像素的时候，他的性能会得以发挥。 好，回到幽灵图。 如同其它位图运算一样，你需要一些循环来遍历每一个像素。但是，你只需要遍历那些你需要修改的像素。 把下面的代码添加到processUsingPixels的下面，还是放在返回语句的前面：```objc NSUInteger offsetPixelCountForInput = ghostOrigin.y * inputWidth + ghostOrigin.x; for (NSUInteger j = 0; j &lt; ghostSize.height; j++) &#123; for (NSUInteger i = 0; i &lt; ghostSize.width; i++) &#123; UInt32 * inputPixel = inputPixels + j * inputWidth + i + offsetPixelCountForInput; UInt32 inputColor = *inputPixel; UInt32 * ghostPixel = ghostPixels + j * (int)ghostSize.width + i; UInt32 ghostColor = *ghostPixel; // Do some processing here &#125; &#125; ``` 通过对幽灵图像像素数的循环和offsetPixelCountForInput获得输入的图像。记住，虽然你使用的是2维数据存储图像，但在内存他它实际上是一维的。 下一步，添加下面的代码到注释语句 Do some processing here的下面来进行混合：```objc // Blend the ghost with 50% alpha CGFloat ghostAlpha = 0.5f * (A(ghostColor) / 255.0); UInt32 newR = R(inputColor) * (1 - ghostAlpha) + R(ghostColor) * ghostAlpha; UInt32 newG = G(inputColor) * (1 - ghostAlpha) + G(ghostColor) * ghostAlpha; UInt32 newB = B(inputColor) * (1 - ghostAlpha) + B(ghostColor) * ghostAlpha; // Clamp, not really useful here :p newR = MAX(0,MIN(255, newR)); newG = MAX(0,MIN(255, newG)); newB = MAX(0,MIN(255, newB)); *inputPixel = RGBAMake(newR, newG, newB, A(inputColor)); ``` 这部分有2点需要说明： 1：你将幽灵图像的每一个像素的透明通道都乘以了0.5，使它成为半透明状态。然后将它混合到图像中像之前讨论的那样。 2：clamping部分将每个颜色的值范围进行限定到0到255之间，虽然一般情况下值不会越界。但是，大多数情况下需要进行这种限定防止发生意外的错误输出。 最后一步，添加下面的代码到 processUsingPixels 的下面，替换之前的返回语句：// Create a new UIImage CGImageRef newCGImage = CGBitmapContextCreateImage(context); UIImage * processedImage = [UIImage imageWithCGImage:newCGImage]; return processedImage; 上面的代码创建了一张新的UIImage并返回它。暂时忽视掉内存泄露问题。编译并运行，你将会看到漂浮的幽灵图像： ![](http://cdn.cocimg.com/cms/uploads/allimg/140812/4196_140812105433_1.png) 好了，完成了，这个程序简直就像个病毒！ 黑白颜色最后一种效果。尝试自己实现黑白颜色效果。为了做到这点，你需要把每一个像素的红色，绿色，蓝色通道的值设定成三个通道原始颜色值的平均值，就像开始的时候输出幽灵图像所有像素亮度值那样。 在注释语句// create a new UIImage前添加上一步的代码 。 找到了吗？```objc // Convert the image to black and white for (NSUInteger j = 0; j &lt; inputHeight; j++) &#123; for (NSUInteger i = 0; i &lt; inputWidth; i++) &#123; UInt32 * currentPixel = inputPixels + (j * inputWidth) + i; UInt32 color = *currentPixel; // Average of RGB = greyscale UInt32 averageColor = (R(color) + G(color) + B(color)) / 3.0; *currentPixel = RGBAMake(averageColor, averageColor, averageColor, A(color)); &#125; &#125; ``` 最后的一步就是清除内存。ARC不能代替你对CGImageRefs和CGContexts进行管理。添加如下代码到返回语句之前。```objcCGColorSpaceRelease(colorSpace); CGContextRelease(context); CGContextRelease(ghostContext); free(inputPixels); free(ghostPixels); 编译并运行，不要被结果吓到： 下面需要做的： 恭喜！你已经完成了自己的第一个图像处理程序。你可以在这里下载该工程的源代码。 还不错吧？你可以尝试修改一下循环中的代码创建自己想要的效果，尝试下实现下面的效果： ·尝试调换图像的红色和蓝色通道值·提高图像的亮度10%·作为进一步的挑战，尝试只使用基于像素的方法缩放幽灵的图像，下面是步骤： 1：使用幽灵图像的尺寸大小创建一个新的CGContext。2：在原图像中得到你想要的并赋值到新的缓存图像中。3：附加，尝试在像素之前进行计算并插入相似值像素点。如果你可以在四个像素间进行插入，你自己就已经实现 Bilinear scaling（双线性插值法）了！太牛了！ 如果你已经完成了第一个项目，想必你对图形图像的处理已经有了基本的概念。现在你可以尝试使用更快更好的方法来实现相同的效果。 在下一章节中，你将会使用另外三个新的方法替换-processUsingPixels：完成相同的任务。一定要看丫！ 同时，如果你对该章节有任何疑问和不解，请留言给我！","tags":[]},{"title":"React Native封装原生UI组件栏","date":"2017-02-21T10:40:12.000Z","path":"2017/02/21/React-Native/2017-02-21/","text":"React Native平台的开发其实本身也是可以让你写纯原生代码并且还可以让你访问原生平台的功能。这是一个比较高级的功能不过官方还是不推荐你在平时开发中使用这样的开发形式。但是如果你具备这样的开发能力，也是还是不错的。特别当在React Native暂时未提供部分原生功能或者模块，那么你可以使用这样的方法进行封装扩展。今天我们就来看一下原生组件的封装扩展方法。 问题来源:项目中要在注册页面显示一张验证码图片,当用户点击验证码图片时,验证码改变。 问题分析:由于RN显示图片主要有两种请查看React-Native正确加载图片的姿势,而且加载的都是固定资源的图片,并不能实现点击图片换一次验证码的需求 一、对原生视图进一步封装举个栗子,我们要在React-Native上调用ZLYCustomView显示,那我们就得对ZLYCustomView进行一次封装才能被RN调用。原生视图如下12345678910@interface ZLYCustomView:UIView@property (nonatomic, assign) id&lt;VerifyPicCodeViewDelegate&gt;delegate;@property (nonatomic, copy) RCTDirectEventBlock onGetCookie;@property (nonatomic, strong) UIImageView * imageView;@property (nonatomic, strong) NSString * source;@end@implementation ZLYCustomView@end 二、创建RCTViewManager的子类来管理原生视图原生视图都需要被一个RCTViewManager的子类来创建和管理。这些管理器在功能上有些类似“视图控制器”，但它们本质上都是单例 - React Native只会为每个管理器创建一个实例。它们创建原生的视图并提供给RCTUIManager，RCTUIManager则会反过来委托它们在需要的时候去设置和更新视图的属性。RCTViewManager还会代理视图的所有委托，并给JavaScript发回对应的事件。 提供原生视图步骤如下： 首先创建一个子类 —— 命名规范为“视图名称+Manager”. 视图名称可以加上自己的前缀，这里最好避免使用RCT前缀，除非你想给官方pull request添加RCT_EXPORT_MODULE()标记宏 —— 让模块接口暴露给JavaScript实现-(UIView *)view方法 —— 创建并返回组件视图封装属性及传递事件下面先贴出完整的代码，然后会对属性和事件进行进一步的解说。 ZLYCustomViewManager.h12345 #import \"ZLYCustomViewManager.h #import \"RCTViewManager.h\"@interface ZLYCustomViewManager : RCTViewManager@end ZLYCustomViewManager.m #import \"ZLYCustomViewManager.h #import \"RCTBridgeModule.h\" #import \"RCTBridge.h\" #import \"RCTEventDispatcher.h\" @interface ZLYCustomViewManager : RCTViewManager // 标记宏（必要） RCT_EXPORT_MODULE() // 事件的导出，onClickBanner对应view中扩展的属性 RCT_EXPORT_VIEW_PROPERTY(onClickBanner, RCTDirectEventBlock) // 通过宏RCT_EXPORT_VIEW_PROPERTY完成属性的映射和导出 RCT_EXPORT_VIEW_PROPERTY(autoScrollTimeInterval, CGFloat); RCT_EXPORT_VIEW_PROPERTY(imageURLStringsGroup, NSArray); RCT_EXPORT_VIEW_PROPERTY(autoScroll, BOOL); - (UIView *)view { // 实际组件的具体大小位置由js控制 ZLYCustomView *customView = [ZLYCustomView alloc]init]; return customView; } @end","tags":[{"name":"React-Naticve","slug":"React-Naticve","permalink":"https://www.devzou.com/tags/React-Naticve/"}]},{"title":"iOS textfield光标位置","date":"2017-02-09T07:58:12.000Z","path":"2017/02/09/ios/2017-02-09-textfield光标位置/","text":"123456 UITextPosition* beginning = self.beginningOfDocument; UITextRange* selectedRange = self.selectedTextRange; UITextPosition* selectionStart = selectedRange.start; UITextPosition* selectionEnd = selectedRange.end; const NSInteger location = [self offsetFromPosition:beginning toPosition:selectionStart]; //光标所在的位置 const NSInteger length = [self offsetFromPosition:selectionStart toPosition:selectionEnd]; //选中文字的长度","tags":[]},{"title":"iOS UILabel显示html标签","date":"2017-02-07T06:50:21.000Z","path":"2017/02/07/ios/2017-02-07-UIlabel-html/","text":"iOS7以后系统提供了显示html标签的方法1UIKIT_EXTERN NSString *const NSHTMLTextDocumentType NS_AVAILABLE_IOS(7_0); 1234567NSString *str = @&quot;&lt;font color=\\&quot;#6c6c6c\\&quot;&gt;满20减5 满40减15，还剩&lt;font color=\\&quot;#ff9147\\&quot;&gt;113天&quot;;UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(30, 50, 300, 50)];NSAttributedString *attrStr = [[NSAttributedString alloc] initWithData:[str dataUsingEncoding:NSUnicodeStringEncoding] options:@&#123;NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType&#125; documentAttributes:nil error:nil];label.attributedText = attrStr;//如果想要改变文字的字体,请在设置attributedText之后设置label.font = [UIFont systemFontOfSize:20];[self.view addSubview:label];","tags":[]},{"title":"static、const、extern简介","date":"2017-02-06T13:54:08.000Z","path":"2017/02/06/ios/2017-02-06-static-const-extern/","text":"const1.const作用:仅仅是用来修饰右边的变量(只能修饰变量:基本变量、指针变量、对象变量)2.const修饰的变量表示只读 const与宏的区别1.编译时刻不同,宏:预编译const:编译时刻 2.宏不会做编译检查错误,const会做编译检查错误 3.宏可以定义代码 4.过多的使用宏会导致编译时间过长const:当有字符串常量的时候,苹果推荐我们使用const","tags":[]},{"title":"iOS设置textfield.placeholder字体及颜色","date":"2017-02-06T10:32:14.000Z","path":"2017/02/06/ios/2017-02-06-textfield-placeholder/","text":"123textField.placeholder = @&quot;请输入手机号码&quot;;[textField setValue:[UIColor blue] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];[textField setValue:[UIFont systemFontOfSize:14] forKeyPath:@&quot;_placeholderLabel.font&quot;];","tags":[]},{"title":"使用hexo+gitpages创建自己的博客","date":"2017-01-26T10:40:12.000Z","path":"2017/01/26/hexo/使用hexo与gitpages创建自己的博客/","text":"准备工作1.安装git2.安装node.js3.申请github账号 安装hexo1.安装hexo1npm install -g hexo-cli 2.安装hexo1npm install hexo --save 【注】warning可以忽略3.查看hexo安装是否成功1hexo -v 如下图所示,则表示安装成功 本地运行hexo1.初始化hexo1hexo init 如下图则表示初始化成功2.安装生成器1npm install 3.本地运行hexo1hexo s -g 如图则表示运行成功 一键部署到github1.打开博客目录中的_config.yml文件修改文件中的deploy下内容 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #elfwalk改为你的github用户名 repository: https://github.com/lianyu125/lianyu125.github.io.git branch: master 2.安装hexo git 插件1npm install hexo-deployer-git --save 3.生成静态页面1hexo generate 4.发布到github1hexo deploy 这样我们的博客就搭建起来了","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.devzou.com/tags/hexo/"}]},{"title":"hexo博客next主题下添加打赏功能","date":"2017-01-26T10:40:12.000Z","path":"2017/01/26/hexo/2017-01-29/","text":"打赏功能next主题下已经包含了打赏功能,只需要在主题目录中的_config.yml文件中添加 #支付宝付款二维码alipay: http://okjl482qy.bkt.clouddn.com/zhifubao.jpg #微信付款二维码wechatpay: http://okjl482qy.bkt.clouddn.com/weixin.jpg即可。【注】支付宝、微信付款二维码需要存放到云服务器上生成外部链接,我是存储在七牛云存储上的。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.devzou.com/tags/hexo/"}]},{"title":"hexo博客在导航条中添加分类和标签栏","date":"2017-01-26T10:40:12.000Z","path":"2017/01/26/hexo/2017-01-30-add-categories-tags/","text":"在导航栏上添加分类,标签等类目添加导航栏方式：直接打开hexo安装根目录下的themes文件夹中，我用的是next主题（根据你主题而定），然后打开next文件夹，更改_config.yml文件，用文本方式打开，找到如下位置，默认情况下有些事注释掉的，你可以试着打开，我选择全部不注释，导航栏就是上图所示。 添加导航栏相应页面导航栏我们刚刚添加成功了，这个时候如果部署 提交，你点击的话，可能是给你报错了，404 提示你找不到页面，这是因为我们只是创建了这个链接，而页面并没有创建，默认情况下home archives 页面都是不用自己创建的，所以分类、标签、关于、404都是要我们自己创建的。在hexo安装根目录下执行如下命令, 创建分类页面1hexo new page &quot;categories&quot; 执行完，在hexo根目录下的source文件夹中会多出一个categories文件夹，里面默认有一个index.md的文件，这就是我们创建的导航栏的分类页面 。 创建标签页面1hexo new page &quot;tags&quot; 执行完，在hexo根目录下的source文件夹中会多出一个tags文件夹，里面默认有一个index.md的文件，这就是我们创建的导航栏的标签页面 。 创建关于页面1hexo new page &quot;about&quot; 执行完，在hexo根目录下的source文件夹中会多出一个about文件夹，里面默认有一个index.md的文件，这就是我们创建的导航栏的标签页面 。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.devzou.com/tags/hexo/"}]},{"title":"hexo博客中插入图片","date":"2017-01-26T10:40:12.000Z","path":"2017/01/26/hexo/2017-01-29-hexo-insertpicture/","text":"1.使用本地路径在/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.devzou.com/tags/hexo/"}]},{"title":"ios内存管理之自动引用计数","date":"2017-01-07T08:25:47.000Z","path":"2017/01/07/ios/2017-01-07/","text":"##自动引用计数自动引用计数是指内存管理对引用采取自动计数的技术。以下内容摘自苹果官方文档大体意思就是","tags":[{"name":"KVO","slug":"KVO","permalink":"https://www.devzou.com/tags/KVO/"}]},{"title":"iOS开发之KVO深入理解","date":"2016-12-16T14:08:36.000Z","path":"2016/12/16/ios/2016-12-16-iOS开发之KVO/","text":"1.初识KVOKVO,全称为Key-Value Observing,是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应。KVO的优点:当有属性改变时，KVO会提供自动的消息通知。 2.KVO使用场景当一个对象(objectOne)需要监控另一个对象(objectTwo)的属性发生变化而作出相应的响应时需要要KVO即objectOne 必须发送一个 addObserver:forKeyPath:options:context:的消息,注册成为objectTwo某个属性的观察着。 3.KVO深入理解首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。 在初始化方法中加入：1[_tableView addObserver:self forKeyPath:@\"contentOffset\" options:NSKeyValueObservingOptionNew context:nil]; 在dealloc中移除KVO监听：1[_tableView removeObserver:self forKeyPath:@\"contentOffset\" context:nil]; 添加默认的响应回调方法：12345- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; [self doSomethingWhenContentOffsetChanges];&#125; 好了，KVO实现就到此完美结束了，拜拜。。。开个玩笑，肯定没这么简单的，这样的代码太粗糙了，当你在controller中添加多个KVO时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。判断如下：1234567- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == _tableView &amp;&amp; [keyPath isEqualToString:@\"contentOffset\"]) &#123; [self doSomethingWhenContentOffsetChanges]; &#125; &#125; 你以为这样就结束了吗？答案是否定的！我们假设当前类(在例子中为UITableViewController)还有父类，并且父类也有自己绑定了一些其他KVO呢？我们看到，上述回调函数体中只有一个判断，如果这个if不成立，这次KVO事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个KVO，那很有可能是在他的superClass，或者super-superClass…中，上述处理砍断了这个链。合理的处理方式应该是这样的：123456789- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == _tableView &amp;&amp; [keyPath isEqualToString:@\"contentOffset\"]) &#123; [self doSomethingWhenContentOffsetChanges]; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; 这样就结束了吗？答案仍旧是否定的。潜在的问题有可能出现在dealloc中对KVO的注销上。KVO的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个keypath进行两次removeObserver时会导致程序crash，这种情况常常出现在父类有一个kvo，父类在dealloc中remove了一次，子类又remove了一次的情况下。不要以为这种情况很少出现！当你封装framework开源给别人用或者多人协作开发时是有可能出现的，而且这种crash很难发现。不知道你发现没，目前的代码中context字段都是nil，那能否利用该字段来标识出到底kvo是superClass注册的，还是self注册的？ 回答是可以的。我们可以分别在父类以及本类中定义各自的context字符串，比如在本类中定义context为@”ThisIsMyKVOContextNotSuper”;然后在dealloc中remove observer时指定移除的自身添加的observer。这样iOS就能知道移除的是自己的kvo，而不是父类中的kvo，避免二次remove造成crash。","tags":[{"name":"KVO","slug":"KVO","permalink":"https://www.devzou.com/tags/KVO/"}]},{"title":"PHP操作Session的原理及提升安全性时的一个问题","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2012-09-19-php-session-security/","text":"Session和Cookie基本介绍相同点：两者都是保存用户的临时信息，以方便用户和网站之间的交互 不同点：Session保存在服务器端，只有服务器端才可查看和修改。服务器端通过客户端在cookie中携带的session_id来获得保存在服务器端的用户数据。Cookie保存在客户端，服务端和客户端都可以对其进行修改。 Session的工作原理首先测试如下一段代码 &lt;?php session_start();//开启session echo ‘Session id:’.session_id().‘&lt;br&gt;’;//显示此次交互的session_id ?&gt; 页面显示结果为 Session id:ihrk96384qjvvsqmce0dlkla04 即使不停刷新页面，依然不变，说明服务器端是可以识别出客户端，那么它是如何做到的呢？ 我们可以查看一下他们的第一次HTTP交互(先清空一次cookie和缓存再测试) Request Header: GET /phptest/test2.php HTTP/1.1 Host: localhost Cookie: Response Header: Set-Cookie: PHPSESSID=sastrf9cikeij6meoe3055brq3; path=/ 为了说明问题，我只取要用到的信息，从请求头可以看到，这个时候客户端没有给服务端传Cookie内容。而返回的头信息中，服务端指明了set-cookie要设置一个PHPSESSID的内容，保存在”/”目录下。 来看第二次交互： Request Header: GET /phptest/test2.php HTTP/1.1 Host: localhost Cookie:PHPSESSID=sastrf9cikeij6meoe3055brq3 Response Header: Set-Cookie: 这一次结果显示服务器端没有再要求写Cookie，而客户端主动上传了上次获得的PHPSESSID值，也就是这种机制，使服务端”认识”了客户端。只要服务端没有要求再次写session，则以后的交互将一直以此session_id作为客户端的身份标志。 服务器端修改Session_id当然session_id不是永久不变的，当我们清空过一次Cookie以后就发现以前登录了的网站都得重新登陆。再次登陆的时候，我们又会以新的session_id来进行重新确认身份。（注：还有别的方式可以传递session_id值，例如query string等）。 其实从上一个例子中我们就可以看到，服务器端修改session_id其实是通过重写一次cookie来实现的，这次重写发生在一次请求完成以后，即传回的HTTP头中说明的。 为了防止Session劫持，我们可能需要通过每次请求都更改session_id来确保用户是本人登录的。在php中，可以使用以下方式： &lt;?php session_start();//开启session echo ‘Old Session id:’.session_id().‘&lt;br&gt;’; session_regenerate_id(true);//重置session_id，并使原session无效 echo ‘New Session id:’.session_id().‘&lt;br&gt;’; ?&gt; 页面显示结果为： Old Session id:mqk5sfudpu9ikgp49vc825ggo6 New Session id:mrck9n85v190reupsni4ob6lo5 可见session_id在使用了session_regenerate_id()以后发生了变化，变化写入方式同第二点介绍的，服务器端在返回的HTTP头中加入Set-Cookie。 session_regenerate_id()的一个问题在实际操作中，session_id的保存位置可以通过 session_set_cookie_params() 来修改，如下： &lt;?php session_set_cookie_params(0,‘/’,‘testdomain’); session_start();//开启session echo ‘Old Session id:’.session_id().‘&lt;br&gt;’; session_regenerate_id(true);//重置session_id，并使原session无效 echo ‘New Session id:’.session_id().‘&lt;br&gt;’; ?&gt; 在这种方式下，session_id的默认domain被修改，但是session_regenerate_id()是不识别的。这不知道算不算php的一个bug，为了解决这个问题，我们必须使用手动方式重置session保存，修改代码如下： &lt;?php session_set_cookie_params(0,‘/’,‘testdomain’); session_start();//开启session echo ‘Old Session id:’.session_id().‘&lt;br&gt;’; session_regenerate_id(true);//重置session_id，并使原session无效 echo ‘New Session id:’.session_id().‘&lt;br&gt;’; setcookie(session_name(),session_id(),0,‘/’,‘testdomain’);//手动更新session_id ?&gt; 这样一来就可以每次交互更新session_id了……虽然有些复杂，但是经测试可行。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"JavaScript变量作用域","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2013-02-24-javascript-variable-domain/","text":"转载自:http://www.cnblogs.com/rainman/archive/2009/04/28/1445687.html,略改 JavaScript的变量作用域是基于其特有的作用域链 JavaScript没有块级作用域 函数中声明的变量在整个函数中都有定义 1.JavaScript的作用域链var rain = 1; function rainman(){ var man = 2; funciton inner(){ var innerVar = 4; alert(rain); } inner(); } rainman(); 在alert(rain);这句代码，JavaScript首先在inner函数中检查，否则则在rainman中查找，这段代码在rainmain()中没有定义，则最终查找的是全局变量中的rain。 作用域链：JavaScript需要查找一个变量时，首先查找作用域链第一个对象，如果第一个对象没有定义，则顺序向后查找。 2.函数体内部，局部变量的优先级比同名的全局变量高var rain = 1; function check(){ var rain = 100; alert(rain); } check(); //100 alert(rain); //1 3.JavaScript没有快级作用域function rainmain(){ //rainman 函数体内存在三个局部变量 i j k var i = 0; if(1){ var j = 0; for(var k=0;k&lt;3;k++) alert(k); //0,1,2 alert(k); // 3 } alert(j); //0 } i,j,k的作用域是相同的，他们在rainmain中是全局的 4.函数中声明的变量在整个函数中都有定义function rain(){ var x = 1; function man(){ x = 100; } man(); //调用man alert(x); //这里会弹出100 } rain(); //调用rain 上面代码说明，变量x在整个rain体内都可以使用，并可以重新幅值。但是会有以下情况产生: var x = 1; function rain(){ alert(x); //undefined var x = &apos;3&apos;; alert(x); //3 } 是由于rain定义了x，它会隐藏同名全局变量x。由于alert时还未定义，所以undefined 5.未使用var关键字定义的变量都是全局变量function rain(){ x = 100; } rain(); alert(x); //100 6.全局变量都是window对象的属性var x = 100; alert(window.x); //100","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.devzou.com/tags/JavaScript/"}]},{"title":"PHP可变变量","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2012-09-27-php-variable-variables/","text":"什么叫可变变量不知道大家在使用php的时候是否遇到这样一种情况，即想将一个变量的内容作为另一个变量的名称。在php中，这个需求可以通过可变变量（Variable variables）来实现。 可变变量的一般形式为： $var=“foo”; $$var=1; 在这里， 其实等同于向将var展开，然后再以它的值作为真正的变量名 $foo=1; 可变变量妙用类的动态实例化$var=“foo”; $a=new $foo; 循环定义变量for($i=0;$i&lt;10;$i++){ ${aa.$i}=“a”; } 动态调用方法class test_class{ var $func=‘display_UK’; function display_UK(){ echo “Hello”; } function display_FR(){ echo “Bonjour”; } function display(){ $this-&gt;{$this-&gt;func}(); } }","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"VNC和远程桌面的区别","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2013-03-21-vnc-vs-rdp/","text":"我们可以通过VNC(Virtual Network Computing)和远程桌面来连接到远程的计算机上，但是两者是有一定的区别的。 VNCVNC使用的是RFB协议来做屏幕分享和远程操作的软件，由著名的AT&amp;T欧洲研究实验室开发。使用时需要客户端软件和服务器软件配合使用。 远程桌面远程桌面使用RDP(Remote Desktop Protocol)远程桌面协议，大部分Windows都默认支持此协议，可以远程接入操作桌面。 RFB和RDP区别RFB是在服务器端将窗口在显存中画好之后将图像传给客户端，客户端只充当一个图像解码显示的角色； RDP则将画图的工作交给了客户端，服务器需要了解客户端显示能力的具体情况，以便作出相应调整。 RFB主要传图像，RDP主要传指令。就一般应用而言，RFB数据量太大，RDP对客户端要求较高，因此RFB适用于瘦客户端，RDP适用于低速网络。","tags":[{"name":"Virtualization","slug":"Virtualization","permalink":"https://www.devzou.com/tags/Virtualization/"}]},{"title":"JS中防止浏览器屏蔽window.open","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2012-09-27-open-widown-in-javascript/","text":"有的时候我们需要一些弹出窗来作为临时信息显示，在js代码中直接使用 window.open(url,“_blank”,option); 即可实现跳转，而且还可以传递一些参数。 但是有个问题是，很多浏览器不支持代码触发上述代码，这个问题在平常使用中显得很不方便，尤其是我们经常用ajax返回值来触发一个新页面。 为了防止被屏蔽，可以有两种方式解决。1、在用户点击事件中增加监听程序 &lt;button onclick=“test()”&gt;点击&lt;/button&gt; &lt;script type=“text/javascript”&gt; var is_finished=false; function test(){ $.get(“/”,function(){ is_finished=true; }); test2(); } function test2(){ if(is_finished){ window.open(“http://www.baidu.com”,“_blank”); }else{ setTimeout(test2,1000); } } &lt;/script&gt; 2、在点击后先打开空白页，之后再修改地址 &lt;button onclick=“test()”&gt;点击&lt;/button&gt; &lt;script type=“text/javascript”&gt; function test(){ var frame=window.open(“about:blank”,“_blank”); $.get(“/”,function(){ frame.location=“http://www.baidu.com”; }); } &lt;/script&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.devzou.com/tags/JavaScript/"}]},{"title":"PHP命名空间及自动加载","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2014-01-16-php-namespace-and-autoload/","text":"命名空间什么是命名空间呢？ 命名空间（英语：Namespace）表示标识符（identifier）的可见范围。一个标识符可在多个命名空间中定义，它在不同命名空间中的含义是互不相干的。这样，在一个新的命名空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其它命名空间中。 简单说来命名空间是为了解决不同库在同一个环境下使用时出现的命名冲突。例如我自己有一个函数名叫A，但是系统已经有一个A函数了，那就会出现冲突。 PHP中的命名空间PHP从5.3版本开始引入了命名空间，之后许多现有PHP类库以及框架都开始支持它。那么PHP的命名空间怎么用呢？ 定义命名空间下面是一个定义命名空间的例子 &lt;?php //file a.php namespace A; const test = &apos;Atest&apos;; function test() { return __FUNCTION__; } class Test{ public function __construct(){ return __METHOD__; } } ?&gt; 上面例子中就是一个典型的命名空间定义方法，只有const, function, class受命名空间的约束。 使用命名空间使用命名空间的方式如下： &lt;?php namespace B; use A; const test = &apos;Btest&apos;; function test() { return __FUNCTION__; } class Test{ public function __construct(){ return __METHOD__; } } include &quot;a.php&quot;;//必须包含A命名空间的文件 // 完全限定 // `\\B\\test`从绝对位置查找输出，如果是全局函数则`\\test` echo \\B\\test; //输出Btest // 限定名称 // 这里已经通过`use A`申明了在这个文件可以通过`\\A\\...`使用A命名空间的函数 echo A\\test; //输出Atest // 非限定名称 // 非限定名称的函数`test`会从当前命名控件查找，即B echo test; //输出Btest // namespace关键字代表当前命名空间 echo namespace/test; ?&gt; 首先要注意的是命名空间只起申明作用，也就是在使用了命名空间的时候依然得把这个命名空间申明的那个文件包含进来。在使用中可以通过__NAMESPACE__来查看当前命名空间。 更多内容可以查看PHP官方文档 自动加载每个文件既要申明命名控件又要手动include是非常不智能的事情，所以在自己的PHP系统或者框架中可以使用自动加载技术，让系统自己去找 最简单的方式是利用函数__autoload函数，但是这个函数只能在非命名控件下定义，也就是全局情况下： function __autoload($class) { $dir = &apos;./&apos;; set_include_path(get_include_path().PATH_SEPARATOR.$ids_dir); $class = str_replace(&apos;\\\\&apos;, &apos;/&apos;, $class) . &apos;.php&apos;; require_once($class); } 如果在已经有了命名空间的类中，可以使用函数spl_autoload_register来注册一个类中的方法来代替__autoload","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"了解GitHub工作流【译】","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2014-01-30-understanding-the-github-workflow/","text":"创建一个分支当你工作在一个项目中，你可能会在任何时间产生不同的想法和特性计划–这些都是准备完成的，或者其他不准备完成的。分支的存在可以帮助你管理工作流。 当你在自己的项目中创建一个分支的时候，也就等于创建了一个尝试自己想法的环境。你在这个分支修改的东西不会影响到主分支，所以你可以尽情的测试和提交改变。这些改变直到你的合作伙伴审查过，确保安全才会被合并到主分支中。 分支是Git的一个核心概念，并且GitHub流完全基于这个概念。只有一个规则，那就是master分支必须是可部署的。 因此，当你在修复bug或者创建新功能时，你的新分支必须创建在master之外。你的分支名称应该是自描述的（如：refactor-authentication，user-content-cache-key，make-retina-avatars），所以其他人可以了解什么正在进行。 增加提交一但你的分支创建完成，就可以进行修改了。不管你进行了增加、修改或者删除一个文件，你都可以进行提交代码，将他们增加到分支中去。这个过程可以保持跟踪你对一个特性分支工作的发展。 提交同样为你的项目创建了一个清晰的历史，这样别人就可以了解你做这些的原因以及内容。每一个提交有一个相关的描述，这个描述可以解释你具体做了什么修改。另外，每一个提交都应该是分开的修改单元。这个使得你可以在发现bug的时候回滚修改，或者你决定朝向不同的方向。 提交描述是非常重要的，尤其因为Git跟踪你的改变并且在他们被推送到服务器上的时候显示他们。通过写出清楚的提交描述，你可以使得别人容易遵从和提供反馈。 开启一个Pull RequestPull Request最初开始于对你的提交的讨论。因为他们紧密集成在Git库下，如果你的请求被接受，所有人可以看到被合并的改变具体包含什么。 你可以开启一个Pull Request在开发过程工任何部分：当你有少量代码，或者你希望分享一些截图或平常的想法，或者当你被卡住希望获得帮助及建议，又或者当你准备好让别人来审查你的工作。通过在请求描述中使用GitHub的 @方式 ，你可以向某一个人或者团队要求反馈，不论他们不在线或者在别的时区。 Pull Request对于开元项目的管理和分享都非常有用。如果你使用一个Fork&amp;Pull模型，Pull Request提供了一个方式来告知项目管理者他们希望关注的改变。如果你使用Shared repository Model，Pull Request有助于开始审查和讨论即将合并到master分支的改变。 讨论并审核你的代码一但一个Pull Request被开启，负责审核代码改变的人们或团队可能会有一些问题或者评论。可能代码风格不符合项目指导，修改缺少单元测试，或者所有修改都做的非常好。Pull Request被设计来促进和不活这种类型的会话。 在对你提交进行讨论和反馈的过程中，你可以继续推送你的分支。如果有人评论你忘了做一些事情，或者有一些bug在你的代码中，你可以在自己分支中修复并且推送这些修改。GitHub将在统一的Pull Request视图中给你显示新的提交和其他额外的反馈。 Pull Request评论用Markdown写成，所以你可以嵌入图片和表情符号，使用pre-formatted的文字块，和高亮的格式。 合并和部署一但你的Pull Request审核通过并且分支通过测试，这些代码就可以被合并到master分支以便部署。如果你需要在合并到GitHub库前进行测试，你可以在本地先进行合并。这些在你推送到库中前都是非常容易控制的。 一但被合并，Pull Request会对你的代码保存一个历史修改记录。因为它们是可搜索的，所以所有人都可以回顾到历史纪录去了解一个决定是为什么或者怎么完成的。 通过在Pull Request的文字中包含某些关键字，你可以关联代码和issues。当你的Pull Request被合并，相关的issues同样会被关闭。比如，输入Closes #32将会关闭库中的32号issue。想要获得更多信息，点这里。 原文链接：http://guides.github.com/overviews/flow/","tags":[{"name":"Git","slug":"Git","permalink":"https://www.devzou.com/tags/Git/"}]},{"title":"PHP Socket的使用","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2014-01-25-how-to-use-php-socket/","text":"Socket是什么 socket的英文原义是“孔”或“插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。 以上内容来自百度百科 简单说来，socket可以帮助不同的服务在不同的端口进行通信。 PHP中的实现服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php set_time_limit(0);// 设置主机和端口$host = \"127.0.0.1\";$port = 12387;// 创建一个tcp流$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(\"socket_create() failed:\" . socket_strerror(socket_last_error()));// 设置阻塞模式socket_set_block($socket) or die(\"socket_set_block() failed:\" . socket_strerror(socket_last_error())); // 绑定到端口socket_bind($socket, $host, $port) or die(\"socket_bind() failed:\" . socket_strerror(socket_last_error()));// 开始监听socket_listen($socket, 4) or die(\"socket_listen() failed:\" . socket_strerror(socket_last_error()));echo \"Binding the socket on $host:$port ... \\n\";while (true) &#123; // 接收连接请求并调用一个子连接Socket来处理客户端和服务器间的信息 if (($msgsock = socket_accept($socket)) &lt; 0) &#123; echo \"socket_accept() failed:\" . socket_strerror(socket_last_error()); &#125;else&#123; // 读数据 $out = ''; while($buf = socket_read($msgsock,8192))&#123; $out .= $buf; &#125; // 写数据 $in = \"数据是 $out\"; socket_write($msgsock, $in, strlen($in)); &#125; // 结束通信 socket_close($msgsock);&#125;socket_close($socket);?&gt; 服务端主要进行了以下步骤： 创建Socket的监听，等待连接 当链接到来时，开启一个子连接处理IO 接收来自客户端的传输数据 将结果写回给客户端 客户端123456789101112131415161718192021222324252627&lt;?php set_time_limit(0);$host = \"127.0.0.1\"; $port = 12387;// 创建一个tcp流$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(\"socket_create() failed:\" . socket_strerror(socket_last_error()));echo \"try to connect to $host:$port...\\n\";$result = socket_connect($socket, $host, $port) or die(\"socket_connect() failed:\" . socket_strerror(socket_last_error()));$in = \"hello \\n\";if(!socket_write($socket, $in, strlen($in))) &#123; echo \"socket_write() failed:\" . socket_strerror($socket);&#125;else &#123; echo \"发送成功！\\n\";&#125;$out = '';while($buf = socket_read($socket, 8192)) &#123; $out .= $buf;&#125;echo \"接受内容为：$out \\n\";socket_close($socket);?&gt; 客户端主要有以下步骤： 连接到服务端Socket 向服务端写数据 接收来自服务端的数据","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"PHP中的魔术方法和魔术常量简介和使用","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2014-04-27-magic-methods-and-magic-constants-in-php/","text":"魔术方法(Magic methods)PHP中把以两个下划线__开头的方法称为魔术方法，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： __construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __construct()和__destruct()构造函数和析构函数应该不陌生，他们在对象创建和消亡时被调用。例如我们需要打开一个文件，在对象创建时打开，对象消亡时关闭 1234567891011121314&lt;?php class FileRead&#123; protected $handle = NULL; function __construct()&#123; $this-&gt;handle = fopen(...); &#125; function __destruct()&#123; fclose($this-&gt;handle); &#125;&#125;?&gt; 这两个方法在继承时可以扩展，例如： 123456789101112&lt;?php class TmpFileRead extends FileRead&#123; function __construct()&#123; parent::__construct(); &#125; function __destruct()&#123; parent::__destruct(); &#125;&#125;?&gt; __call()和__callStatic()在对象中调用一个不可访问方法时会调用这两个方法，后者为静态方法。这两个方法我们在可变方法（Variable functions）调用中可能会用到。 12345678910111213141516&lt;?phpclass MethodTest &#123; public function __call ($name, $arguments) &#123; echo \"Calling object method '$name' \". implode(', ', $arguments). \"\\n\"; &#125; public static function __callStatic ($name, $arguments) &#123; echo \"Calling static method '$name' \". implode(', ', $arguments). \"\\n\"; &#125;&#125;$obj = new MethodTest;$obj-&gt;runTest('in object context');MethodTest::runTest('in static context');?&gt; __get()，__set()，__isset()和__unset()当get/set一个类的成员变量时调用这两个函数。例如我们将对象变量保存在另外一个数组中，而不是对象本身的成员变量 123456789101112131415161718192021222324&lt;?php class MethodTest&#123; private $data = array(); public function __set($name, $value)&#123; $this-&gt;data[$name] = $value; &#125; public function __get($name)&#123; if(array_key_exists($name, $this-&gt;data)) return $this-&gt;data[$name]; return NULL; &#125; public function __isset($name)&#123; return isset($this-&gt;data[$name]) &#125; public function unset($name)&#123; unset($this-&gt;data[$name]); &#125;&#125;?&gt; __sleep()和__wakeup()当我们在执行serialize()和unserialize()时，会先调用这两个函数。例如我们在序列化一个对象时，这个对象有一个数据库链接，想要在反序列化中恢复链接状态，则可以通过重构这两个函数来实现链接的恢复。例子如下： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Connection &#123; protected $link; private $server, $username, $password, $db; public function __construct($server, $username, $password, $db) &#123; $this-&gt;server = $server; $this-&gt;username = $username; $this-&gt;password = $password; $this-&gt;db = $db; $this-&gt;connect(); &#125; private function connect() &#123; $this-&gt;link = mysql_connect($this-&gt;server, $this-&gt;username, $this-&gt;password); mysql_select_db($this-&gt;db, $this-&gt;link); &#125; public function __sleep() &#123; return array('server', 'username', 'password', 'db'); &#125; public function __wakeup() &#123; $this-&gt;connect(); &#125;&#125;?&gt; __toString()对象当成字符串时的回应方法。例如使用echo $obj;来输出一个对象 123456789101112&lt;?php// Declare a simple classclass TestClass&#123; public function __toString() &#123; return 'this is a object'; &#125;&#125;$class = new TestClass();echo $class;?&gt; 这个方法只能返回字符串，而且不可以在这个方法中抛出异常，否则会出现致命错误。 __invoke()调用函数的方式调用一个对象时的回应方法。如下 12345678910&lt;?phpclass CallableClass &#123; function __invoke() &#123; echo 'this is a object'; &#125;&#125;$obj = new CallableClass;var_dump(is_callable($obj));?&gt; __set_state()调用var_export()导出类时，此静态方法会被调用。 12345678910111213141516171819&lt;?phpclass A&#123; public $var1; public $var2; public static function __set_state ($an_array) &#123; $obj = new A; $obj-&gt;var1 = $an_array['var1']; $obj-&gt;var2 = $an_array['var2']; return $obj; &#125;&#125;$a = new A;$a-&gt;var1 = 5;$a-&gt;var2 = 'foo';var_dump(var_export($a));?&gt; __clone()当对象复制完成时调用。例如在设计模式详解及PHP实现：单例模式一文中提到的单例模式实现方式，利用这个函数来防止对象被克隆。 1234567891011121314151617181920&lt;?php public class Singleton &#123; private static $_instance = NULL; // 私有构造方法 private function __construct() &#123;&#125; public static function getInstance() &#123; if (is_null(self::$_instance)) &#123; self::$_instance = new Singleton(); &#125; return self::$_instance; &#125; // 防止克隆实例 public function __clone()&#123; die('Clone is not allowed.' . E_USER_ERROR); &#125;&#125;?&gt; 魔术常量(Magic constants)PHP中的常量大部分都是不变的，但是有8个常量会随着他们所在代码位置的变化而变化，这8个常量被称为魔术常量。 __LINE__，文件中的当前行号 __FILE__，文件的完整路径和文件名 __DIR__，文件所在的目录 __FUNCTION__，函数名称 __CLASS__，类的名称 __TRAIT__，Trait的名字 __METHOD__，类的方法名 __NAMESPACE__，当前命名空间的名称 这些魔术常量常常被用于获得当前环境信息或者记录日志。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"用Laravel+Grunt+Bower管理你的应用","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2014-03-10-grunt-bower-and-laravel/","text":"为什么这么选择？如今开源盛行，从后端的各个类库，到如今前端的jQuery插件，前端框架等，越来越多优秀的组件可以被我们选择应用在现有的项目中。随着开源组件的更新迭代，它们互相之间的依赖也越来越复杂。旧的框架对于新的变化总是显得难以适从，就算为了新的特性改变旧的框架，也会显的略显牵强。于是就会有新的框架和工具，在这个时候凸现出来。 每个项目开始的方向是很重要的，良好的开始可以避免之后的各种问题。下面要说的三个工具，就是现有应用开发的一个良好开端。 LaravelLaravel是一个非常新的PHP框架，借鉴了很多前辈的优秀特性，以PHP5为起点，引入了Composer作为包管理工具，号称为WEB艺术家创造的PHP框架。 Grunt基于JavaScript的自动化构建工具，可以将重复的任务，例如压缩（minification），编译，单元测试，linting等自动化。 BowerWeb前端开发的包管理工具，解决前端框架间的依赖关系，方便模块化和重用。 优势 使用Laravel可以更好的利用最新版PHP的优势，排除了一些历史问题。 利用Composer可以极大减少”轮子”的数量，优秀的包可以去Packagist找到，这些包几乎都利用Github来托管，利用Github的issue和request可以辅助提高包的质量。 Bower可以帮助统一管理开源前端库，如Bootstrap和jQuery等，同样这些包也在Github上托管。 Grunt帮助粘合前后端的开源组件，将合并编译压缩等工作自动化。 安装使用前提有些需要提前安装的组件这里不在赘述，请自行Google。 Composer Node &amp; npm Grunt Bower Laravel有了Composer后安装一个Laravel项目非常容易 composer create-project laravel/laravel myproject 安装完成后在myproject目录下就生成了laravel的框架结构，入口文件在public中。在myproject根目录下，有一个composer.json文件，这个文件看起来是这样的： 12345678910&#123; \"name\": \"laravel/laravel\", \"description\": \"The Laravel Framework.\", \"keywords\": [\"framework\", \"laravel\"], \"license\": \"MIT\", \"require\": &#123; \"laravel/framework\": \"4.1.*\" &#125;, //...&#125; 这个文件可以控制项目的一些依赖关系，我们需要一些组件的时候直接在require下添加即可，composer会帮我们去查找这个组件所需的依赖包。 接着为了安装前端框架，我们先来创建几个公共目录，在public下，创建类似的目录 123456789.|-- assets| |-- css| |-- fonts| `-- js|-- favicon.ico|-- index.php|-- packages`-- robots.txt 这里只有assets目录是我新创建的 Bower准备好后端框架以后，可以安装前端框架了，例如Bootstrap。利用Bower安装的前端库是其整个工程，并不是我们需要的个别文件，所以可以讲它们先放在一个位置，之后利用Grunt来统一处理。 首先配置一下安装路径，在myproject根目录下配置文件.bowerrc为 123&#123; \"directory\": \"public/assets/bower\"&#125; 这个文件告诉bower，将下载的包都安装到public/assets/bower下。 接着在根目录创建一个bower的配置文件bower.json为 123&#123; \"name\": \"myproject\"&#125; 接着添加前端库 bower install bootstrap -S 这个命令将会利用配置文件管理整个库依赖，这个时候再看一下配置文件，bower已经帮助我们自动安装好了Bootstrap依赖的包–jQuery，同时修改了配置文件 123456&#123; \"name\": \"myproject\", \"dependencies\": &#123; \"bootstrap\": \"~3.1.1\" &#125;&#125; 在看一下目标目录，public/assets下，生成了一个bower目录，其中包含了Bootstrap和jQuery。 Grunt根据上面的步骤，我们很方便的建立了后端框架和前端框架，但是前端框架在使用的时候直接用bower下的文件并不是非常方便，而且还可能会涉及到一些库的合并压缩等步骤。这些问题都可以交给Grunt去做. 首先在myproject根目录下利用npm init初始化一个配置文件。根据提示一步一步填写即可，最后生成的配置文件package.json应该如下所示： 1234567891011&#123; \"name\": \"myproject\", \"version\": \"0.0.1\", \"description\": \"\", \"main\": \"Gruntfile.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 有不一样的地方不用担心，尽管修改即可。 接着我们要安装一些Grunt的插件，帮助我们更好的完成所需功能。 npm install grunt --save-dev npm install grunt-contrib-concat --save-dev npm install grunt-contrib-less --save-dev npm install grunt-contrib-uglify --save-dev npm install grunt-contrib-watch --save-dev npm install grunt-contrib-copy --save-dev npm install grunt-contrib-cssmin --save-dev 这里的每个插件我会在下面的配置中介绍。上面命令中的--save-dev选项的作用是将安装的这些包放入配置文件依赖项中，方便以后安装。下面是安装后的配置文件： 1234567891011121314151617181920&#123; \"name\": \"myproject\", \"version\": \"0.0.1\", \"description\": \"\", \"main\": \"Gruntfile.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"grunt\": \"~0.4.3\", \"grunt-contrib-concat\": \"~0.3.0\", \"grunt-contrib-less\": \"~0.10.0\", \"grunt-contrib-uglify\": \"~0.4.0\", \"grunt-contrib-watch\": \"~0.5.3\", \"grunt-contrib-cssmin\": \"~0.9.0\" \"grunt-contrib-copy\": \"~0.5.0\" &#125;&#125; 注意在安装后有了一个node_modules目录，这个是node项目依赖包的位置，我们一般都在本地进行文件的合并和压缩，所以可以将这个包保留在本地。另外对于bower生成的目录，在Grunt处理过以后也是可以不上传到正式环境中的。所以修改.gitignore文件，将这两个文件夹排除出去： 12345678910/bootstrap/compiled.php/vendorcomposer.pharcomposer.lock.env.local.php.env.php.DS_StoreThumbs.db/public/assets/bower/node_modules 接下来就要进行Grunt的配置项编写了，我会在配置中加入注释帮助理解。还记得我们刚刚建立的package.json配置文件中的入口文件吗？这个文件还不存在，所以我们需要手动建立，在myproject下创建Gruntfile.js的文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586module.exports = function(grunt) &#123; //配置项 grunt.initConfig(&#123; //concat插件配置，用来合并多个文件 concat: &#123; //文件间的分隔符 options: &#123; separator: ';', &#125;, //app是一个任务名，可以随意命名 app: &#123; //将进行的合并项 src: [ './public/assets/bower/jquery/dist/jquery.js', './public/assets/bower/bootstrap/dist/js/bootstrap.js', ], //合并后放置在 dest: './public/assets/js/javascript.js', &#125;, &#125;, //css合并压缩 cssmin: &#123; //任务名 app: &#123; src: [ './public/assets/bower/bootstrap/dist/css/bootstrap.css', './public/assets/css/base.css' ], dest: './public/assets/css/stylesheet.css' &#125; &#125;, //js压缩 uglify: &#123; options: &#123; mangle: false //是否混合变量，如果需求的话置为true &#125;, app: &#123; files: &#123; './public/assets/js/javascript.js': './public/assets/js/javascript.js', &#125; &#125;, &#125;, //移动文件 copy: &#123; app: &#123; files: [ &#123; expand: true, flatten: true, cwd: './public/assets/bower/bootstrap/fonts/', src: ['**'], dest: './public/assets/fonts/', filter: 'isFile' &#125;, ] &#125; &#125;, //监听文件变化，如果文件变化，将重新进行任务 watch: &#123; app: &#123; files: [ './public/assets/bower/jquery/dist/jquery.js', './public/assets/bower/bootstrap/dist/js/bootstrap.js', './public/assets/bower/bootstrap/dist/css/bootstrap.css', ], //文件变化后执行哪些任务 tasks: ['concat:app','uglify:app','cssmin:app','copy:app'], options: &#123; livereload: true &#125; &#125;, &#125; &#125;); //导入所需的插件 grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-contrib-less'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-copy'); grunt.loadNpmTasks('grunt-contrib-cssmin'); //注册两个任务 grunt.registerTask('watch', ['watch']); grunt.registerTask('default', ['concat:app','uglify:app','cssmin:app','copy:app']);&#125;; 我们看到，最后注册了两个任务，这两个任务可以从终端中执行，例如： grunt watch 可以开启文件监听，当文件变化时执行watch中设定的任务。 如果直接执行grunt，则会执行default中设定的任务。我们也可以具体指定执行某一单一任务，如 grunt copy:app 上面则只将bootstrap/fonts中的文件拷贝到public/assets/fonts中。 对于上述的这些插件，可以在这里找到，也有详细的用法。 总结每个人都有自己的喜好，我的这种配置可能只抛个砖，希望有更好的方式分享。最后在总结一下这三剑客： Laravel利用了最新PHP特性，引入了Composer包管理，解决后端库之间的依赖 Bower帮助安装和解决前端框架和库的依赖关系 Grunt帮助粘合前后端的开源组件，并且完成合并和压缩等重复性工作。 下面两篇参考文章各有特色，如果希望了解一下可以点击链接去看。 我在Github上建立了这篇博客中所讲的目录结构，想要快速建立一个可使用的工程，只需要以下几部： git clone https://github.com/suyan/Laravel-Bower-Grunt.git composer install bower update npm install grunt Enjoy it! 参考 How I use Bower and Grunt with my Laravel projects Using Grunt + Bower with Laravel and Bootstrap","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"https://www.devzou.com/tags/Laravel/"}]},{"title":"从运行原理及使用场景看Apache和Nginx","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2014-02-15-apache-and-nginx/","text":"本文只作为了解Apache和Nginx知识的一个梳理，想详细了解的请阅读文末参考链接中的博文。 Web服务器Web服务器也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务。 应用层使用HTTP协议。 HTML文档格式。 浏览器统一资源定位器(URL)。 Web服务器常常以B/S（Browser/Server）方式提供服务。浏览器和服务器的交互方式如下： 123456789 GET /index.php HTTP/1.1+---------------+ +----------------+| +-------------------&gt; || Browser | | Server || &lt;-------------------+ |+---------------+ +----------------+ HTTP/1.1 200 OK 浏览器向服务器发出HTTP请求(Request)。 服务器收到浏览器的请求数据，经过分析处理，向浏览器输出响应数据（Response）。 浏览器收到服务器的响应数据，经过分析处理，将最终结果显示在浏览器中。 Apache和Nginx都属于Web服务器，两者都实现了HTTP 1.1协议。 Apache概述Apache HTTP Server是Apache软件基金会的一个开放源代码的网页服务器，可以在大多数计算机操作系统中运行，由于其跨平台和安全性。被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl／Python等解释器编译到服务器中。 – 维基百科 Apache组件Apache是基于模块化设计的，它的核心代码并不多，大多数的功能都被分散到各个模块中，各个模块在系统启动的时候按需载入。 12345678910111213141516 +----------+ +- | Module | -----------------+ | +----------+ | | +------------++-----------+ Apache HTTPD | php module || Module | +------------++-----------+ +----------+| +----------+-------- | MPM |+ | +----+---+-+ +-v-----------+ | | | ARP &lt;--+ | +------+------+ | | | +---------------v-------------v--+ | Operating System | +--------------------------------+ MPM（Multi -Processing Modules，多重处理模块）是Apache的核心组件之一，Apache通过MPM来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得最好的运行性能，针对不同的平台 (Unix/Linux、Window)做了优化，为不同的平台提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。至于您的服务器正以哪种方式运行，取决于安装Apache过程中指定的MPM编译参数,在X系统上默认的编译参数为 prefork。 由于大多数的Unix都不支持真正的线程，所以采用了预派生子进程(prefork)方式，象Windows或者Solaris这些支持 线程的平台，基于多进程多线程混合的worker模式是一种不错的选择。Apache中还有一个重要的组件就是APR（Apache portable Runtime Library），即Apache可移植运行库，它是一个对操作系统调用的抽象库，用来实现Apache内部组件对操作系统的使用，提高系统的可移植性。 Apache对于php的解析，就是通过众多Module中的php Module来完成的。 Apache生命周期12345678910111213141516171819202122+--------------------------------------------------------------+| +---------------------+ 启动阶段 || | 系统启动, 配置 | || +----------+----------+ || | || +----------v----------+ || | 模块的初始化 | || +-+--------+--------+-+ || | | | || +-------------+ | +------v-------+| +--------------+ || | 子进程初始化 |&lt;+ | 子进程初始化 |+&gt;| 子进程初始化 | || +------+------+ +-------+------+ +-------+------+ |+--------------------------------------------------------------+| | | | 运行阶段 || +----v----+ +----v----+ +----v----+ || | 请求循环 | | 请求循环 | | 请求循环 | || +----+----+ +----+----+ +----+----+ || | | | || +------v------+ +------v------+ +------v------+ || | 子进程结束 | | 子进程结束 | | 子进程结束 | || +-------------+ +-------------+ +-------------+ |+--------------------------------------------------------------+ 这个生命周期是在perfork工作下的示意，从图中可以看出，Apache对于每一个请求都要启动一个单独的进程来处理。 Apache的工作模式prefork的工作原理一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。运行子进程的用户必须要对他所服务的内容有读取的权限，但是对服务内容之外的其他资源必须拥有尽可能少的权限。 worker的工作原理每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。Apache总是试图维持一个备用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。虽然子进程必须对其提供的内容拥有读权限，但应该尽可能给予他较少的特权。另外，除非使用了suexec ，否则，这些指令配置的权限将被CGI脚本所继承。 Apache的运行启动阶段在启动阶段，Apache主要进行配置文件解析(例如http.conf以及Include指令设定的配置文件等)、模块加载(例如mod_php.so,mod_perl.so等)和系统资源初始化（例如日志文件、共享内存段等）工作。在这个阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root（X系统）或超级管理员administrator(Windows系统)完成启动。 这个过程可以通过下图来深入了解： 12345678910111213141516171819 +--------+ | 开始 | +----+---+ |+----------v------------+ 解析主配置文件http.conf中配置信息， | 解析配置文件 | 像LoadModule, AddType+----------+------------+ 等指令被加载至内存 |+----------v------------+ 依据AddModule, LoadModule等指令| 加载静态/动态模块 | 加载Apache模块，像mod_php5.so被+----------+------------+ 加载至内存，映射到Apache地址空间。 |+----------v------------+ 日志文件、共享内存段，数据库链接| 系统资源初始化 | 等初始化+----------+------------+ | +---v----+ | 结束 | +--------+ 运行阶段在运行阶段，Apache主要工作是处理用户的服务请求。在这个阶段，Apache放弃特权用户级别，使用普通权限，这主要是基于安全性的考虑，防止由于代码的缺陷引起的安全漏洞。 由于Apache的Hook机制，Apache 允许模块(包括内部模块和外部模块，例如mod_php5.so,mod_perl.so等)将自定义的函数注入到请求处理循环中。mod_php5.so/php5apache2.dll就是将所包含的自定义函数，通过Hook机制注入到Apache中，在Apache处理流程的各个阶段负责处理php请求。 Apache将请求处理循环分为11个阶段，依次是：Post-Read-Request，URI Translation，Header Parsing，Access Control，Authentication，Authorization，MIME Type Checking，FixUp，Response，Logging，CleanUp。 Apache处理http请求的生命周期: Post-Read-Request阶段:在正常请求处理流程中，这是模块可以插入钩子的第一个阶段。对于那些想很早进入处理请求的模块来说，这个阶段可以被利用。 URI Translation阶段 : Apache在本阶段的主要工作：将请求的URL映射到本地文件系统。模块可以在这阶段插入钩子，执行自己的映射逻辑。mod_alias就是利用这个阶段工作的。 Header Parsing阶段 : Apache在本阶段的主要工作：检查请求的头部。由于模块可以在请求处理流程的任何一个点上执行检查请求头部的任务，因此这个钩子很少被使用。mod_setenvif就是利用这个阶段工作的。 Access Control阶段 : Apache在本阶段的主要工作：根据配置文件检查是否允许访问请求的资源。Apache的标准逻辑实现了允许和拒绝指令。mod_authz_host就是利用这个阶段工作的。 Authentication阶段 : Apache在本阶段的主要工作：按照配置文件设定的策略对用户进行认证，并设定用户名区域。模块可以在这阶段插入钩子，实现一个认证方法。 Authorization阶段 : Apache在本阶段的主要工作：根据配置文件检查是否允许认证过的用户执行请求的操作。模块可以在这阶段插入钩子，实现一个用户权限管理的方法。 MIME Type Checking阶段 : Apache在本阶段的主要工作：根据请求资源的MIME类型的相关规则，判定将要使用的内容处理函数。标准模块mod_negotiation和mod_mime实现了这个钩子。 FixUp阶段 : 这是一个通用的阶段，允许模块在内容生成器之前，运行任何必要的处理流程。和Post_Read_Request类似，这是一个能够捕获任何信息的钩子，也是最常使用的钩子。 Response阶段 : Apache在本阶段的主要工作：生成返回客户端的内容，负责给客户端发送一个恰当的回复。这个阶段是整个处理流程的核心部分。 Logging阶段 : Apache在本阶段的主要工作：在回复已经发送给客户端之后记录事务。模块可能修改或者替换Apache的标准日志记录。 CleanUp阶段 : Apache在本阶段的主要工作：清理本次请求事务处理完成之后遗留的环境，比如文件、目录的处理或者Socket的关闭等等，这是Apache一次请求处理的最后一个阶段。 Nginx概述Nginx（发音同engine x）是一款由俄罗斯程序员Igor Sysoev所开发轻量级的网页服务器、反向代理服务器以及电子邮件（IMAP/POP3）代理服务器。起初是供俄国大型的门户网站及搜索引擎Rambler（俄语：Рамблер）使用。 – 维基百科 Nginx的模块与工作原理Nginx由内核和模块组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。 Nginx的模块从结构上分为核心模块、基础模块和第三方模块： 核心模块：HTTP模块、EVENT模块和MAIL模块 基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块， 第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块。 Nginx的模块从功能上分为如下三类: Handlers（处理器模块）。此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个。 Filters （过滤器模块）。此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。 Proxies （代理类模块）。此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能。 123456789101112131415161718 + ^ Http Request | | Http Response | | +---------+------v-----+ +----+----+ | Conf | Nginx Core | | FilterN | +---------+------+-----+ +----^----+ | | | +----+----+ | | Filter2 |choose a handler | +----^----+based conf | | | +----+----+ | | Filter1 | | +----^----+ | | Generate content +-----v--------------------+----+ | Handler | +-------------------------------+ Nginx本身做的工作实际很少，当它接到一个HTTP请求时，它仅仅是通过查找配置文件将此次请求映射到一个location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做Nginx真正的劳动工作者。通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。 Nginx架构及工作流程 上图是Nginx的架构，这个架构类似于Apache的Worker工作状态，Nginx的每一个Worker进程都管理着大量的线程，真正处理请求的是Worker之下的线程。 所有实际上的业务处理逻辑都在worker进程。worker进程中有一个函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个nginx服务被停止。Worker中这个函数执行内容如下： 操作系统提供的机制（例如epoll, kqueue等）产生相关的事件。 接收和处理这些事件，如是接受到数据，则产生更高层的request对象。 处理request的header和body。 产生响应，并发送回客户端。 完成request的处理。 重新初始化定时器及其他事件。 Nginx和FastCGIFastCGIFastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。 FastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后将结果返回给HTTP服务器。这在处理高并发访问时几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少使用了。 FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。 Nging和FastCGI合作Nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。 接下来以Nginx下PHP的运行过程来说明。PHP-FPM是管理FastCGI的一个管理器，它作为PHP的插件存在。 FastCGI进程管理器php-fpm自身初始化，启动主进程php-fpm和启动start_servers个CGI 子进程。主进程php-fpm主要是管理fastcgi子进程，监听9000端口。fastcgi子进程等待来自Web Server的连接。 当客户端请求到达Web Server Nginx是时，Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理，即Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理。 FastCGI进程管理器PHP-FPM选择并连接到一个子进程CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程。 FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。 FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。 Apache和Nginx比较功能对比Nginx和Apache一样，都是HTTP服务器软件，在功能实现上都采用模块化结构设计，都支持通用的语言接口，如PHP、Perl、Python等，同时还支持正向和反向代理、虚拟主机、URL重写、压缩传输、SSL加密传输等。 在功能实现上，Apache的所有模块都支持动、静态编译，而Nginx模块都是静态编译的， 对FastCGI的支持，Apache对Fcgi的支持不好，而Nginx对Fcgi的支持非常好； 在处理连接方式上，Nginx支持epoll，而Apache却不支持； 在空间使用上，Nginx安装包仅仅只有几百K，和Nginx比起来Apache绝对是庞然大物。 Nginx相对apache的优点 轻量级，同样起web 服务，比apache 占用更少的内存及资源 静态处理，Nginx 静态处理性能比 Apache 高 3倍以上 抗并发，nginx 处理请求是异步非阻塞的，而apache则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能。在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出现Apache进程数飙升，从而拒绝服务的现象。 高度模块化的设计，编写模块相对简单 社区活跃，各种高性能模块出品迅速啊 apache相对nginx的优点 rewrite，比nginx 的rewrite 强大 模块超多，基本想到的都可以找到 少bug，nginx的bug相对较多 超稳定 Apache对PHP支持比较简单，Nginx需要配合其他后端用 选择Nginx的优势所在 作为Web服务器: Nginx处理静态文件、索引文件，自动索引的效率非常高。 作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度。 作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡。 在性能方面，Nginx是专门为性能优化而开发的，在实现上非常注重效率。它采用内核Poll模型(epoll and kqueue )，可以支持更多的并发连接，最大可以支持对50 000个并发连接数的响应，而且只占用很低的内存资源。 在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持10 000个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的。 在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7×24小时不间断地运行。 同时使用Nginx和Apache由于Nginx和Apache各自的优势，现在很多人选择了让两者在服务器中共存。在服务器端让Nginx在前，Apache在后。由Nginx做负载均衡和反向代理，并且处理静态文件，讲动态请求（如PHP应用）交给Apache去处理。 参考 Apache运行机制剖析 Apache处理http请求的生命周期 Nginx平台初探 Nginx架构综述 Apache, nginx, lighttpd性能比较","tags":[{"name":"Apache","slug":"Apache","permalink":"https://www.devzou.com/tags/Apache/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.devzou.com/tags/Nginx/"}]},{"title":"为PHP设置服务器(Apache/Nginx)环境变量","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tech/2014-05-04-set-environment-variables-of-server-for-php/","text":"设置Apache环境变量指令设置当前环境变量为DEV SetEnv RUNTIME_ENVIROMENT DEV 数据库帐号密码 SetEnv MYSQL_USERNAME root SetEnv MYSQL_PASSWORD root 配置文件格式&lt;VirtualHost *:80&gt; ServerAdmin admin@admin.com DocumentRoot &quot;/var/www/&quot; ServerName localhost SetEnv RUNTIME_ENVIROMENT DEV SetEnv MYSQL_USERNAME root SetEnv MYSQL_PASSWORD root ErrorLog &quot;logs/error.log&quot; CustomLog &quot;logs/access.log&quot; common &lt;/VirtualHost&gt; 设置Nginx环境变量指令设置当前环境变量为DEV fastcgi_param RUNTIME_ENVIROMENT &apos;DEV&apos; 数据库帐号密码 fastcgi_param MYSQL_USERNAME &apos;root&apos; fastcgi_param MYSQL_PASSWORD &apos;root&apos; 配置文件格式在fastcgi_params文件中配置 fastcgi_param RUNTIME_ENVIROMENT &apos;DEV&apos;; fastcgi_param MYSQL_USERNAME &apos;root&apos;; fastcgi_param MYSQL_PASSWORD &apos;root&apos;; 在nginx.conf中配置 server { listen 80; root /var/www; index index.php; server_name localhost; location / { index index.php; } location ~ .*\\.(php|php5)?$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; } } 为PHP脚本设置环境变量为当前用户临时设置临时设置只需要执行 export KEY=VALUE 为当前用户永久设置在~/.bashrc（不同系统各有不同）中写 为所有用户（不包括root）设置创建文件/etc/profile.d/test.sh，写入 KEY=VALUE 为所有用户（包括root）设置在/etc/environment中写入 KEY=VALUE 注意，这个文件的生效时间是用户登录时，所以对于root来说，需要重启机器 在Supervisor中设置有的时候PHP脚本是用Supervisor来控制的，所以记得设置supervisor配置中的environment项 在PHP中调用服务器环境变量在PHP中有两个调用方式： $env = getenv(&apos;RUNTIME_ENVIROMENT&apos;); 还有超全局变量方式： $env = $_SERVER[&apos;RUNTIME_ENVIROMENT&apos;]; 参考 apache和nginx设置环境变量的方法","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"},{"name":"Apache","slug":"Apache","permalink":"https://www.devzou.com/tags/Apache/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.devzou.com/tags/Nginx/"}]},{"title":"Linux下开启Libvirtd的tcp监控","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-03-25-open-tcp-port-of-libvirt/","text":"使用virsh连接到别的服务器时，使用的是tcp连接 virsh -c qemu+tcp://host/system 如果目标服务器没有开启libvirtd的tcp端口监听时，会出现 error: unable to connect to server at &apos;host:16509&apos;: Connection refused error: failed to connect to the hypervisor ubuntu下解决方法sed -i &apos;s/#listen_tls = 0/listen_tls = 0/g&apos; /etc/libvirt/libvirtd.conf sed -i &apos;s/#listen_tcp = 1/listen_tcp = 1/g&apos; /etc/libvirt/libvirtd.conf sed -i &apos;s/#auth_tcp = &quot;sasl&quot;/auth_tcp = &quot;none&quot;/g&apos; /etc/libvirt/libvirtd.conf vi /etc/default/libvirt-bin 修改为libvirt_opts = &quot;-d -l&quot; 增加-l监听tcp service libvirt-bin restart centos下解决方法sed -i &apos;s/#listen_tls = 0/listen_tls = 0/g&apos; /etc/libvirt/libvirtd.conf sed -i &apos;s/#listen_tcp = 1/listen_tcp = 1/g&apos; /etc/libvirt/libvirtd.conf sed -i &apos;s/#auth_tcp = &quot;sasl&quot;/auth_tcp = &quot;none&quot;/g&apos; /etc/libvirt/libvirtd.conf sed -i &apos;s/#LIBVIRTD_ARGS=&quot;--listen&quot;/LIBVIRTD_ARGS=&quot;--listen&quot;/g&apos; /etc/sysconfig/libvirtd service libvirtd restart","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.devzou.com/tags/Linux/"}]},{"title":"win7快速打开应用程序或文件","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-02-25-quick-open-in-windows/","text":"Win7下打开“运行”的快捷键是 Win+R 打开系统命令windows的“运行”功能本来就是帮助用户快速打开程序的，不过其支持的主要是系统的一些程序，大致如下(来自网络，有一部分失效或无法打开)： 1、cleanmgr: 打开磁盘清理工具 2、compmgmt.msc: 计算机管理 3、conf: 启动系统配置实用程序 4、charmap: 启动字符映射表 5、calc: 启动计算器 6、chkdsk.exe: Chkdsk磁盘检查 7、cmd.exe: CMD命令提示符 8、certmgr.msc: 证书管理实用程序 9、Clipbrd: 剪贴板查看器 10、dvdplay: DVD播放器 11、diskmgmt.msc: 磁盘管理实用程序 12、dfrg.msc: 磁盘碎片整理程序 13、devmgmt.msc: 设备管理器 14、dxdiag: 检查DirectX信息 15、dcomcnfg: 打开系统组件服务 16、explorer: 打开资源管理器 17、eventvwr: 事件查看器 18、eudcedit: 造字程序 19、fsmgmt.msc: 共享文件夹管理器 20、gpedit.msc: 组策略 21、iexpress: 工具，系统自带 22、logoff: 注销命令 23、lusrmgr.msc: 本机用户和组 24、MdSched:来启动Windows内存诊断程序 25、mstsc: 远程桌面连接 26、Msconfig.exe: 系统配置实用程序 27、mplayer2: 简易widnows media player 28、mspaint: 画图板 29、magnify: 放大镜实用程序 30、mmc: 打开控制台 31、mobsync: 同步命令 32、notepad: 打开记事本 33、nslookup: 网络管理的工具向导 34、narrator: 屏幕“讲述人” 35、netstat : an(TC)命令检查接口 36、OptionalFeatures：打开“打开或关闭Windows功能”对话框 37、osk: 打开屏幕键盘 38、perfmon.msc: 计算机性能监测程序 39、regedt32: 注册表编辑器 40、rsop.msc: 组策略结果集 41、regedit.exe: 注册表 42、services.msc: 本地服务设置 43、sysedit: 系统配置编辑器 44、sigverif: 文件签名验证程序 45、shrpubw: 创建共享文件夹 46、secpol.msc: 本地安全策略 47、syskey: 系统加密 48、Sndvol: 音量控制程序 49、sfc.exe: 系统文件检查器 50、sfc /scannow: windows文件保护（扫描错误并复原） 51、taskmgr: 任务管理器 52、utilman: 辅助工具管理器 53、winver: 检查Windows版本 54、wmimgmt.msc: 打开windows管理体系结构(WMI) 55、Wscript.exe: windows脚本宿主设置 56、write: 写字板 57、wiaacmgr: 扫描仪和照相机向导 58、psr：问题步骤记录器 59、PowerShell：提供强大远程处理能力 60、colorcpl：颜色管理，配置显示器和打印机等中的色彩。 61、credwiz：备份或还原储存的用户名和密码 62、eventvwr：事件查看器管理单元(MMC) ，主要用于查看系统日志等信息。 63、wuapp：Windows更新管理器，建议设置为更新提醒模式 64、wf.msc：高级安全Windows防火墙 65、soundrecorder：录音机，没有录音时间的限制 66、snippingtool：截图工具，支持无规则截图 67、slui：Windows激活，查看系统激活信息 68、sdclt：备份状态与配置，就是查看系统是否已备份 69、Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项 70、msdt：微软支持诊断工具 71、lpksetup：语言包安装/删除向导，安装向导会提示下载语言包 系统自带的很多已经够用了，例如其中的notepad命令，想要直接修改hosts文件（常用）可以直接输入 notepad %systemroot%\\system32\\drivers\\etc\\hosts %systemroot%是window内自带的变量，即指向了C:\\Windows,其他一些常用变量如： %HOMEDRIVE% = C:\\ 当前启动的系统的所在分区 %SystemRoot% = C:\\WINDOWS 当前启动的系统的所在目录 %windir% = %SystemRoot% = C:\\WINDOWS 当前启动的系统的所在目录 %USERPROFILE% = C:\\Documents and Settings\\sihochina 当前用户数据变量 %HOMEPATH% = C:\\Documents and Settings\\sihochina 当前用户环境变量 %temp% = %USERPROFILE%\\Local Settings\\Temp = C:\\Documents and Settings\\sihochina\\Local Settings\\Temp 当前用户TEMP缓存变量 另外输入盘符可直达相应盘符，文件也是 d: d:\\application 自定义命令只有系统的应用程序是不够我们用的，要想增加自己另外安装的程序，可以通过其他手段实现 方法一：修改环境变量(不推荐)经常使用cmd命令的同学应该明白，放在环境变量中的文件夹下的应用程序，可以在任何位置直接运行，因为环境变量是windows搜索应用程序的路径，直接放在环境变量下文件夹中的应用程序可以直接运行。 1. 计算机（右键）-》属性-》高级系统设置-》环境变量 2. 修改PATH值，在其后增加相应路径，用‘;’隔开 之所以不推荐是因为环境变量如果设太多，一是管理不便，二又会拖慢应用程序打开速度。 方式二:快捷方式(推荐)这种方式和第一种类似，但是不是修改环境变量，而是往已有的环境变量中增加应用程序的快捷方式 1. 右键应用程序-》发送到桌面快捷方式 2. 修改名字为想要打开的命令 3. 移动快捷方式到已有环境变量中，如C:\\windows下 方式三：注册表方式(不推荐)修改注册表实现，太繁琐，不容易控制 方式四：软件方式（推荐）有一些软件可以帮助建立这样的命令，具体方式因软件而异，但是它们会把功能做的比较人性化，如可以实现增加、更新、删除等 魔方有这个功能，我用的就是这个 打开魔方-》优化设置大师-》系统设置-》快捷命令","tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.devzou.com/tags/Windows/"}]},{"title":"服务器自动化部署及运维常见工具","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-03-25-tools-of-sever-deployment/","text":"CobblerCobbler是一个Linux的安装服务，它可以在网络环境下迅速安装。它可以将众多Linux任务关连在一起，这样在你安装或修改系统时，就可以不必在众多命令和应用程序之间切换了。 随着一系列简单的命令，可以配置网络安装PXE(Preboot Execute Environment)、重新安装、基于媒体的网络安装和虚拟化安装(支持Xen、qemu、KVM、和一些类型的VMware)。Cobbler使用一个叫做’koan’(和Cobbler交互)的程序来重新安装及虚拟化支持。 Cobbler是一个轻量级的应用程序(只有1.5万行Python代码)。它试图在小型和大型安装时都非常简单易用，而且容易工作、扩展和阅读。它避免成为”企业级”(像那么复杂)，但是它又拥有众多优秀的功能，非常适合在各种企业环境中使用，在重复性工作中节省大量的时间。 Cobbler可以选择性的帮助管理DHCP、DNS和yum包镜像基础设施，再者方面，它是一个更广义的自动化应用程序，而不仅仅只是处理配置。它还有一个轻量级的内置配置管理系统，以及整合与配置管理系统，像Puppet一样。Cobbler有一个命令行界面，一个网络界面，和许多用来访问配置的API。 Puppetpuppet是一种Linux、Unix平台的集中配置管理系统，使用ruby语言，可管理配置文件、用户、cron任务、软件包、系统服务等。puppet把这些系统实体称之为资源，puppet的设计目标是简化对这些资源的管理以及妥善处理资源间的依赖关系。 Puppet是一个C/S架构的配置管理工具，在中央服务器上安装puppet-server软件包（被称作Puppet master）。在需要管理的目标主机上安装puppet客户端软件（被称作Puppet Client）。当客户端连接上Puppet master后，定义在Puppet master上的配置文件会被编译，然后在客户端上运行。每个客户端默认每半个小时和服务器进行一次通信，确认配置信息的更新情况。如果有新的配置信息或者配置信息已经改变，配置将会被重新编译并发布到各客户端执行。也可以在服务器上主动触发一个配置信息的更新，强制各客户端进行配置。如果客户端的配置信息被改变了，它可以从服务器获得原始配置进行校正。 FUNCfunc全称 Fedora Unified Network Controller ,主要用在Radhat, Fedora,OpenSuse,Centos系列系统上由一个server管理任意台服务器的工具,建立了Master-Slaves 主从SSL证书管控体系，可以将证书自动分发到所有受控服务.func直接发送远程命令或者远程获取数据,但是只适用于一些常用功能的模块的操作,实现其它功能需要自己写Python API,个人认为没有使用比较适当的”for do done”循环程序效果明确和方便.","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.devzou.com/tags/Linux/"}]},{"title":"给sublime增加snippet","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-04-21-add-snippet/","text":"创建点击菜单栏Tools ==&gt; New Snippet打开一个snippet模板文件 &lt;content&gt;&lt;![CDATA[ ]]]&gt;&lt;/content&gt;部分是片段输入内容 &lt;tabTrigger&gt;p&lt;/tabTrigger&gt;部分是触发此片段的字符，此处为p触发 &lt;scope&gt;text.html&lt;/scope&gt;部分是此片段可用范围，此处为html文件中可用 完整例子： &lt;snippet&gt; &lt;content&gt;&lt;![CDATA[ &lt;p&gt; $1 &lt;/p&gt; ]]&gt;&lt;/content&gt; &lt;tabTrigger&gt;p&lt;/tabTrigger&gt; &lt;scope&gt;text.html&lt;/scope&gt; &lt;/snippet&gt; 保存最后保存文件为.sublime-snippet格式，保存在用户配置目录下 Mac OS X:/Users/yourname/Library/Application Support/Sublime Text 2/Packages/User 另外，&lt;scope&gt;source.css&lt;/scope&gt;是css文件可用 参考参考","tags":[{"name":"Sublime","slug":"Sublime","permalink":"https://www.devzou.com/tags/Sublime/"}]},{"title":"给SVN控制的项目添加忽略文件/文件夹","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-04-22-add-svn-ignore-file/","text":"忽略目录其实有些像建立一个文件夹，但却不放入版本控制。如果不加入版本控制又会在svn status命令中显示出来，很不方便，所以可以设置本文件夹属性，让它既加入版本控制，又忽略其变化 未加入控制的文件夹svn propset svn:ignore &apos;test&apos; . svn update svn commit -m &quot;add a ignore dir&quot; 已经加入版本控制的文件夹svn export test test_bak svn rm test svn commit -m &quot;delete test&quot; mv test_bak test svn propset svn:ignore &apos;test&apos; . svn update svn commit -m &quot;add a ignore dir&quot; 如果想要忽略一个目录下多个文件夹的话，需要有一点点技巧，如下 svn propset svn:ignore &apos;test test1 test2&apos; . 即每一个文件夹要单独另起一行","tags":[{"name":"SVN","slug":"SVN","permalink":"https://www.devzou.com/tags/SVN/"}]},{"title":"Jekyll的中的代码高亮","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-04-22-highlight-of-jekyll/","text":"代码高亮方式选择1.小片段直接使用“ ` ”符号包含起来，或者使用一个tab直接利用markdown来做高亮 2.Pygments渲染Jekyll通过Pygments可以直接处理代码高亮 在Github Pages的文档里，也提到了这个方式，但是总觉得这样有点不是很舒服，打破了markdown的格式 3.gist嵌入方式这个方式使用了一个插件，而且gist也得管理，增大了开销…… 4.js和css处理这个方式使用了google-code-prettify来渲染代码高亮，本身库并不是很大，使用方便，最后我也选择了这个 Prettify使用1.下载代码直接到google-code-prettify官网下载代码，然后将它们放到项目下 2.包含css和js官网提到了可以直接包含run_prettify.js的方式，这个会导入远程库，我选择了自己导入，如下 &lt;link rel=&quot;stylesheet&quot; href=&quot;/public/js/prettify/prettify.css&quot;&gt; &lt;script src=&quot;/public/js/prettify/prettify.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;pre&quot;).addClass(&quot;prettyprint linenums&quot;); prettyPrint(); }); &lt;/script&gt; 这里导入了css和js后，就可以直接用markdown的tab的方式来导入代码段了 3.更换主题默认主题不是很好看，只要更换prettify.css即可更换样式，可以到这里下载自己喜欢的主题css即可","tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://www.devzou.com/tags/Jekyll/"}]},{"title":"让git push命令不再需要密码","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-04-22-ignore-password-in-git-push/","text":"最近利用jekyll写博客，为的就是博客管理方便，但是在上传博客的时候使用git push命令每次都得输入github帐号和密码特别的不方便，于是就搜了一下。 在这篇文章里提到，GitHub获得远程库时，有ssh方式和https方式。 两个方式的url地址不同，认证方式也不同。使用ssh时保存密钥对以后可以不再输入帐号密码，而https却不能。所以如果想要不再输入帐号密码，一种方式就是在git clone的时候使用ssh方式，另一种方式就是去修改已有项目.git目录下的config文件中的url，如下： [remote &quot;origin&quot;] url = git@github.com:suyan/suyan.github.io.git fetch = +refs/heads/*:refs/remotes/origin/*","tags":[{"name":"Git","slug":"Git","permalink":"https://www.devzou.com/tags/Git/"}]},{"title":"给Git或者APT设置goagent代理","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-05-20-set-proxy-for-git-or-apt/","text":"安装goagent这个教程网上很多，放狗一搜即可。 不过网上goagent教程里讲的大部分是给浏览器用的。其实goagent是监听了本地的8087端口，其实任何程序都可以利用这个端口，只要设置好即可。 设置git代理直接在终端输入 export https_proxy=&quot;127.0.0.1:8087&quot; export http_proxy=&quot;127.0.0.1:8087&quot; git config --global http.sslVerify false 这样git clone就是走代理了，其实这个设置完以后apt-get的操作也是通过代理的了 设置apt-get代理上面的方法也可以直接使apt代理，如果不想设置环境变量，可以使用下面命令 sudo apt-get -o Acquire::http::proxy=&quot;http://127.0.0.1:8087/&quot; update","tags":[{"name":"Git","slug":"Git","permalink":"https://www.devzou.com/tags/Git/"}]},{"title":"从Bash切换到Zsh","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-05-22-change-to-zsh/","text":"安装Zsh我在mac下，使用port install zsh就好了，因为mac自带的Zsh比较老，然后使用chsh -s /opt/local/bin/zsh搞定 安装Zsh配置文件克隆配置 git clone git://github.com/sjl/oh-my-zsh.git ~/.oh-my-zsh 移动到根目录 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 使用Zsh使用Zsh的九个理由写了Zsh最令人激动的理由","tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.devzou.com/tags/Mac/"}]},{"title":"安装MySQL和MongoDB的WEB管理界面","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-05-23-install-mysql-and-mongo-web-admin/","text":"MySQL管理界面这个没多少选择，大部分人都安装的是phpmyadmin，而且简单方便，在ubuntu下，只要 apt-get install phpmyadmin 设置也不需要，只要在安装过程中输入mysql密码即可，访问http://localhost/phpmyadmin即可 MongoDB管理界面MongoDB的工具还比较多，没有一个能够统一全部工具的，不过推荐使用RockMongo，这个工具确实速度很快，而且很顺手，支持中文 到RockMongo下载安装包 如果Apache有根目录，移动到根目录下，否则自己建立一个/etc/apache2/conf.d/rockmongo.conf，写入 Alias /rockmongo /var/www/rockmongo &lt;Directory /var/www/rockmongo&gt; Options FollowSymLinks DirectoryIndex index.php &lt;/Directory&gt; 然后要安装php-mongo模块 apt-get install php5-mongo 修改php配置文件 echo &quot;extension=mongo.so&quot; &gt;&gt; /etc/php5/apache2/php.ini 然后访问http://localhost/rockmongo即可，帐号密码都是admin","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.devzou.com/tags/MongoDB/"},{"name":"Linux","slug":"Linux","permalink":"https://www.devzou.com/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.devzou.com/tags/MySQL/"}]},{"title":"我与工具","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-08-04-something-about-tools-i-used/","text":"“工欲善其事，必先利其器”—XXX 作为一个标准的工科男，我对于自己使用的工具的追求还是比较严格的，一直都希望自己使用的工具按自己的标准去工作，并且是最顺手的 编辑器作为一个IT男的标配，从Vim,Emacs到各种IDE，一直有着持续不断的月经战 自己也曾经捣鼓过Vim和Emacs，可以说过程是心酸的，结果更是心酸的 喜欢Vim即开即用的速度，又喜欢Emacs灵便的快捷键，速度和功能似乎从来都是背向而行的，而且都有个共性问题，配置复杂（追求各种自定义），而且还不能同步在不同的机器上 直到我遇到了Sublime，我惊讶于它不仅简单易用，而且各个部分都特别的人性化。它就如它的名字那样绚丽 我把它的快捷键改成了类emacs的（本来在mac上编辑器快捷键就挺像emacs），也没多花多大功夫，而且直接从以前win平台把setting-user拷贝过来就可以了。它统一使用json格式来配置功能，非常易用。 除了编辑器外，还有各种各样的软件和工具，我都曾自己折腾过。直到最后出来一个对的上口味的软件，终结了我之前所有做过的自定义 工具本身是用来提升自己工作的效率的，更多的精力应该放在工作上。好的工具不需要太多修改就可以方便使用，当一个工具难用到爆的时候，绝对会有颠覆着出现 这个话题似乎能写不少东西，把我折腾过的软件都一一列举一下","tags":[{"name":"Tool","slug":"Tool","permalink":"https://www.devzou.com/tags/Tool/"}]},{"title":"我与工具--阅读和知识管理","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-08-06-tools-of-reading/","text":"1. 信息来源在这个信息爆炸的时代，我们阅读的来源实在太多了，以至于超过了我们能处理的极限。很好的筛选信息是很重要的，只阅读对自己当前最重要的文章。 FeedlyFeedly 不用多说，作为 Google Reader 的替代者，功能上来说基本都满足了订阅RSS阅读的需求。为了筛选内容，可以考虑只读阅读人数多的文章。 RSS订阅包括了一些个人博客、媒体，比如: V2EX Hacker News 50 Techmeme 36Kr 虎嗅 TwitterTwitter 上关注了挺多开发者和科技媒体，偶尔关注一下最新动态。 知乎日报每天一些精选内容，挑感兴趣的读一下。 微信微信上公众帐号经常有不错的文章，值得阅读。 微信公众帐号虽然关注了挺多，但是其实最后也只看这么几个人的: 小道消息 道哥的黑板报 MacTalk By 池建强 人生如戏 鬼脚七 2. 稍后读稍后读工具之前还在用信息源的收藏，后来发现那些收藏既不容易翻阅，又不容易搜索，所以后来统一到了一个软件下。 PocketPocket 拥有比较广的支持，例如 Feedly, Twitter 和知乎日报都支持了 Pocket 收藏。只有微信不支持，不过没有关系，微信里点在 Safari 中打开，然后分享到 Pocket 即可。 3. 信息归档稍后读的最大问题就是 Read It Never。不过这个没有问题，本来我们要做的也是阅读 or 归档。由于信息实在太多，有些内容又不是想现在读，合理的归档可以有助于以后再搜索。不过我们必须保证 Pocket 的尽量简洁，每天晚上尽量将今天收藏的文章归档。 EvernoteEvernote 是我发现当前的最佳归档工具。它的检索非常快，而且网页版插件也非常好用。","tags":[{"name":"Tool","slug":"Tool","permalink":"https://www.devzou.com/tags/Tool/"}]},{"title":"更新前端框架到Bootstrap3","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-08-28-change-bootstrap-to-3/","text":"Bootstrap3出来大概有几天时间了，据说他们宣称这个版本是移动优先，而且还把控件给排扁了。 前几天稍微看了一下他们的新文档，感觉确实变化挺多，但是对于熟悉第二版的开发这者来说，稍微看一下基本就了解了。这个框架使用的人真的是奇多，正式版刚发布的那天就有人提醒我，我github上头一个基于Bootstrap的自动提醒控件应该升级成v3的了，而且还给我发来了代码，这效率…… 这个博客当初是决定了以后常用的，所以代码和文件布置的还算合理，从v2升级到v3基本不费什么功夫。就是换一下css和js，改改class的事情。总共时间1个小时吧，加上写这个总结，接下来说说主要关心修改什么内容。 1.bootstrap文件更新看一下新的bootstrap文件 . ├── css │ ├── bootstrap.css │ └── bootstrap.min.css ├── fonts │ ├── glyphicons-halflings-regular.eot │ ├── glyphicons-halflings-regular.svg │ ├── glyphicons-halflings-regular.ttf │ └── glyphicons-halflings-regular.woff └── js ├── bootstrap.js └── bootstrap.min.js css和js还是老样子，只要覆盖原来的就行了，这里关键说一下fonts里头的东西。 以前版本里面，图标都是真的图片做成的，他们都被集合在之前的glyphicon-halflings.png里头，用哪个根据图片位置相对显示哪个。这种方式导致的问题就是在分辨率变法的时候，图片要么失真要么显示有问题，尤其是retina屏下头。 这个问题在v2阶段就有解决办法，只不过不是官方发布的，而是由Font Awesome提供了基于字体的图标，这样形成的图标是矢量图，可以面对各种各样的分辨率。我找到一个对它进行分析的文章，链接在此。 现在v3版本里面也有了类似的解决方案，对我来说用原来的就行，没有影响。 2.网格布局修改网格布局由原来的span变成了现在超级难看的col-xx-xx，而且看起来不那么简约时尚国际范了。不过稍微细读一下文档会发现，这种略微复杂的控制方式，反而对响应式布局的控制变得非常精细，妈妈再也不用担心分辨率改了以后还得修改css文件了！ 通过&lt;div class=&quot;col-xs-12 col-md-8&quot;&gt;类似这样的并列方式，就可以控制不同分辨率下控件的现实形式。对我来说没啥作用，因为默认的布局方式就够用了，直接把span都换成col-md，搞定！ 这里我用md是因为我这个博客页面不是很丰富，太宽不好看，而且我还把bootstrap.css下1200那个最大值给调成了2000。也就是说，你想看到col-lg的布局，得屏幕分辨率达到2000xXXX以上了…… 3.控件修改这里大概用了一些简单的控件，比如右边的affix，以及顶上的navbar，还有下面的pagination，还有分类页面的collapse。变化仅仅是改了一下class的名字，逐个击破就好了 4.一些想法Bootstrap的出现，一定程度上统一了前端杂乱的氛围，简化了开发流程，降低了开发难度，简直就是老少皆宜。对于不是做前端，却要偶尔写前端的孩纸，指明了一条道路。对于做前端的开发者来说，又有了一个较为标准化的学习对象，可以加快学习速度，少走一些弯路。 现在阅读字体和风格都不怎么舒服，待优化，下次再弄吧。","tags":[{"name":"Blog","slug":"Blog","permalink":"https://www.devzou.com/tags/Blog/"}]},{"title":"在ubuntu下搭建pptp vpn服务器","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-12-11-deploy-pptp-vpn-in-ubuntu/","text":"pptp配置安装pptp用ubuntu就是安装东西快 sudo apt-get -y update sudo apt-get -y install pptpd 修改配置脚本配置一下dns cat &gt;/etc/ppp/options.pptpd &lt;&lt;END name pptpd refuse-pap refuse-chap refuse-mschap require-mschap-v2 require-mppe-128 ms-dns 8.8.8.8 ms-dns 8.8.4.4 proxyarp lock nobsdcomp novj novjccomp nologfd END 说明 name pptpd（pptpd服务名，可以随便填写。） refuse-pap（拒绝pap身份认证模式。） refuse-chap（拒绝chap身份认证模式。） refuse-mschap（拒绝mschap身份认证模式。） require-mschap-v2（在端点进行连接握手时需要使用微软的 mschap-v2 进行自身验证。） require-mppe-128（MPPE 模块使用 128 位加密。） ms-dns 8.8.8.8 (ppp 为 Windows 客户端提供 DNS 服务器 IP 地址。) proxyarp (建立 ARP 代理键值。) nodefaultroute（不替换默认路由） debug（开启调试模式，相关信息记录在 /var/logs/message 中。） lock（锁定客户端 PTY 设备文件。） nobsdcomp (禁用 BSD 压缩模式。) 还有ip cat &gt; /etc/pptpd.conf &lt;&lt;END option /etc/ppp/options.pptpd logwtmp localip 192.168.2.1 remoteip 192.168.2.10-100 END 增加路由转发ipv4转发cat &gt;&gt; /etc/sysctl.conf &lt;&lt;END net.ipv4.ip_forward=1 END sysctl -p 修改iptables备份当前iptables iptables-save &gt; /etc/iptables.down.rules 修改iptable NAT转发 iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -o eth0 -j MASQUERADE 设置MTU iptables -I FORWARD -s 192.168.2.0/24 -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1300 保存新iptables iptables-save &gt; /etc/iptables.up.rules 重启后继续有效 cat &gt;&gt;/etc/ppp/pptpd-options&lt;&lt;EOF pre-up iptables-restore &lt; /etc/iptables.up.rules post-down iptables-restore &lt; /etc/iptables.down.rules EOF 增加用户增加帐号密码都是test的用户 cat &gt;/etc/ppp/chap-secrets &lt;&lt;END test pptpd test * END 重启服务/etc/init.d/pptpd restart netstat -lntp 自动脚本wget -c https://github.com/suyan/scripts/raw/master/Setup/pptp.sh 问题logwtmp.so 版本问题如果链接中断，并且出现下面问题： Plugin /usr/lib/pptpd/pptpd-logwtmp.so is for pppd version 2.4.5, this is 2.4.6 在 /etc/pptpd.conf 文件中把 logwtmp 删掉就好了。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.devzou.com/tags/Linux/"}]},{"title":"Mac下用brew搭建PHP(LNMP/LAMP)开发环境","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2013-12-11-lamp-in-mac/","text":"Brewbrew对于mac，就像apt-get对于ubuntu，安装软件的好帮手，不能方便更多… brew的安装方式如下： ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go/install)&quot; brew常用选项 brew install xxx brew uninstall xxx brew list brew update xxx Apache || Nginx (只需要装一个)ApacheApache的话使用mac自带的基本就够了，我的系统是10.9，可以使用以下命令控制Apache sudo apachectl start sudo apachectl restart sudo apachectl stop 唯一要改的是主目录，mac默认在home下有个Sites（站点）目录，访问路径是 http://localhost/~user_name 这样不太容易访问，修改/etc/apache2/httpd.conf内容 DocumentRoot /Users/username/Sites &lt;Directory /Users/username/Sites&gt; Options Indexes MultiViews # apache 2.2 # AllowOverride All # Order allow,deny # Allow from 127.0.0.1 # apache 2.4 Require local &lt;/Directory&gt; 这样Sites目录就是网站根目录了，通过http://localhost就可以访问了。 常用命令123sudo apachectl start # 启动apachesudo apachectl stop # 关闭apachesudo apachectl restart # 重启apache 设置vhost设置vhost可以很方便的进行站点调试，尤其是对于需要在根目录运行的站点。推荐 VirtualHostX. 设置方法是： 1sudo vi /etc/apache2/extra/httpd-vhosts.conf 然后输入： 123456789&lt;Directory \"/pash/to/site\"&gt; Allow From All AllowOverride All Options +Indexes&lt;/Directory&gt;&lt;VirtualHost *:80&gt; ServerName \"site.test\" DocumentRoot \"/path/to/site\"&lt;/VirtualHost&gt; 这么设置会有个问题，默认的http://localhost会被转到这儿来，所以专门再设置一下localhost的host就好了。 1234&lt;VirtualHost *:80&gt; ServerName localhost DocumentRoot /path/to/root&lt;/VirtualHost&gt; 然后把host文件改一下，把刚刚设置的ServerName改到本地就好了。 1sudo vi /etc/hosts 写入： 1127.0.0.1 site.test Nginx要使用Nginx也比较方便，首先安装 brew install nginx 启动关闭Nginx的命令如下（如果想要监听80端口，必须以管理员身份运行） #打开 nginx sudo nginx #重新加载配置|重启|停止|退出 nginx nginx -s reload|reopen|stop|quit #测试配置是否有语法错误 nginx -t 配置Nginx cd /usr/local/etc/nginx/ mkdir conf.d 修改Nginx配置文件 vim nginx.conf 主要修改位置是最后的include worker_processes 1; error_log /usr/local/var/log/nginx/error.log warn; pid /usr/local/var/run/nginx.pid; events { worker_connections 256; } http { include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/var/log/nginx/access.log main; port_in_redirect off; sendfile on; keepalive_timeout 65; include /usr/local/etc/nginx/conf.d/*.conf; } 修改自定义文件 vim ./conf.d/default.conf 增加一个监听端口 server { listen 80; server_name localhost; root /Users/username/Sites/; # 该项要修改为你准备存放相关网页的路径 location / { index index.php; autoindex on; } #proxy the php scripts to php-fpm location ~ \\.php$ { include /usr/local/etc/nginx/fastcgi.conf; fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; } } 这个时候还不能访问php站点，因为还没有开启php-fpm。 虽然mac 10.9自带了php-fpm，但是由于我们使用了最新的PHP，PHP中自带php-fpm，所以使用PHP中的php-fpm可以保证版本的一致。 这里的命令在安装完下一步的php后再执行 sudo nginx sudo php-fpm -D PHPPHP在mac下默认安装了，但是不好控制版本，利用brew可以再mac下安装最新版本，甚至是多个版本，我装了php5.5 brew update brew tap homebrew/dupes brew tap josegonzalez/homebrew-php # brew install php55 --with-fpm #Nginx brew install php55 #Apache 然后修改php的cli路径和apache使用的php模块。在.bashrc或.zshrc里头加以下内容 #export PATH=&quot;$(brew --prefix josegonzalez/php/php55)/bin:$PATH&quot; export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 就用刚刚安装的php代替了系统默认cli的php版本。然后在/etc/apache2/httpd.conf下增加 LoadModule php5_module /usr/local/Cellar/php55/5.5.8/libexec/apache2/libphp5.so 这样就对apache使用的php版本也进行了修改。 后面会用到mongo和mysql，所以可以直接利用下面命令安装php模块，其他模块也类似 #brew install php55-mysql #这个已经不需要再安装了 brew install php55-mongo MySQLmac不自带mysql，这里需要重新安装，方法依然很简单 brew install mysql unset TMPDIR mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew --prefix mysql)&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp sudo chown -R your_user /usr/local/var/mysql/ 第一句是安装，后面的是确保正常使用。然后是启动命令 mysql.server start 最好给mysql设个密码，方法如下 mysqladmin -u root password &apos;xxx&apos; 如果想修改mysql的配置，在/usr/local/etc下建立一个my.cnf，例如增加log [mysqld] general-log general_log_file = /usr/local/var/log/mysqld.log MongoDBMongoDB可以说是最简单的一个，直接执行 brew install mongodb 启动方法 mongod --fork PHPMyAdminphpmyadmin几乎是管理mysql最容易的web应用了吧，每次我都顺道装上。 去官网下载最新的版本 解压到~/Sites/phpmyadmin下 在phpmyadmin目录下创建一个可写的config目录 打开http://localhost/phpmyadmin/setup，安装一个服务，最后保存（这里只需要输入帐号密码就够了） 将config下生成的config.inc.php移到phpmyadmin根目录下 删除config 这样就装好了，虽然可能有点小复杂，但是来一次就习惯了。 这里很可能会遇到2002错误，就是找不到mysql.sock的问题，用下面方法解决 sudo mkdir /var/mysql sudo ln -s /tmp/mysql.sock /var/mysql/mysql.sock RockMongoRockMongo是MongoDB很好用的一个web应用，安装也很容易 去官网下载最新版本 解压到~/Sites/rockmongo下 运行http://localhost/rockmongo即可 把 site 放在 Dropbox 文件夹下123ln -s ~/Dropbox/sitename ~/Sites/sitenamechmod a+rw ~/Dropboxchmod a+rw ~/Dropbox/sitename 完成这样就在mac下配置好一个php开发环境了，enjoy it! 参考 Hot to install nginx, PHP-fpm 5.5.6, mongo and MySql on mac with homebrew Mac OSX 10.9搭建nginx+mysql+php-fpm环境","tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.devzou.com/tags/Mac/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.devzou.com/tags/MongoDB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"在Github上搭建Jekyll博客和创建主题","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2014-02-12-how-to-deploy-a-blog-on-github-by-jekyll/","text":"之前本来想展开写的，后来发现Jekyll官网的教程已经非常完善了就没有多写，所以只有这篇。但是过了这么久，发现很多人还是不清楚怎么搭建，所以这里打算详细写一下，并且把自己对图片的解决方案以及主题的创建步骤也一并写下。 本篇主要谈如何搭建，不再讲为什么用它们。 说明：本篇用到的代码中，为了防止解析冲突，一律多了\\这个来防止被误解析 创建一个库在Github上新开一个库，名字叫做username.github.io，然后当别人在地址栏输入相应url的时候就可以访问进来了。 在这个库中完全可以只上传一个index.html，来讲自己要写的东西写进去，但是这样会丧失很多灵活性，所以需要Jekyll的帮助来创建自己的博客。 设定目录结构把自己的库clone到本地来，建立如下目录结构： 1234567891011121314151617181920212223242526272829303132├── CNAME├── README.md├── _config.yml├── _includes│ ├── disqus.html│ ├── footer.html│ ├── googleanalytics.html│ ├── header.html│ └── navside.html├── _layouts│ ├── base.html│ ├── book.html│ ├── page.html│ └── post.html├── _posts│ ├── Book│ ├── Life│ ├── Resource│ ├── Technology│ └── Tool├── index.html├── pages│ ├── about.html│ ├── archive.html│ └── atom.xml├── public│ ├── css│ ├── fonts│ ├── img│ ├── js│ └── upload└── sitemap.txt 这个目录结构是我自己设定的，也可以有不同的目录结构，看官网。 接下来我主要解释这里面每一个目录的功能。 配置文件_config.yml里写有整个站点的主要配置项，我的如下： 12345678910111213permalink: /:year/:month/:day/:title.html #博文的固定链接paginate: 10 #分页时每页博文数量author: #自定义常亮 name: 闫肃 email: yansu0711@gmail.com link: http://yansu.orgtitle: 闫肃的博客 #自定义常量locals: #自定义常量 tags: 标签 about: 关于active: 技术 #自定义常量subscribe_rss: /pages/atom.xml #订阅地址markdown: redcarpet #markdown解释器 这里的自定义常量可以在模板中使用，以后有修改的时候就不需要跑去改代码了。尤其是对一些私人的选项，可以在这里定义。现在我的博客中出了disqus和googleanalytics外都直接在这里设定就好了。 域名配置CNAME这个文件写明了这个站点的域名，如果不喜欢username.github.io的话，可以像我一样改掉 1yansu.org 改法只要在这个文件中写入域名就可以了。不过你需要去域名服务商那里设定域名解析规则。 只要把主机记录为@,www的记录值写成username.github.io就好了。 博客存放_posts下的所有目录中的所有博客，都会被Jekyll处理成为静态的html文件，然后放在_site下。我这里没有_site目录，是因为我在.gitignore文件中把这个目录屏蔽掉了，它不会上传到Github上。 123_site/_drafts/.DS_Store 以上是我的.gitignore文件内容。 在_posts下的符合YYYY-MM-DD-xxxxxx.md的文件，都会被Jekyll认定为博客内容。我在_posts下又新建了一些文件夹，主要是方便自己本地管理博客。 在上述这些文件中，必须先定义一些配置项，例如这篇博客的md文件中，开头是这样的： 1234567layout: post #这个博客的布局文件title: 在Github上搭建自己的Jekyll博客 #博客标题category: 工具 #博客分类tags: Jekyll #博客标签keywords: Jekyll,Github #自定义常量description: #自定义常量 除了自定义常量外的必须包含进去，自定义变量在这个布局中可以访问。 模版文件剩余的目录，基本都属于模板文件了，我解释一下各自的作用： _includes 可以在模板中随时包含的文件 _layouts 布局文件，在博客头配置中可以选择 pages 站内固定的页面 public 公共资源，包括js,css,img等，还有我博客中调用的图片，我都放这里 index.html 站点的首页，整个站的入口文件 sitemap.txt 给搜索引擎看的，如何爬取这个站 创建自己的主题上面讲了如何布局好站内文件结构，接下来主要就是如何创建一个自己的主题了。 布局文件是整个主题最重要的文件，这些文件告诉Jekyll如何去形成一个html页面。 首先我说一下我最基础的page.html文件，因为它决定了入口文件index.html的布局。 12345678910111213141516layout: base&lt;div class=\"row\"&gt; &lt;div class=\"col-md-12 aside3-title\"&gt; &lt;br&gt; &lt;h2 id=\"#identifier\"&gt;&#123;\\&#123; page.title &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-md-12 aside3-content\"&gt; &lt;div id=\"page-content\"&gt; &#123;\\&#123; content &#125;&#125; &lt;/div&gt; &lt;hr&gt; &#123;\\% include disqus.html %&#125; &lt;/div&gt;&lt;/div&gt; 从这里可以看到这个文件写起来一点都不复杂，但是为什么开头还有个layout呢？因为它也不是最基本的布局文件，最基本的是base.html，我们看一下它的内容。 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &#123;\\% include header.html %&#125;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &#123;\\% include navside.html %&#125; &lt;div class=\"col-md-8 col-lg-8 col-sm-12 col-xs-12 aside3\"&gt; &lt;div id=\"container\"&gt; &lt;div id=\"pjax\"&gt; &#123;\\&#123; content &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;\\% include footer.html %&#125; &#123;\\% include googleanalytics.html %&#125;&lt;/body&gt;&lt;/html&gt; 这个文件就更像一个HTML文件了，用PHP或者Python写过web应用的人看到{\\% %}这样的标签应该不陌生，这不就是模板标签嘛。其实Jekyll也是借用了一下模板系统的，官网说明在这里，看到开头第一句讲的它用了Liquid了吧。如果Jekyll的文档不能满足你的话，可以去Liquid那里查查。 我解释一下base.html中几个标签的功能。 {\\% include header.html %} 从_includes中把header.html包含进来放在这里 {\\% include navside.html %} 同上 {\\{ content }} 这句的作用是将继承这个Layout的文件中的代码，放在这里 所以再看page.html文件就很容易了，它就是把配置项下面的内容，填补到base.html中的{\\{ content }}处形成了一个文件。那么page.html中的{\\{ content }}做什么用呢？因为别人也可以以page.html来作为自己的布局文件。 入口文件index.html就是这么干的： 123layout: pagetitle: 首页... 这里看到选择了page作为布局文件，那么title干嘛用的呢？其实它是在被包含的header.html中被用到了。来看看header.html怎么写的： 1234567891011&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&#123;\\&#123; page.title &#125;&#125; | &#123;\\&#123; site.title &#125;&#125;&lt;/title&gt;&lt;meta name=\"author\" content=\"&#123;&#123; site.author.name &#125;&#125;\"&gt;&#123;\\% if page.keywords %&#125; &lt;meta name=\"keywords\" content=\"&#123;&#123; page.keywords &#125;&#125;\"&gt;&#123;\\% endif %&#125;&#123;\\% if page.description %&#125; &lt;meta name=\"description \" content=\"&#123;&#123; page.description &#125;&#125;\"&gt;&#123;\\% endif %&#125;... 这里又使用了一些新标签——{\\{ }\\}，这个标签就是用来书写变量的，通过在配置处配置变量，或者使用系统的自定义变量，可以轻松改变页面内的一些元素或者内容。 系统变量查询可以去这里 其实整个主题书写就是这么简单，如果有不清楚的可以再看看官网的文档。动一动手就非常明白了。 插入图片很多人感觉用Jekyll最不方便的就是插入图片了，其实我也是这么觉得的。所以只能自己去想些办法。 图片统一存放图片我都放在了/public/upload下，所以我在插入图片的时候只要用![xxx](http://7u2ho6.com1.z0.glb.clouddn.com/xxx)就可以了。 方便的图片导入导入图片的方式是我将upload文件夹做了个软连接，放到mac的dock上就行了，有图片要用的时候直接往里面一拖。 方便的截图很多时候图片都是现截取的，比如用QQ的截图工具，或者系统的截图工具，但是他们截取完都存放在了user/Pictures里面，来回移动太累了。我这里介绍一个Mac下的一个工具——Trickster，看图 这个工具可以看到刚刚修改过的图片，而且还有一个收藏的文件夹，我每次截取完图以后，从左边往右边一拖，然后在markdown中就可以继续书写了。一点都不耗时。 本地预览及提交本地预览自己的修改很容易，只要进入username.github.io目录，执行 1jekyll serve 然后访问http://localhost:4000就OK了，安装Jekyll的方式自行谷歌吧… 自己预览过没有问题以后，就提交到服务端吧，Git三步走 123git add xxxgit commit -m &quot;xxx&quot;git push 其他我觉得自己的这个主题设定的算是比较好修改和移植的了，如果大家有什么问题，可以尽管问。 另外一些特别的功能，比如三栏、评论、谷歌分析，这些都不难，相信你稍微打开Github读一下这个主题的代码就很快明白了。 代码地址戳这里","tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://www.devzou.com/tags/Jekyll/"}]},{"title":"用Xdebug和Sublime调试PHP代码","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2014-03-20-php-debug-with-xdebug/","text":"xdebug是php调试的好帮手，sublime是php编写的好帮手。这里只说如何配置，默认读者会用sublime和xdebug 安装xdebug在mac下非常方便： brew install php55-xdebug 然后进行配置，在/usr/local/etc/php/5.5/conf.d/ext-xdebug.ini中添加 xdebug.remote_enable=1 xdebug.remote_handler=dbgp xdebug.remote_host=127.0.0.1 xdebug.remote_port=9000 xdebug.remote_log=&quot;/var/log/xdebug/xdebug.log&quot; 重启apache sudo apachectl restart 配置sublime要调试某一个项目，首先得把这个项目在sublime下保存成一个project sublime-&gt;project-&gt;save project as ... 然后用package control安装xdebug client 接下来配置项目 sublime-&gt;project-&gt;edit poject 配置文件类似以下内容： { &quot;folders&quot;: [ { &quot;follow_symlinks&quot;: true, &quot;path&quot;: &quot;.&quot; } ], &quot;settings&quot;: { &quot;xdebug&quot;: { &quot;url&quot;: &quot;http://my.local.website/&quot;, } } } 其中url是项目所在url，记得在hosts里头将这个url指向127.0.0.1，还有在apache的virtualhost里将其指向项目根目录 这样就OK了，准备开启调试吧 开启调试开启调试方式也比较简单，在想要加断点的地方右键 xdebug-&gt;Add/Remove breakpoint 这样项目在运行到本行的时候就会停止下来 然后开始调试，在菜单栏选择 tools-&gt;xdebug-&gt;start debugging(launch browser) sublime会自动打开浏览器，进入配置时写的网站链接，进行调试 调试中所用的功能可以在调试文件中右键查看之 可能问题无法跟踪断点这可能是xdebug端口被占用，按Ctrl+`或者菜单栏View-&gt;show Console查看错误信息，有可能是xdebug端口已经被占用的缘故。 在sublime xdebug中关闭调试，或者重启sublime可以解决这个问题。 参考 Debugging with Xdebug and Sublime Text 3","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"在Mac下安装使用Docker","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2014-04-10-install-docker-in-mac/","text":"安装Docker暂时并不支持原生的Mac系统，所以Mac下的Docker实际上是依赖一个很小的linux虚拟机来实现的。 安装VirtualboxVagrant依赖现有的虚拟机软件来管理虚拟机，如Virtualbox, Vmware Fusion, Parallel Desktop等，其中最方便的是VirtualBox，所以我选择了Virtualbox。 下载地址在https://www.virtualbox.org/wiki/Downloads。下载好后直接安装。 安装Boot2DockerBoot2Docker是帮助控制虚拟机中Docker的工具，它会下载一个安装好docker的虚拟机，并控制其实现docker功能。 在mac下安装boot2docker只要执行 brew install boot2docker 即可。 安装docker client要想在mac下直接执行docker命令，需要安装一个适合mac的docker client，安装方法如下 # Get the docker client file DIR=$(mktemp -d ${TMPDIR:-/tmp}/dockerdl.XXXXXXX) &amp;&amp; \\ curl -f -o $DIR/ld.tgz https://get.docker.io/builds/Darwin/x86_64/docker-latest.tgz &amp;&amp; \\ gunzip $DIR/ld.tgz &amp;&amp; \\ tar xvf $DIR/ld.tar -C $DIR/ &amp;&amp; \\ cp $DIR/usr/local/bin/docker ./docker # Set the environment variable for the docker daemon export DOCKER_HOST=tcp://127.0.0.1:4243 # Copy the executable file sudo cp docker /usr/local/bin/ 这样就有一个docker命令了 使用使用docker安装需要先启动boot2docker虚拟机 # Initiate the VM boot2docker init # Run the VM (the docker daemon) boot2docker up # To see all available commands: boot2docker 之后就可以使用docker命令了 docker version 参考 How To Install Docker On Mac OS X boot2docker","tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.devzou.com/tags/Mac/"},{"name":"Docker","slug":"Docker","permalink":"https://www.devzou.com/tags/Docker/"}]},{"title":"在Mac下安装使用Vagrant","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2014-04-10-install-vagrant-in-mac/","text":"安装安装VagrantVagrant的旧版本是可以通过gem来安装的，但是由于依赖实在太多，官方放弃了这种安装方式，建议下载官方安装包来安装。 下载地址在http://www.vagrantup.com/downloads。下载好pkg包后，点击安装即可。 安装VirtualboxVagrant依赖现有的虚拟机软件来管理虚拟机，如Virtualbox, Vmware Fusion, Parallel Desktop等，其中最方便的是VirtualBox，所以我选择了Virtualbox。 下载地址在https://www.virtualbox.org/wiki/Downloads。同样下载好后直接安装。 使用下载启动Box在Vagrant中，box是一种打包好的镜像，通过这个镜像，可以生成相应的虚拟机。box可以通过官方网站下载，也可以自己制作，在团队内分享。 官方的Box可以在创建时自动下载。例如以下步骤 cd ~/Documents/Vagrant/Ubuntu # 进入一个vagrant虚拟机目录，一个目录管理一个虚拟机 vagrant init hashicorp/precise32 # 创建一个ubuntu的虚拟机 vagrant up # 启动这个虚拟机 通过这个步骤，vagrant会去box列表中找hashicorp/precise32这个镜像，如果没有就去官方下载。Box被保存在~/.vagrant下。通过命令 vagrant box list 可以查看已经下载的box。如果想以这个box再建立一个虚拟机，只要再创建一个目录，例如~/Documents/Vagrant/Ubuntu32，然后执行 vagrant init hashicorp/precise32 即可。 操作虚拟机操作虚拟机时，必须进入刚刚建立的目录中去，这个目录中必须含有init命令建立的Vagrantfile文件。常用命令有 $ vagrant init # 初始化 $ vagrant up # 启动虚拟机 $ vagrant halt # 关闭虚拟机 $ vagrant reload # 重启虚拟机 $ vagrant ssh # SSH 至虚拟机 $ vagrant status # 查看虚拟机运行状态 $ vagrant destroy # 销毁当前虚拟机 共享文件夹通过Vagrant建立的虚拟机和Mac共享文件非常容易，虚拟机中/vagrant目录会映射到我们本地虚拟机目录中。例如 cd ~/Documents/Vagrant/Ubuntu vagrant up vagrant ssh cd /vagrant ls 这个时候，我们会看到，这里显示的文件和~/Documents/Vagrant/Ubuntu下是一样的。 共享Box如果只有上述功能的话，那么Vagrant的作用就不是那么杀手级了。通过命令 vagrant package 可以将一个虚拟机打包成Box，供别人使用。别人只要用打包的box来创建一个虚拟机即可，例如 vagrant box add myubuntu ~/Documents/Vagrant/Ubunutu/ubunut.box 参考 Vagrant Docs 使用 Vagrant 打造跨平台开发环境","tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.devzou.com/tags/Mac/"},{"name":"Vagrant","slug":"Vagrant","permalink":"https://www.devzou.com/tags/Vagrant/"}]},{"title":"使用Dropzone和七牛云存储来优化博客图床","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/2015-01-10-use-dropzone-and-qiniu-to-store-blog-images/","text":"设置七牛帐号 七牛是国内口碑不错的一个云存储为主的公司。它的特点应该就在图片存储上，有非常方便的上传SDK和图片处理流，用来作为博客图床非常合适，而且价格不贵，每月有免费的10G流量。 去七牛注册帐号 刚刚创建的帐号是测试帐号，完成个人认证就可以成为标准帐号，获得10G的存储空间和各10G的上传下载流量。 创建一个空间 创建空间也比较容易，记得选择公开空间。 设置Dropzone Dropzone是我很早就非常喜欢的一个软件。它通过拖拽的方式，增强了文件的处理流程。一直懒得给它开发插件，没想到七牛的SDK如此好用，所以今天折腾了一下搞定了。 下载软件 这个软件可以在App Store上直接购买，但是买到的是功能受限的，它不能操作外部文件。不过没有关系，再从官网上下载非沙箱版本，然后覆盖掉Application文件夹下的即可。 安装Qiniu插件 我把这个插件放到了Github上，戳这里下载。 安装插件 下载后的是一个zip包，把这个包解压以后双击安装即可。 启用插件 从增加列表中选择我们安装好的七牛插件。 然后填写配置： server: 七牛上的空间名 username: 七牛的access_key password: 七牛的secret_key remote path(可选): 本地同步图片的目录，如果你希望本地也存一份图片，选一个地址即可 root url: 七牛的公共链接根目录 其他建议利用Dropzone还有很多可利用的技巧，例如增加一个ImageOptim应用来压缩图片，然后再进行上传。 对于临时图片，可以直接上传到Imgur获得链接。","tags":[{"name":"Blog","slug":"Blog","permalink":"https://www.devzou.com/tags/Blog/"}]},{"title":"让git push命令不再需要密码","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/git/2013-04-22-ignore-password-in-git-push/","text":"最近利用jekyll写博客，为的就是博客管理方便，但是在上传博客的时候使用git push命令每次都得输入github帐号和密码特别的不方便，于是就搜了一下。 在这篇文章里提到，GitHub获得远程库时，有ssh方式和https方式。 两个方式的url地址不同，认证方式也不同。使用ssh时保存密钥对以后可以不再输入帐号密码，而https却不能。所以如果想要不再输入帐号密码，一种方式就是在git clone的时候使用ssh方式，另一种方式就是去修改已有项目.git目录下的config文件中的url，如下： [remote &quot;origin&quot;] url = git@github.com:suyan/suyan.github.io.git fetch = +refs/heads/*:refs/remotes/origin/*","tags":[{"name":"Git","slug":"Git","permalink":"https://www.devzou.com/tags/Git/"}]},{"title":"git创建远程库","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/tool/create-remote-resp/","text":"git创建远程库 git中一般使用 git init 创建的库不允许同一分支多个work tree直接提交，如果这么做有可能会出现以下问题： remote: error: refusing to update checked out branch: refs/heads/master 要解决这个问题可以有以下四种方式 创建共享库（推荐）# 创建共享库(bare) $ mkdir /git/repo.git &amp;&amp; cd /git/repo.git &amp;&amp; git init --bare # 本地库 $ mkdir ~/repo &amp;&amp; cd ~/repo &amp;&amp; git init # 创建一个文件 $ vi foo # 增加新增文件到库管理 $ git add . # 提交 $ git commit # 增加共享库位置 $ git remote add origin file:///git/repo.git # 提交更改 $ git push origin master 不工作在同一库下（推荐）# 创建库 $ mkdir /git/repo &amp;&amp; cd /git/repo &amp;&amp; git init # 创建一个文件 $ vi foo # 增加新增文件到库管理 $ git add . # 提交 $ git commit # 新建一个分支 $ git branch test # 本地库 $ git clone file:///git/repo &amp;&amp; cd repo # 切换到分支test $ git checkout test # 修改文件 $ echo &quot;foo&quot;&gt;foo # 提交 $ git commit # 增加远程库位置 $ git remote add origin flie:///git/repo # 提交更改 $ git push origin test 忽略冲突1修改远程库.git/config添加下面代码 [receive] denyCurrentBranch = ignore 这种方式不能直接显示在结果的work tree上，如果要显示，需要使用 git reset --hard才能看到 忽略冲突2在远程库上 git config -bool core.bare true","tags":[{"name":"Git","slug":"Git","permalink":"https://www.devzou.com/tags/Git/"}]},{"title":"在ubuntu下搭建pptp vpn服务器","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/git/2013-12-11-deploy-pptp-vpn-in-ubuntu/","text":"pptp配置安装pptp用ubuntu就是安装东西快 sudo apt-get -y update sudo apt-get -y install pptpd 修改配置脚本配置一下dns cat &gt;/etc/ppp/options.pptpd &lt;&lt;END name pptpd refuse-pap refuse-chap refuse-mschap require-mschap-v2 require-mppe-128 ms-dns 8.8.8.8 ms-dns 8.8.4.4 proxyarp lock nobsdcomp novj novjccomp nologfd END 说明 name pptpd（pptpd服务名，可以随便填写。） refuse-pap（拒绝pap身份认证模式。） refuse-chap（拒绝chap身份认证模式。） refuse-mschap（拒绝mschap身份认证模式。） require-mschap-v2（在端点进行连接握手时需要使用微软的 mschap-v2 进行自身验证。） require-mppe-128（MPPE 模块使用 128 位加密。） ms-dns 8.8.8.8 (ppp 为 Windows 客户端提供 DNS 服务器 IP 地址。) proxyarp (建立 ARP 代理键值。) nodefaultroute（不替换默认路由） debug（开启调试模式，相关信息记录在 /var/logs/message 中。） lock（锁定客户端 PTY 设备文件。） nobsdcomp (禁用 BSD 压缩模式。) 还有ip cat &gt; /etc/pptpd.conf &lt;&lt;END option /etc/ppp/options.pptpd logwtmp localip 192.168.2.1 remoteip 192.168.2.10-100 END 增加路由转发ipv4转发cat &gt;&gt; /etc/sysctl.conf &lt;&lt;END net.ipv4.ip_forward=1 END sysctl -p 修改iptables备份当前iptables iptables-save &gt; /etc/iptables.down.rules 修改iptable NAT转发 iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -o eth0 -j MASQUERADE 设置MTU iptables -I FORWARD -s 192.168.2.0/24 -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1300 保存新iptables iptables-save &gt; /etc/iptables.up.rules 重启后继续有效 cat &gt;&gt;/etc/ppp/pptpd-options&lt;&lt;EOF pre-up iptables-restore &lt; /etc/iptables.up.rules post-down iptables-restore &lt; /etc/iptables.down.rules EOF 增加用户增加帐号密码都是test的用户 cat &gt;/etc/ppp/chap-secrets &lt;&lt;END test pptpd test * END 重启服务/etc/init.d/pptpd restart netstat -lntp 自动脚本wget -c https://github.com/suyan/scripts/raw/master/Setup/pptp.sh 问题logwtmp.so 版本问题如果链接中断，并且出现下面问题： Plugin /usr/lib/pptpd/pptpd-logwtmp.so is for pppd version 2.4.5, this is 2.4.6 在 /etc/pptpd.conf 文件中把 logwtmp 删掉就好了。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.devzou.com/tags/Linux/"}]},{"title":"在Mac下安装使用Vagrant","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/git/2014-04-10-install-vagrant-in-mac/","text":"安装安装VagrantVagrant的旧版本是可以通过gem来安装的，但是由于依赖实在太多，官方放弃了这种安装方式，建议下载官方安装包来安装。 下载地址在http://www.vagrantup.com/downloads。下载好pkg包后，点击安装即可。 安装VirtualboxVagrant依赖现有的虚拟机软件来管理虚拟机，如Virtualbox, Vmware Fusion, Parallel Desktop等，其中最方便的是VirtualBox，所以我选择了Virtualbox。 下载地址在https://www.virtualbox.org/wiki/Downloads。同样下载好后直接安装。 使用下载启动Box在Vagrant中，box是一种打包好的镜像，通过这个镜像，可以生成相应的虚拟机。box可以通过官方网站下载，也可以自己制作，在团队内分享。 官方的Box可以在创建时自动下载。例如以下步骤 cd ~/Documents/Vagrant/Ubuntu # 进入一个vagrant虚拟机目录，一个目录管理一个虚拟机 vagrant init hashicorp/precise32 # 创建一个ubuntu的虚拟机 vagrant up # 启动这个虚拟机 通过这个步骤，vagrant会去box列表中找hashicorp/precise32这个镜像，如果没有就去官方下载。Box被保存在~/.vagrant下。通过命令 vagrant box list 可以查看已经下载的box。如果想以这个box再建立一个虚拟机，只要再创建一个目录，例如~/Documents/Vagrant/Ubuntu32，然后执行 vagrant init hashicorp/precise32 即可。 操作虚拟机操作虚拟机时，必须进入刚刚建立的目录中去，这个目录中必须含有init命令建立的Vagrantfile文件。常用命令有 $ vagrant init # 初始化 $ vagrant up # 启动虚拟机 $ vagrant halt # 关闭虚拟机 $ vagrant reload # 重启虚拟机 $ vagrant ssh # SSH 至虚拟机 $ vagrant status # 查看虚拟机运行状态 $ vagrant destroy # 销毁当前虚拟机 共享文件夹通过Vagrant建立的虚拟机和Mac共享文件非常容易，虚拟机中/vagrant目录会映射到我们本地虚拟机目录中。例如 cd ~/Documents/Vagrant/Ubuntu vagrant up vagrant ssh cd /vagrant ls 这个时候，我们会看到，这里显示的文件和~/Documents/Vagrant/Ubuntu下是一样的。 共享Box如果只有上述功能的话，那么Vagrant的作用就不是那么杀手级了。通过命令 vagrant package 可以将一个虚拟机打包成Box，供别人使用。别人只要用打包的box来创建一个虚拟机即可，例如 vagrant box add myubuntu ~/Documents/Vagrant/Ubunutu/ubunut.box 参考 Vagrant Docs 使用 Vagrant 打造跨平台开发环境","tags":[{"name":"-Mac -Vagrant","slug":"Mac-Vagrant","permalink":"https://www.devzou.com/tags/Mac-Vagrant/"}]},{"title":"git创建远程库","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/git/create-remote-resp/","text":"git创建远程库 git中一般使用 git init 创建的库不允许同一分支多个work tree直接提交，如果这么做有可能会出现以下问题： remote: error: refusing to update checked out branch: refs/heads/master 要解决这个问题可以有以下四种方式 创建共享库（推荐）# 创建共享库(bare) $ mkdir /git/repo.git &amp;&amp; cd /git/repo.git &amp;&amp; git init --bare # 本地库 $ mkdir ~/repo &amp;&amp; cd ~/repo &amp;&amp; git init # 创建一个文件 $ vi foo # 增加新增文件到库管理 $ git add . # 提交 $ git commit # 增加共享库位置 $ git remote add origin file:///git/repo.git # 提交更改 $ git push origin master 不工作在同一库下（推荐）# 创建库 $ mkdir /git/repo &amp;&amp; cd /git/repo &amp;&amp; git init # 创建一个文件 $ vi foo # 增加新增文件到库管理 $ git add . # 提交 $ git commit # 新建一个分支 $ git branch test # 本地库 $ git clone file:///git/repo &amp;&amp; cd repo # 切换到分支test $ git checkout test # 修改文件 $ echo &quot;foo&quot;&gt;foo # 提交 $ git commit # 增加远程库位置 $ git remote add origin flie:///git/repo # 提交更改 $ git push origin test 忽略冲突1修改远程库.git/config添加下面代码 [receive] denyCurrentBranch = ignore 这种方式不能直接显示在结果的work tree上，如果要显示，需要使用 git reset --hard才能看到 忽略冲突2在远程库上 git config -bool core.bare true","tags":[{"name":"Git","slug":"Git","permalink":"https://www.devzou.com/tags/Git/"}]},{"title":"Python 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/python/2014-01-15-general-python-resources/","text":"常用代码遍历对象for key in a.__dict__: print key,&apos;:&apos;,a.__dict__[key] 调试方法assert False //引发异常，观察错误界面 import logging logging.info(&apos;&apos;) //写日志 获得当前时间#时间戳 time.time() #日期时间 time.ctime() #iso时间 datetime.fromtimestamp(time.time()).isoformat() #固定格式 time.strftime(&apos;%Y-%m-%d&apos;,time.localtime(time.time())) 日期到时间戳dateC=datetime.datetime(2010,6,6,8,14,59) timestamp=time.mktime(dateC.timetuple()) 时间戳到日期ltime=time.localtime(1237515355.0) timeStr=time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, ltime) 之后的包从绝对位置导入from __future__ import absolute_import","tags":[{"name":"Python","slug":"Python","permalink":"https://www.devzou.com/tags/Python/"}]},{"title":"Bootstrap常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2013-04-23-general-bootstrap-resources/","text":"官方资源 官方首页 字体图标 Font Awesome 扩展bootstrap的图标，是基于css的，非常漂亮，而且还支持视网膜屏，但是貌似手机上没法支持（测试过UC） 下拉按钮 Bootstrap Mutiselect 多选下拉列表插件 表单扩展 Bootstrap Form Helpers 扩展常用的表单功能，包括日期选择、时间选择等","tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://www.devzou.com/tags/Bootstrap/"}]},{"title":"HTML 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-01-15-general-html-resources/","text":"常用属性在link中可能会出现media=screen的情况这个属性是确定在哪种情况下使用这个link的css文件，screen是指输出到屏幕，而print用于打印 在meta中增加viewport选项viewport的作用是告诉浏览器，目前的装置情况。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width;initial-scale=1.0&quot;&gt; width:数字或device-width 设置宽度 height:数字或device-width 设置高度 initial-scale:最小0.25，最大5 初始缩放 minimum-scale:最小0.25，最大5 最小缩放 maximum-scale:最小0.25，最大5 最大缩放 user-scalable:1或0(yes or no) 是否允许用户缩放","tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.devzou.com/tags/HTML/"}]},{"title":"Mac下用brew搭建PHP(LNMP/LAMP)开发环境","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/git/2013-12-11-lamp-in-mac/","text":"Brewbrew对于mac，就像apt-get对于ubuntu，安装软件的好帮手，不能方便更多… brew的安装方式如下： ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go/install)&quot; brew常用选项 brew install xxx brew uninstall xxx brew list brew update xxx Apache || Nginx (只需要装一个)ApacheApache的话使用mac自带的基本就够了，我的系统是10.9，可以使用以下命令控制Apache sudo apachectl start sudo apachectl restart sudo apachectl stop 唯一要改的是主目录，mac默认在home下有个Sites（站点）目录，访问路径是 http://localhost/~user_name 这样不太容易访问，修改/etc/apache2/httpd.conf内容 DocumentRoot /Users/username/Sites &lt;Directory /Users/username/Sites&gt; Options Indexes MultiViews # apache 2.2 # AllowOverride All # Order allow,deny # Allow from 127.0.0.1 # apache 2.4 Require local &lt;/Directory&gt; 这样Sites目录就是网站根目录了，通过http://localhost就可以访问了。 常用命令123sudo apachectl start # 启动apachesudo apachectl stop # 关闭apachesudo apachectl restart # 重启apache 设置vhost设置vhost可以很方便的进行站点调试，尤其是对于需要在根目录运行的站点。推荐 VirtualHostX. 设置方法是： 1sudo vi /etc/apache2/extra/httpd-vhosts.conf 然后输入： 123456789&lt;Directory \"/pash/to/site\"&gt; Allow From All AllowOverride All Options +Indexes&lt;/Directory&gt;&lt;VirtualHost *:80&gt; ServerName \"site.test\" DocumentRoot \"/path/to/site\"&lt;/VirtualHost&gt; 这么设置会有个问题，默认的http://localhost会被转到这儿来，所以专门再设置一下localhost的host就好了。 1234&lt;VirtualHost *:80&gt; ServerName localhost DocumentRoot /path/to/root&lt;/VirtualHost&gt; 然后把host文件改一下，把刚刚设置的ServerName改到本地就好了。 1sudo vi /etc/hosts 写入： 1127.0.0.1 site.test Nginx要使用Nginx也比较方便，首先安装 brew install nginx 启动关闭Nginx的命令如下（如果想要监听80端口，必须以管理员身份运行） #打开 nginx sudo nginx #重新加载配置|重启|停止|退出 nginx nginx -s reload|reopen|stop|quit #测试配置是否有语法错误 nginx -t 配置Nginx cd /usr/local/etc/nginx/ mkdir conf.d 修改Nginx配置文件 vim nginx.conf 主要修改位置是最后的include worker_processes 1; error_log /usr/local/var/log/nginx/error.log warn; pid /usr/local/var/run/nginx.pid; events { worker_connections 256; } http { include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/var/log/nginx/access.log main; port_in_redirect off; sendfile on; keepalive_timeout 65; include /usr/local/etc/nginx/conf.d/*.conf; } 修改自定义文件 vim ./conf.d/default.conf 增加一个监听端口 server { listen 80; server_name localhost; root /Users/username/Sites/; # 该项要修改为你准备存放相关网页的路径 location / { index index.php; autoindex on; } #proxy the php scripts to php-fpm location ~ \\.php$ { include /usr/local/etc/nginx/fastcgi.conf; fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; } } 这个时候还不能访问php站点，因为还没有开启php-fpm。 虽然mac 10.9自带了php-fpm，但是由于我们使用了最新的PHP，PHP中自带php-fpm，所以使用PHP中的php-fpm可以保证版本的一致。 这里的命令在安装完下一步的php后再执行 sudo nginx sudo php-fpm -D PHPPHP在mac下默认安装了，但是不好控制版本，利用brew可以再mac下安装最新版本，甚至是多个版本，我装了php5.5 brew update brew tap homebrew/dupes brew tap josegonzalez/homebrew-php # brew install php55 --with-fpm #Nginx brew install php55 #Apache 然后修改php的cli路径和apache使用的php模块。在.bashrc或.zshrc里头加以下内容 #export PATH=&quot;$(brew --prefix josegonzalez/php/php55)/bin:$PATH&quot; export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 就用刚刚安装的php代替了系统默认cli的php版本。然后在/etc/apache2/httpd.conf下增加 LoadModule php5_module /usr/local/Cellar/php55/5.5.8/libexec/apache2/libphp5.so 这样就对apache使用的php版本也进行了修改。 后面会用到mongo和mysql，所以可以直接利用下面命令安装php模块，其他模块也类似 #brew install php55-mysql #这个已经不需要再安装了 brew install php55-mongo MySQLmac不自带mysql，这里需要重新安装，方法依然很简单 brew install mysql unset TMPDIR mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew --prefix mysql)&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp sudo chown -R your_user /usr/local/var/mysql/ 第一句是安装，后面的是确保正常使用。然后是启动命令 mysql.server start 最好给mysql设个密码，方法如下 mysqladmin -u root password &apos;xxx&apos; 如果想修改mysql的配置，在/usr/local/etc下建立一个my.cnf，例如增加log [mysqld] general-log general_log_file = /usr/local/var/log/mysqld.log MongoDBMongoDB可以说是最简单的一个，直接执行 brew install mongodb 启动方法 mongod --fork PHPMyAdminphpmyadmin几乎是管理mysql最容易的web应用了吧，每次我都顺道装上。 去官网下载最新的版本 解压到~/Sites/phpmyadmin下 在phpmyadmin目录下创建一个可写的config目录 打开http://localhost/phpmyadmin/setup，安装一个服务，最后保存（这里只需要输入帐号密码就够了） 将config下生成的config.inc.php移到phpmyadmin根目录下 删除config 这样就装好了，虽然可能有点小复杂，但是来一次就习惯了。 这里很可能会遇到2002错误，就是找不到mysql.sock的问题，用下面方法解决 sudo mkdir /var/mysql sudo ln -s /tmp/mysql.sock /var/mysql/mysql.sock RockMongoRockMongo是MongoDB很好用的一个web应用，安装也很容易 去官网下载最新版本 解压到~/Sites/rockmongo下 运行http://localhost/rockmongo即可 把 site 放在 Dropbox 文件夹下123ln -s ~/Dropbox/sitename ~/Sites/sitenamechmod a+rw ~/Dropboxchmod a+rw ~/Dropbox/sitename 完成这样就在mac下配置好一个php开发环境了，enjoy it! 参考 Hot to install nginx, PHP-fpm 5.5.6, mongo and MySql on mac with homebrew Mac OSX 10.9搭建nginx+mysql+php-fpm环境","tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.devzou.com/tags/Mac/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.devzou.com/tags/MongoDB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"Git 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-01-15-general-git-resources/","text":"克隆库12git clone https://github.com/php/php-src.gitgit clone --depth=1 https://github.com/php/php-src.git # 只抓取最近的一次 commit 历史管理查看历史12git log --pretty=oneline filename # 一行显示git show xxxx # 查看某次修改 标签功能12345678git tag # 显示所有标签git tag -l 'v1.4.2.*' # 显示 1.4.2 开头标签git tag v1.3 # 简单打标签 git tag -a v1.2 9fceb02 # 后期加注标签git tag -a v1.4 -m 'my version 1.4' # 增加标签并注释， -a 为 annotated 缩写git show v1.4 # 看某一标签详情git push origin v1.5 # 分享某个标签git push origin --tags # 分享所有标签 回滚操作12git reset 9fceb02 # 保留修改git reset 9fceb02 --hard # 删除之后的修改 取消文件的修改12git checkout -- a.php # 取消单个文件git checkout -- # 取消所有文件的修改 删除文件12git rm a.php # 直接删除文件git rm --cached a.php # 删除文件暂存状态 移动文件1git mv a.php ./test/a.php 查看文件修改12git diff # 查看未暂存的文件更新 git diff --cached # 查看已暂存文件的更新 暂存和恢复当前staging12345git stash # 暂存当前分支的修改git stash apply # 恢复最近一次暂存git stash list # 查看暂存内容git stash apply stash@&#123;2&#125; # 指定恢复某次暂存内容git stash drop stash@&#123;0&#125; # 删除某次暂存内容 修改 commit 历史纪录1git rebase -i 0580eab8 分支管理创建分支12git branch develop # 只创建分支git checkout -b master develop # 创建并切换到 develop 分支 合并分支1234git checkout master # 切换到 master 分支git merge --no-ff develop # 把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录git rebase develop # rebase 当前分支到 developgit branch -d develop # 删除 develop 分支 克隆远程分支12git branch -r # 显示所有分支，包含远程分支git checkout origin/android 修复develop上的合并错误 将merge前的commit创建一个分之，保留merge后代码 将develop reset --force到merge前，然后push --force 在分支中rebase develop 将分支push到服务器上重新merge 强制更新到远程分支最新版本12git reset --hard origin/mastergit submodule update --remote -f Submodule使用克隆带submodule的库1git clone --recursive https://github.com/chaconinc/MainProject clone主库后再去clone submodule123git clone https://github.com/chaconinc/MainProjectgit submodule initgit submodule update Git设置Git的全局设置在~/.gitconfig中，单独设置在project/.git/config下。 忽略设置全局在~/.gitignore_global中，单独设置在project/.gitignore下。 设置 commit 的用户和邮箱12git config user.name \"xx\"git config user.email \"xx@xx.com\" 或者直接修改config文件 123[user] name = xxx email = xxx@xxx.com 查看设置项1git config --list 设置git终端颜色123git config --global color.diff autogit config --global color.status autogit config --global color.branch auto","tags":[{"name":"Git","slug":"Git","permalink":"https://www.devzou.com/tags/Git/"}]},{"title":"PHP 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-01-15-general-php-resources/","text":"常用资源常用扩展 phpDocumentor PHPUnit Guzzle 好文 PHP之道 Cookie/Session机制详解 优秀的类库 PHP中文分词: 自动打标签功能 判断是否为空1234567891011121314151617181920+--------------+-----------+---------+-----------+---------+--------+| 真值表 | gettype() | empty() | is_null() | isset() | (bool) |+--------------+-----------+---------+-----------+---------+--------+| $x = &quot;&quot; | string | true | false | true | false || $x=null | NULL | true | true | false | false || var $x | NULL | true | true | false | false || $x = array() | array | true | false | true | false || $x = false | boolean | true | false | true | false || $x = 15 | integer | false | false | true | true || $x = 1 | integer | false | false | true | true || $x = 0 | integer | true | false | true | false || $x = -1 | integer | false | false | true | true || $x = &apos;15&apos; | string | false | false | true | true || $x = &apos;1&apos; | string | false | false | true | true || $x = &apos;0&apos; | string | true | false | true | false || $x = &apos;-1&apos; | string | false | false | true | true || $x = &apos;foo&apos; | string | false | false | true | true || $x = &apos;true&apos; | string | false | false | true | true || $x = &apos;false&apos; | string | false | false | true | true |+--------------+-----------+---------+-----------+---------+--------+ 常用命令修改phpunit内存限制phpunit -d memory_limit=512M PHPStorm 常用快捷键 Quick Command Command + Shift + A Quick File Command + Shift + O Quick Class Command + O Quick Symbol Command + Option + O","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"JavaScript 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-01-15-general-javascript-resources/","text":"常用代码字符串截取substr(start [, length ]) 返回一个从指定位置开始的指定长度的子字符串 substring(start, end) 返回位于 String 对象中指定位置的子字符串。 页面跳转window.navigate(&quot;top.jsp&quot;); window.history.back(-1); window.location.href=&quot;login.jsp?backurl=&quot;+window.location.href; self.location=&apos;top.htm&apos;; top.location=&apos;xx.jsp&apos;; 加载完成window.onload 必须等页面内包括图片的所有元素加载完成后才能执行。 不能同时编写多个，只执行一个 $(document).ready() 是DOM结构绘制完毕后就可以执行 可以编写多个 简写$(function(){}); $(window).load()等同与window.onload 刷新页面history.go(0) location.reload() location=location location.assign(location) document.execCommand(&apos;Refresh&apos;) window.navigate(location) location.replace(location) document.URL=location.href json转化和解析JSON.parse(&quot;{a:&apos;111&apos;,b:&apos;ccc&apos;}&quot;); //解析 eval(&quot;(&quot;+&quot;{{ cpu_data }}&quot;+&quot;)&quot;); //解析 时间转换var day1 = parseInt(new Date().valueOf()/1000); //获得当前时间时间戳 day2 = new Date(day1*1000); alert(day2.getFullYear()+&quot;-&quot;+(day2.getMonth()+1)+&quot;-&quot;+day2.getDate()+&quot; &quot;+day2.getHours()+&quot;:&quot;+day2.getMinutes()+&quot;:&quot;+day2.getSeconds()) d = new Date(); s = d.getFullYear() + &quot;-&quot;; s += (&quot;0&quot;+(d.getMonth()+1)).slice(-2) + &quot;-&quot;; s += (&quot;0&quot;+d.getDate()).slice(-2) + &quot; &quot;; s += (&quot;0&quot;+d.getHours()).slice(-2) + &quot;:&quot;; s += (&quot;0&quot;+d.getMinutes()).slice(-2) + &quot;:&quot;; s += (&quot;0&quot;+d.getSeconds()).slice(-2) + &quot;.&quot;; s += (&quot;00&quot;+d.getMilliseconds()).slice(-3); URI编码转换var a=&quot;&apos;:&apos;&quot;; en = encodeURI(a); //编码 a = decodeURI(en); //解码 HTML编码转换function htmlEncode(value){ return $(&apos;&lt;div/&gt;&apos;).text(value).html(); } function htmlDecode(value){ return $(&apos;&lt;div/&gt;&apos;).html(value).text(); }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.devzou.com/tags/JavaScript/"}]},{"title":"jQuery 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-01-15-general-jquery-resources/","text":"官方资源 官方首页 官方插件 下拉框扩展 Select 2 功能强大的下拉列表插件，基本包含了所有可能的需求…… OptionTree 联动下拉列表插件，可以动态生成下拉列表，而且支持ajax获取数据 常用代码禁用a的链接href=&quot;return false;&quot;或href=&quot;javascript;&quot; $().live(&apos;click&apos;,function(e){ e.preventDefault(); }); 清空file的内容var cfile = $(&apos;#id&apos;).clone(); $(&apos;#id&apos;).replaceWith(cfile); jquery.form.js 和 jquery.validate.js配合使用这两个脚本搭配在表单验证和提交是非常的好用,顺便增加了对bootstrap表单的支持 $(&quot;#page_form&quot;).validate({ highlight: function(element) { $(element).closest(&apos;.control-group&apos;).removeClass(&apos;success&apos;).addClass(&apos;error&apos;); }, success: function(element) { element.text(&apos;OK!&apos;).addClass(&apos;valid&apos;).closest(&apos;.control-group&apos;).removeClass(&apos;error&apos;).addClass(&apos;success&apos;); }, submitHandler:function(form) { $(form).ajaxSubmit(options); }}); 选择父节点使用$(this)来将dom对象转为jquery对象 $(this).parents(&apos;tr&apos;); 多重操作$(this).parents(&apos;tr&apos;).remove(); 因为jquery函数返回jquery节点","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.devzou.com/tags/jQuery/"}]},{"title":"Shell 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-01-15-general-shell-resources/","text":"常用指令文本内容搜索grep aaa * 文件夹操作查看文件夹大小 du -h --max-depth=1 /home/ys 查看驱动器空间 df -h 压缩命令tar zxvf aaa.tar.gz tar zcvf aaa.tar.gz aaa 登陆到其他用户login 查看端口的占用lsof -i:8087 查看8087端口的使用 批量杀死进程ps -aux|grep name|grep -v grep|cut -c 9-15|xargs kill -9 查看当前时间date 时间 date +%s 时间戳 date -d &quot;2010-07-20 10:25:30&quot; +%s 指定时间时间戳 date -d &quot;@1279592730&quot; 时间戳转时间 date -d &quot;1970-01-01 14781 days&quot; &quot;+%Y/%m/%d %H:%M:%S&quot; 查看进程内存使用情况top -d 1 -p pid [,pid ...] pmap pid ps aux|grep process_name 查看/proc/process_id/文件夹下的status文件 查看Linux内核版本或发布版本lsb_release -a uname -a 一句话实现一个HTTP服务，把当前文件夹作为根目录python -m SimpleHTTPServer 查看本地网络服务活动状态lsof -i 查看自己的外网ipcurl ifconfig.me 下载整个网站wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com 后台运行一段不中止的程序，并可随时查看它的状态screen -d -m -S some_ name ping my_router 查看进程执行的时间ps -A -opid,stime,etime,args | grep python 创建守护进程nohup python /var/www/a.py &amp; 查看当前文件夹下文件（文件夹）大小du -h --max-depth=1 . 查看所有磁盘大小df -h 诊断网络mtr ping traceroute dig 列出本机监听的端口号netstat –tlnp netstat -anop 在远程机器上运行一段脚本ssh user@server bash &lt; /path/to/local/script.sh 端口扫描nc -z -v -n 127.0.0.1 20-100 负载测试，30秒内向Google发起20个并发连接siege -c20 www.google.co.uk -b -t30s","tags":[{"name":"Shell","slug":"Shell","permalink":"https://www.devzou.com/tags/Shell/"}]},{"title":"SVN 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-01-15-general-svn-resources/","text":"常用指令将文件checkout到本地目录svn checkout path（path是服务器上的目录） svn checkout svn://192.168.1.1/pro/domain svn co 往版本库中添加新的文件svn add file svn add test.php(添加test.php) svn add *.php(添加当前目录下所有的php文件) svn add *.php --force(增加所有文件) 将改动的文件提交到版本库svn commit -m “LogMessage“ [-N] [--no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关) svn commit -m “add test file for my test“ test.php svn ci 加锁/解锁svn lock -m “LockMessage“ [--force] PATH svn lock -m “lock test file“ test.php svn unlock PATH 更新到某个版本svn update -r m path svn update 如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200) svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit) svn up 查看文件或者目录状态svn status path（目录下的文件和子目录的状态，正常状态不显示） 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 svn status -v path(显示文件和子目录状态) 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 svn st 删除文件svn delete path -m “delete test fle“ svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file” 或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种 svn (del, remove, rm) 查看日志svn log path svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 查看文件详细信息svn info path svn info test.php 比较差异svn diff path(将修改的文件与基础版本比较) svn diff test.php svn diff -r m:n path(对版本m和版本n比较差异) svn diff -r 200:201 test.php svn di 将两个版本之间的差异合并到当前文件svn merge -r m:n path svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） SVN 帮助svn help svn help ci 版本库下的文件和目录列表svn list path svn ls 创建纳入版本控制下的新目录svn mkdir: 创建纳入版本控制下的新目录。 mkdir PATH… mkdir URL… 创建版本控制的目录。 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。 2、每个以URL指定的目录，都会透过立即提交于仓库中创建.在这两个情况下，所有的中间目录都必须事先存在。 恢复本地修改svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert: 用法: revert PATH… 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录 代码库URL变更svn switch (sw): 更新工作副本至不同的URL。 1、switch URL [PATH] 2、switch –relocate FROM TO [PATH...] 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动(比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用这个命令更新工作副本与仓库的对应关系。 解决冲突svn resolved: 移除工作副本的目录或文件的“冲突”状态。 java设计模式之——策略模式 用法: resolved PATH… 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让 PATH 可以再次提交。 输出指定文件或URL的内容。svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。 svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)","tags":[{"name":"SVN","slug":"SVN","permalink":"https://www.devzou.com/tags/SVN/"}]},{"title":"Mac 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-08-03-general-mac-resources/","text":"常用软件AlfredAlfred常用Workflow Dash Dict - Lookup Word Reminders Evernote Notes 常用命令开启关闭dashboard关闭 defaults write com.apple.dashboard mcx-disabled -boolean YES killall Dock 开启 defaults write com.apple.dashboard mcx-disabled -boolean NO killall Dock 剪贴板操作写入剪切板 echo &apos;test&apos; &gt; pbcopy cat testfile &gt; pbcopy 读取剪贴板 pbpaste &gt; testfile pbpaste | cat 开启关闭Hidpi开启 sudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES 关闭 sudo defaults delete /Library/Preferences/com.apple.windowserver DisplayResolutionDisabled 修改Dock隐藏和出现时间123defaults write com.apple.dock autohide-delay -int 0defaults write com.apple.dock autohide-time-modifier -float 0.4killall Dock 设置iterm中option为alt(meta)键 删除dropbox冲突文件find . -type f -name &quot;* conflicted *&quot; -exec rm -f {} \\; 清空Launchpad（删除掉）sqlite3 ~/Library/Application\\ Support/Dock/*.db &apos;DELETE FROM apps;&apos; &amp;&amp; killall Dock 重置Launchpadrm -f ~/Library/Application\\ Support/Dock/*.db &amp;&amp; killall Dock 修改Finder中文件夹显示语言# 以Desktop为例 touch ~/Desktop/.localized chmod 600 ~/Desktop/.localized 常用快捷键Chrome 切换用户 Command + shift + M","tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.devzou.com/tags/Mac/"}]},{"title":"在Github上搭建Jekyll博客和创建主题","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/git/2014-02-12-how-to-deploy-a-blog-on-github-by-jekyll/","text":"创建一个库在Github上新开一个库，名字叫做username.github.io，然后当别人在地址栏输入相应url的时候就可以访问进来了。 在这个库中完全可以只上传一个index.html，来讲自己要写的东西写进去，但是这样会丧失很多灵活性，所以需要Jekyll的帮助来创建自己的博客。 设定目录结构把自己的库clone到本地来，建立如下目录结构： 1234567891011121314151617181920212223242526272829303132├── CNAME├── README.md├── _config.yml├── _includes│ ├── disqus.html│ ├── footer.html│ ├── googleanalytics.html│ ├── header.html│ └── navside.html├── _layouts│ ├── base.html│ ├── book.html│ ├── page.html│ └── post.html├── _posts│ ├── Book│ ├── Life│ ├── Resource│ ├── Technology│ └── Tool├── index.html├── pages│ ├── about.html│ ├── archive.html│ └── atom.xml├── public│ ├── css│ ├── fonts│ ├── img│ ├── js│ └── upload└── sitemap.txt 这个目录结构是我自己设定的，也可以有不同的目录结构，看官网。 接下来我主要解释这里面每一个目录的功能。 配置文件_config.yml里写有整个站点的主要配置项，我的如下： 12345678910111213permalink: /:year/:month/:day/:title.html #博文的固定链接paginate: 10 #分页时每页博文数量author: #自定义常亮 name: 闫肃 email: yansu0711@gmail.com link: http://yansu.orgtitle: 闫肃的博客 #自定义常量locals: #自定义常量 tags: 标签 about: 关于active: 技术 #自定义常量subscribe_rss: /pages/atom.xml #订阅地址markdown: redcarpet #markdown解释器 这里的自定义常量可以在模板中使用，以后有修改的时候就不需要跑去改代码了。尤其是对一些私人的选项，可以在这里定义。现在我的博客中出了disqus和googleanalytics外都直接在这里设定就好了。 域名配置CNAME这个文件写明了这个站点的域名，如果不喜欢username.github.io的话，可以像我一样改掉 1yansu.org 改法只要在这个文件中写入域名就可以了。不过你需要去域名服务商那里设定域名解析规则。 只要把主机记录为@,www的记录值写成username.github.io就好了。 博客存放_posts下的所有目录中的所有博客，都会被Jekyll处理成为静态的html文件，然后放在_site下。我这里没有_site目录，是因为我在.gitignore文件中把这个目录屏蔽掉了，它不会上传到Github上。 123_site/_drafts/.DS_Store 以上是我的.gitignore文件内容。 在_posts下的符合YYYY-MM-DD-xxxxxx.md的文件，都会被Jekyll认定为博客内容。我在_posts下又新建了一些文件夹，主要是方便自己本地管理博客。 在上述这些文件中，必须先定义一些配置项，例如这篇博客的md文件中，开头是这样的： 1234567layout: post #这个博客的布局文件title: 在Github上搭建自己的Jekyll博客 #博客标题category: 工具 #博客分类tags: Jekyll #博客标签keywords: Jekyll,Github #自定义常量description: #自定义常量 除了自定义常量外的必须包含进去，自定义变量在这个布局中可以访问。 模版文件剩余的目录，基本都属于模板文件了，我解释一下各自的作用： _includes 可以在模板中随时包含的文件 _layouts 布局文件，在博客头配置中可以选择 pages 站内固定的页面 public 公共资源，包括js,css,img等，还有我博客中调用的图片，我都放这里 index.html 站点的首页，整个站的入口文件 sitemap.txt 给搜索引擎看的，如何爬取这个站 创建自己的主题上面讲了如何布局好站内文件结构，接下来主要就是如何创建一个自己的主题了。 布局文件是整个主题最重要的文件，这些文件告诉Jekyll如何去形成一个html页面。 首先我说一下我最基础的page.html文件，因为它决定了入口文件index.html的布局。 12345678910111213141516layout: base&lt;div class=\"row\"&gt; &lt;div class=\"col-md-12 aside3-title\"&gt; &lt;br&gt; &lt;h2 id=\"#identifier\"&gt;&#123;\\&#123; page.title &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-md-12 aside3-content\"&gt; &lt;div id=\"page-content\"&gt; &#123;\\&#123; content &#125;&#125; &lt;/div&gt; &lt;hr&gt; &#123;\\% include disqus.html %&#125; &lt;/div&gt;&lt;/div&gt; 从这里可以看到这个文件写起来一点都不复杂，但是为什么开头还有个layout呢？因为它也不是最基本的布局文件，最基本的是base.html，我们看一下它的内容。 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &#123;\\% include header.html %&#125;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &#123;\\% include navside.html %&#125; &lt;div class=\"col-md-8 col-lg-8 col-sm-12 col-xs-12 aside3\"&gt; &lt;div id=\"container\"&gt; &lt;div id=\"pjax\"&gt; &#123;\\&#123; content &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;\\% include footer.html %&#125; &#123;\\% include googleanalytics.html %&#125;&lt;/body&gt;&lt;/html&gt; 这个文件就更像一个HTML文件了，用PHP或者Python写过web应用的人看到{\\% %}这样的标签应该不陌生，这不就是模板标签嘛。其实Jekyll也是借用了一下模板系统的，官网说明在这里，看到开头第一句讲的它用了Liquid了吧。如果Jekyll的文档不能满足你的话，可以去Liquid那里查查。 我解释一下base.html中几个标签的功能。 {\\% include header.html %} 从_includes中把header.html包含进来放在这里 {\\% include navside.html %} 同上 {\\{ content }} 这句的作用是将继承这个Layout的文件中的代码，放在这里 所以再看page.html文件就很容易了，它就是把配置项下面的内容，填补到base.html中的{\\{ content }}处形成了一个文件。那么page.html中的{\\{ content }}做什么用呢？因为别人也可以以page.html来作为自己的布局文件。 入口文件index.html就是这么干的： 123layout: pagetitle: 首页... 这里看到选择了page作为布局文件，那么title干嘛用的呢？其实它是在被包含的header.html中被用到了。来看看header.html怎么写的： 1234567891011&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&#123;\\&#123; page.title &#125;&#125; | &#123;\\&#123; site.title &#125;&#125;&lt;/title&gt;&lt;meta name=\"author\" content=\"&#123;&#123; site.author.name &#125;&#125;\"&gt;&#123;\\% if page.keywords %&#125; &lt;meta name=\"keywords\" content=\"&#123;&#123; page.keywords &#125;&#125;\"&gt;&#123;\\% endif %&#125;&#123;\\% if page.description %&#125; &lt;meta name=\"description \" content=\"&#123;&#123; page.description &#125;&#125;\"&gt;&#123;\\% endif %&#125;... 这里又使用了一些新标签——{\\{ }\\}，这个标签就是用来书写变量的，通过在配置处配置变量，或者使用系统的自定义变量，可以轻松改变页面内的一些元素或者内容。 系统变量查询可以去这里 其实整个主题书写就是这么简单，如果有不清楚的可以再看看官网的文档。动一动手就非常明白了。 插入图片很多人感觉用Jekyll最不方便的就是插入图片了，其实我也是这么觉得的。所以只能自己去想些办法。 图片统一存放图片我都放在了/public/upload下，所以我在插入图片的时候只要用![xxx](http://7u2ho6.com1.z0.glb.clouddn.com/xxx)就可以了。 方便的图片导入导入图片的方式是我将upload文件夹做了个软连接，放到mac的dock上就行了，有图片要用的时候直接往里面一拖。 方便的截图很多时候图片都是现截取的，比如用QQ的截图工具，或者系统的截图工具，但是他们截取完都存放在了user/Pictures里面，来回移动太累了。我这里介绍一个Mac下的一个工具——Trickster，看图 这个工具可以看到刚刚修改过的图片，而且还有一个收藏的文件夹，我每次截取完图以后，从左边往右边一拖，然后在markdown中就可以继续书写了。一点都不耗时。 本地预览及提交本地预览自己的修改很容易，只要进入username.github.io目录，执行 1jekyll serve 然后访问http://localhost:4000就OK了，安装Jekyll的方式自行谷歌吧… 自己预览过没有问题以后，就提交到服务端吧，Git三步走 123git add xxxgit commit -m &quot;xxx&quot;git push 其他我觉得自己的这个主题设定的算是比较好修改和移植的了，如果大家有什么问题，可以尽管问。 另外一些特别的功能，比如三栏、评论、谷歌分析，这些都不难，相信你稍微打开Github读一下这个主题的代码就很快明白了。 代码地址戳这里","tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://www.devzou.com/tags/Jekyll/"}]},{"title":"SEO 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2015-02-13-general-seo-resources/","text":"小技巧URL中用-分割单词，用_关联单词Google 会把 a-good_reource-of-seo.html 拆分成关键字：a, good_resource, of 和 seo。","tags":[{"name":"SEO","slug":"SEO","permalink":"https://www.devzou.com/tags/SEO/"}]},{"title":"MySQL常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2014-05-11-general-mysql-resources/","text":"安装数据库 1、先到mysql官网上下载dmg格式安装包，进行安装。 2、安装完后，命别名： 12alias mysql=/usr/local/mysql/bin/mysqlalias mysqladmin=/usr/local/mysql/bin/mysqladmin 给root创建密码：1/usr/local/mysql/bin/mysqladmin -u root password root 通过shell连接到数据库cd /usr/local/mysql启动sudo support-files/mysql.server start重启sudo support-files/mysql.server restart停止sudo support-files/mysql.server stop 2.连接到数据库:mysql -h localhost -uroot -p 登录数据库mysql -h localhost -uroot -p 导出数据库mysqldump -uroot -p db &gt; db.sql 导入数据库mysql -uroot -p db &lt; db.sql // or mysql -uroot -p db -e &quot;source /path/to/db.sql&quot; 开启远程登录grant all privileges on ss.* to &apos;root&apos;@&apos;%&apos; indentified by &apos;passoword&apos; with grant option; // or update user set Host=&quot;%&quot; and User=&quot;root&quot; // 注意%是不包含localhost的 flush privileges; 创建用户CREATE USER &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;; grant all privileges on *.* to test@&apos;localhost&apos; identified by &apos;test&apos;; 创建表CREATE SCHEMA testdb DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci; 赋予数据库权限GRANT ALL ON testdb.* TO &apos;test&apos;@&apos;localhost&apos;; 其他常用命令show databases; //显示所有的数据库 create database chinacity; //创建名为chinacity的数据库 drop database chinacity; //删除名为chinacity的数据库 use mysql; //使用mysql数据库 show tables from mysql; //查看某个数据库中的表","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.devzou.com/tags/MySQL/"}]},{"title":"用Xdebug和Sublime调试PHP代码","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/git/2014-03-20-php-debug-with-xdebug/","text":"安装xdebug在mac下非常方便： brew install php55-xdebug 然后进行配置，在/usr/local/etc/php/5.5/conf.d/ext-xdebug.ini中添加 xdebug.remote_enable=1 xdebug.remote_handler=dbgp xdebug.remote_host=127.0.0.1 xdebug.remote_port=9000 xdebug.remote_log=&quot;/var/log/xdebug/xdebug.log&quot; 重启apache sudo apachectl restart 配置sublime要调试某一个项目，首先得把这个项目在sublime下保存成一个project sublime-&gt;project-&gt;save project as ... 然后用package control安装xdebug client 接下来配置项目 sublime-&gt;project-&gt;edit poject 配置文件类似以下内容： { &quot;folders&quot;: [ { &quot;follow_symlinks&quot;: true, &quot;path&quot;: &quot;.&quot; } ], &quot;settings&quot;: { &quot;xdebug&quot;: { &quot;url&quot;: &quot;http://my.local.website/&quot;, } } } 其中url是项目所在url，记得在hosts里头将这个url指向127.0.0.1，还有在apache的virtualhost里将其指向项目根目录 这样就OK了，准备开启调试吧 开启调试开启调试方式也比较简单，在想要加断点的地方右键 xdebug-&gt;Add/Remove breakpoint 这样项目在运行到本行的时候就会停止下来 然后开始调试，在菜单栏选择 tools-&gt;xdebug-&gt;start debugging(launch browser) sublime会自动打开浏览器，进入配置时写的网站链接，进行调试 调试中所用的功能可以在调试文件中右键查看之 可能问题无法跟踪断点这可能是xdebug端口被占用，按Ctrl+`或者菜单栏View-&gt;show Console查看错误信息，有可能是xdebug端口已经被占用的缘故。 在sublime xdebug中关闭调试，或者重启sublime可以解决这个问题。 参考 Debugging with Xdebug and Sublime Text 3","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.devzou.com/tags/PHP/"}]},{"title":"Vim 常用资源","date":"2016-10-15T03:14:06.000Z","path":"2016/10/15/resource/2015-10-04-general-vim-resources/","text":"在粘贴代码时不启动自动缩进粘贴之前输入 :set paste粘贴完后恢复 :set nopaste 关闭和开启行号关闭 :set nonu开启 :set number","tags":[{"name":"Vim","slug":"Vim","permalink":"https://www.devzou.com/tags/Vim/"}]}]